<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="个人学习笔记，将对知识点进行概述，主要学习请参考B站江科大的视频。或者STM32手册。">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32归档">
<meta property="og:url" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/index.html">
<meta property="og:site_name" content="来自星星的弦乐">
<meta property="og:description" content="个人学习笔记，将对知识点进行概述，主要学习请参考B站江科大的视频。或者STM32手册。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802090509772.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092111160.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092501391.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092609813.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092744941.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093041456.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093323996.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093547488.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085322283.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085339575.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804091214547.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140450873.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140815853.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804141911813.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142052238.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142120741.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804143658827.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160531114.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160614690.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804161013946.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230805151849133.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813094959667.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100353705.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100243577.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100827977.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100920081.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113020376.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113501182.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813121832130.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122009533.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122038841.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/STM32%E5%BD%92%E6%A1%A3/image-20230813124428753.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906144618584.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/STM32%E5%BD%92%E6%A1%A3/image-20230906144635542.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906150101596.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906161718832.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906162701392.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906163019452.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907132353584.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135103458.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135147731.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135338333.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907140812970.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907143237498.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907162801097.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908100020216.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105311721.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105519483.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105542093.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908211901582.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909134000653.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141006160.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909140814309.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141225078.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141515783.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145103684.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145559280.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145836537.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145914699.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150013914.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150438360.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212035982.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212111665.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212244338.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212521710.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213052577.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213356192.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213909958.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230923092407230.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926133507630.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134153532.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134322264.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/STM32%E5%BD%92%E6%A1%A3/image-20230926210423747.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210537974.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210641784.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210653469.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210745962.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210802474.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210847282.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210952604.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/STM32%E5%BD%92%E6%A1%A3/image-20230926211002416.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112711694.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112818035.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113322761.png">
<meta property="og:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113344291.png">
<meta property="article:published_time" content="2023-08-02T00:57:24.000Z">
<meta property="article:modified_time" content="2023-09-28T04:19:35.213Z">
<meta property="article:author" content="星戏溪行">
<meta property="article:tag" content="单片机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802090509772.png">


<link rel="canonical" href="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/","path":"2023/08/02/STM32归档/","title":"STM32归档"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>STM32归档 | 来自星星的弦乐</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2adf217e938bc0432386afe319c0e750"></script>






<link rel="dns-prefetch" href="waline-ecru-theta.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">来自星星的弦乐</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">| ❀ ❀ ❀ 踏梦携猫荡蓝海 ❀ ❀ ❀| | ☆ ☆ ☆ 引虹径行启银光 ☆ ☆ ☆|</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-茶馆"><a href="/comments/" rel="section"><i class="fas fa-comments fa-fw"></i>茶馆</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GPIO"><span class="nav-number">1.</span> <span class="nav-text">GPIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GPIO%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">GPIO简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">GPIO基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GPIO%E4%BD%8D%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">GPIO位结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPIO%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">GPIO模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%A9%BA-x2F-%E4%B8%8A%E6%8B%89-x2F-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">浮空&#x2F;上拉&#x2F;下拉输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5"><span class="nav-number">1.2.2.</span> <span class="nav-text">模拟输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%BC%8F-x2F-%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.3.</span> <span class="nav-text">开漏&#x2F;推挽输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E5%BC%80%E6%BC%8F-x2F-%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="nav-number">1.2.4.</span> <span class="nav-text">复用开漏&#x2F;推挽输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%AE%BEGPIO%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.5.</span> <span class="nav-text">外设GPIO配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.6.</span> <span class="nav-text">示例程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NVIC"><span class="nav-number">2.</span> <span class="nav-text">NVIC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">中断系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STM32%E4%B8%AD%E6%96%AD"><span class="nav-number">2.1.1.</span> <span class="nav-text">STM32中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NVIC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">NVIC的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NVIC%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">NVIC优先级分组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="nav-number">2.2.</span> <span class="nav-text">EXTI外部中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EXTI%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">EXTI简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXTI%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">EXTI的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFIO%E5%A4%8D%E7%94%A8IO%E5%8F%A3"><span class="nav-number">2.2.3.</span> <span class="nav-text">AFIO复用IO口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXTI%E6%A1%86%E5%9B%BE"><span class="nav-number">2.2.4.</span> <span class="nav-text">EXTI框图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">2.2.5.</span> <span class="nav-text">示例程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TIM%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">TIM简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">定时器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.2.2.</span> <span class="nav-text">通用定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text">高级定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.3.</span> <span class="nav-text">定时器结构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">3.3.1.</span> <span class="nav-text">定时中断基本结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%88%86%E9%A2%91%E5%99%A8%E6%97%B6%E5%BA%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">预分频器时序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E5%BA%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">计数器时序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%A0%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">计数器无预装时序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%9C%89%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">计数器有预装时序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RCC%E6%97%B6%E9%92%9F%E6%A0%91"><span class="nav-number">3.3.4.</span> <span class="nav-text">RCC时钟树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-2"><span class="nav-number">3.3.5.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%EF%BC%88%E5%86%85%E9%83%A8%E6%97%B6%E9%92%9F%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">配置过程（内部时钟为例）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%EF%BC%88%E5%86%85%E9%83%A8%E6%97%B6%E9%92%9F%EF%BC%89%EF%BC%9A"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">定时器中断（内部时钟）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F"><span class="nav-number">3.3.5.3.</span> <span class="nav-text">定时器外部时钟</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PWM"><span class="nav-number">4.</span> <span class="nav-text">PWM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">PWM简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%AE%80%E4%BB%8B"><span class="nav-number">4.2.</span> <span class="nav-text">输出比较简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%80%9A%E9%81%93-%E9%AB%98%E7%BA%A7"><span class="nav-number">4.2.1.</span> <span class="nav-text">输出比较通道(高级)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%80%9A%E9%81%93-%E9%80%9A%E7%94%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">输出比较通道(通用)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">输出比较模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">4.4.</span> <span class="nav-text">PWM基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-3"><span class="nav-number">4.5.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEPWM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.5.1.</span> <span class="nav-text">配置PWM初始化程序的一般步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWM%E9%A9%B1%E5%8A%A8LED%E5%91%BC%E5%90%B8%E7%81%AF"><span class="nav-number">4.5.2.</span> <span class="nav-text">PWM驱动LED呼吸灯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWM%E9%A9%B1%E5%8A%A8%E8%88%B5%E6%9C%BA"><span class="nav-number">4.5.3.</span> <span class="nav-text">PWM驱动舵机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7"><span class="nav-number">5.</span> <span class="nav-text">输入捕获</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.</span> <span class="nav-text">输入捕获简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%91%E7%8E%87%E6%B5%8B%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">频率测量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%80%9A%E9%81%93"><span class="nav-number">5.3.</span> <span class="nav-text">输入捕获通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">主从触发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">5.5.</span> <span class="nav-text">输入捕获基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PWMI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">5.6.</span> <span class="nav-text">PWMI基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-4"><span class="nav-number">5.7.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.7.1.</span> <span class="nav-text">一般配置步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87"><span class="nav-number">5.7.2.</span> <span class="nav-text">输入捕获模式测频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWMI%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="nav-number">5.7.3.</span> <span class="nav-text">PWMI模式测频率占空比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.8.</span> <span class="nav-text">编码器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="nav-number">5.8.1.</span> <span class="nav-text">编码器接口简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">5.8.2.</span> <span class="nav-text">正交编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">5.8.3.</span> <span class="nav-text">编码器接口基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.8.4.</span> <span class="nav-text">工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-5"><span class="nav-number">5.8.5.</span> <span class="nav-text">示例程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ADC"><span class="nav-number">6.</span> <span class="nav-text">ADC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E7%AE%80%E4%BB%8B"><span class="nav-number">6.1.</span> <span class="nav-text">ADC简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E6%AC%A1%E9%80%BC%E8%BF%91%E5%9E%8BADC"><span class="nav-number">6.2.</span> <span class="nav-text">逐次逼近型ADC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E6%A1%86%E5%9B%BE"><span class="nav-number">6.3.</span> <span class="nav-text">ADC框图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">6.4.</span> <span class="nav-text">ADC基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93"><span class="nav-number">6.5.</span> <span class="nav-text">输入通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E7%BB%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.6.</span> <span class="nav-text">规则组的四种转换模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%AC%A1%E8%BD%AC%E6%8D%A2%EF%BC%8C%E9%9D%9E%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.6.1.</span> <span class="nav-text">单次转换，非扫描模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2%EF%BC%8C%E9%9D%9E%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.6.2.</span> <span class="nav-text">连续转换，非扫描模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%AC%A1%E8%BD%AC%E6%8D%A2%EF%BC%8C%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.6.3.</span> <span class="nav-text">单次转换，扫描模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2%EF%BC%8C%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.6.4.</span> <span class="nav-text">连续转换，扫描模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">6.7.</span> <span class="nav-text">触发控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-number">6.8.</span> <span class="nav-text">数据对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="nav-number">6.9.</span> <span class="nav-text">转换时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%A1%E5%87%86"><span class="nav-number">6.10.</span> <span class="nav-text">校准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="nav-number">6.11.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-6"><span class="nav-number">6.12.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.12.1.</span> <span class="nav-text">一般步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AD%E5%8D%95%E9%80%9A%E9%81%93"><span class="nav-number">6.12.2.</span> <span class="nav-text">AD单通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AD%E5%A4%9A%E9%80%9A%E9%81%93"><span class="nav-number">6.12.3.</span> <span class="nav-text">AD多通道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DMA"><span class="nav-number">7.</span> <span class="nav-text">DMA</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E7%AE%80%E4%BB%8B"><span class="nav-number">7.1.</span> <span class="nav-text">DMA简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F"><span class="nav-number">7.2.</span> <span class="nav-text">存储器映像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E6%A1%86%E5%9B%BE"><span class="nav-number">7.3.</span> <span class="nav-text">DMA框图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.</span> <span class="nav-text">DMA基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E8%AF%B7%E6%B1%82"><span class="nav-number">7.5.</span> <span class="nav-text">DMA请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E5%AF%B9%E9%BD%90"><span class="nav-number">7.6.</span> <span class="nav-text">数据宽度与对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-DMA"><span class="nav-number">7.7.</span> <span class="nav-text">数据转运+DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADC%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F-DMA"><span class="nav-number">7.8.</span> <span class="nav-text">ADC扫描模式+DMA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-7"><span class="nav-number">7.9.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90"><span class="nav-number">7.9.1.</span> <span class="nav-text">DMA数据转运</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-AD%E5%A4%9A%E9%80%9A%E9%81%93"><span class="nav-number">7.9.2.</span> <span class="nav-text">DMA+AD多通道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#USART%E4%B8%B2%E5%8F%A3"><span class="nav-number">8.</span> <span class="nav-text">USART串口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.1.</span> <span class="nav-text">通信接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-1"><span class="nav-number">8.2.</span> <span class="nav-text">硬件电路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86"><span class="nav-number">8.3.</span> <span class="nav-text">电平标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%82%E6%95%B0%E5%8F%8A%E6%97%B6%E5%BA%8F"><span class="nav-number">8.4.</span> <span class="nav-text">串口参数及时序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%97%B6%E5%BA%8F"><span class="nav-number">8.4.1.</span> <span class="nav-text">串口时序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USART%E5%A4%96%E8%AE%BE%E7%AE%80%E4%BB%8B"><span class="nav-number">8.5.</span> <span class="nav-text">USART外设简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USART%E6%A1%86%E5%9B%BE"><span class="nav-number">8.6.</span> <span class="nav-text">USART框图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USART%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">8.7.</span> <span class="nav-text">USART基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="nav-number">8.7.1.</span> <span class="nav-text">数据帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E4%BE%A6%E6%B5%8B"><span class="nav-number">8.7.2.</span> <span class="nav-text">起始位侦测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="nav-number">8.7.3.</span> <span class="nav-text">数据采样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="nav-number">8.8.</span> <span class="nav-text">波特率发生器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.9.</span> <span class="nav-text">数据模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-8"><span class="nav-number">8.10.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81-x2F-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">8.10.1.</span> <span class="nav-text">串口发送&#x2F;接收数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="nav-number">8.10.2.</span> <span class="nav-text">数据包</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->
			<link rel="stylesheet" href="/dist/APlayer.min.css">  
			<div id="aplayer"></div>
			<script type="text/javascript" src="/dist/APlayer.min.js"></script>
			<script type="text/javascript" src="/dist/music.js"></script>
        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="星戏溪行"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">星戏溪行</p>
  <div class="site-description" itemprop="description">我和挚友的Shelter</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/02/STM32%E5%BD%92%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="星戏溪行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="来自星星的弦乐">
      <meta itemprop="description" content="我和挚友的Shelter">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="STM32归档 | 来自星星的弦乐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STM32归档
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-02 08:57:24" itemprop="dateCreated datePublished" datetime="2023-08-02T08:57:24+08:00">2023-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-28 12:19:35" itemprop="dateModified" datetime="2023-09-28T12:19:35+08:00">2023-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/stm32%E5%BD%92%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">stm32归档</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>51 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>个人学习笔记，将对知识点进行概述，主要学习请参考B站江科大的视频。或者STM32手册。<span id="more"></span></p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="GPIO简介"><a href="#GPIO简介" class="headerlink" title="GPIO简介"></a>GPIO简介</h2><p>•GPIO（General Purpose Input Output）通用输入输出口</p>
<p>•可配置为8种输入输出模式</p>
<p>•引脚电平：0V~3.3V，部分引脚可容忍5V</p>
<p>•输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</p>
<p>•输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
<h3 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802090509772.png" class="" title="image-20230802090509772">

<p>所有GPIO都挂载在APB2总线上。PA0~PB15为GPIO外设引脚</p>
<p><strong>寄存器</strong>是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，以完成输出电平和读取电平的功能，但只有低16位才有对应端口。</p>
<p><strong>驱动器</strong>负责增大驱动能力。</p>
<h4 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092111160.png" class="" title="image-20230802092111160">

<h2 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092501391.png" class="" title="image-20230802092501391">

<p>推挽输出的高低电平均有较强的驱动能力。</p>
<h3 id="浮空-x2F-上拉-x2F-下拉输入"><a href="#浮空-x2F-上拉-x2F-下拉输入" class="headerlink" title="浮空&#x2F;上拉&#x2F;下拉输入"></a>浮空&#x2F;上拉&#x2F;下拉输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092609813.png" class="" title="image-20230802092609813">

<p>在输入模式下，出入驱动器断开。</p>
<h3 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092744941.png" class="" title="image-20230802092744941">

<p>使用ADC的专用配置。输入和输出驱动器都断开无效，信号从引脚后，直接进入片上外设。</p>
<h3 id="开漏-x2F-推挽输出"><a href="#开漏-x2F-推挽输出" class="headerlink" title="开漏&#x2F;推挽输出"></a>开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093041456.png" class="" title="image-20230802093041456">

<p>一个端口可以有多个输入，但只能有一个输出。通过输出驱动器的MOS管，可以控制输出为推挽或开漏模式。</p>
<h3 id="复用开漏-x2F-推挽输出"><a href="#复用开漏-x2F-推挽输出" class="headerlink" title="复用开漏&#x2F;推挽输出"></a>复用开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093323996.png" class="" title="image-20230802093323996">

<p>输出控制由片上外设控制，输入时，片上外设和输入驱动器都有效。</p>
<h3 id="外设GPIO配置"><a href="#外设GPIO配置" class="headerlink" title="外设GPIO配置"></a>外设GPIO配置</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093547488.png" class="" title="image-20230802093547488">

<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><details>  <summary><font size="4" color="orange">流水灯</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                      // 延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启APB2时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //为结构体命名
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        //设为GPIO为推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;             //所有引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       //输出速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_Write(GPIOA, ~0x0001);	//0000 0000 0000 0001   //一次写入16个端口，控制GPIO
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0002);	//0000 0000 0000 0010
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0004);	//0000 0000 0000 0100
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0008);	//0000 0000 0000 1000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0010);	//0000 0000 0001 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0020);	//0000 0000 0010 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0040);	//0000 0000 0100 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0080);	//0000 0000 1000 0000
        Delay_ms(100);
    &#125;
&#125;
</code> </pre> </details>


<details> 
<summary><font size="4" color="orange">LED闪烁</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                     //延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //结构体，初始化GPIO
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       //推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;              //初始化的引脚为GPIOA的pin0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;      //运行速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_ResetBits(GPIOA, GPIO_Pin_0);             //把pin0置为低电平
        Delay_ms(500);
        GPIO_SetBits(GPIOA, GPIO_Pin_0);               //把pin0置为高电平
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1);
        Delay_ms(500);
    &#125;
&#125;
</code>
</pre> </details>




<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断：　　　　　在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p>
<p>中断优先级：　　当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p>
<p>中断嵌套：　　　当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</p>
<p><strong>中断执行流程</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085322283.png" class="" title="image-20230803085322283">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085339575.png" class="" title="image-20230803085339575">

<p>程序由硬件电路自动跳转到中断程序中</p>
<h3 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a><strong>STM32中断</strong></h3><p>•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p>
<p>•使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。  </p>
<p>内核中断：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804091214547.png" class="" title="image-20230804091214547">

<h3 id="NVIC的基本结构"><a href="#NVIC的基本结构" class="headerlink" title="NVIC的基本结构"></a>NVIC的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140450873.png" class="" title="image-20230804140450873">

<p>一个外设可能占用多个中断通道</p>
<h3 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h3><p>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p>
<p>•抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140815853.png" class="" title="image-20230804140815853">

<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><h3 id="EXTI简介"><a href="#EXTI简介" class="headerlink" title="EXTI简介"></a>EXTI简介</h3><p>•EXTI（Extern Interrupt）外部中断</p>
<p>•EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p>
<p>•支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p>
<p>•支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断。（PA1和PB1不能同时用）</p>
<p>•通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
<p>•触发响应方式：中断响应&#x2F;事件响应</p>
<p>中断响应：让CPU执行中断函数</p>
<p>事件响应：当外部中断检测到引脚变化时，中断信号就不会通向CPU了，而是通到其它外设，用来触发其它外设的操作（ADC,DMA）属于外设之间的联合工作。</p>
<h3 id="EXTI的基本结构"><a href="#EXTI的基本结构" class="headerlink" title="EXTI的基本结构"></a>EXTI的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804141911813.png" class="" title="image-20230804141911813">

<h3 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h3><p>•AFIO主要用于引脚复用功能的选择和重定义</p>
<p>•在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142052238.png" class="" title="image-20230804142052238">

<h3 id="EXTI框图"><a href="#EXTI框图" class="headerlink" title="EXTI框图"></a>EXTI框图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142120741.png" class="" title="image-20230804142120741">

<h3 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>配置过程：</strong></p>
<p>1.　　　　配置RCC,把涉及的外设时钟都打开GPIO,AFIO，（无需：NVIC,EXTI）<br>2.　　　　配置GPIO，选择端口为输入模式<br>3.　　　　配置AFIO，选择所需的GPIO链接EXTI。<br>4.　　　　配置EXTI，选择触发方式和响应方式。（一般为边沿触发，中断响应）<br>5.　　　　配置NVIC，选择合适的优先级。</p>
<p>最后，通过NVIC，外部中断信号进入CPU。</p>
<p><strong>对射式红外传感器计次</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804143658827.png" class="" title="image-20230804143658827">

<p>挡光片在对射式红外传感器中间经过时，D0输出电平跳变，触发PB14号IO口的中断。</p>
<details>  <summary><font size="4" color="orange">代码</font></summary>  <pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
uint16_t CountSensor_Count;
void CountSensor_Init(void)
&#123;
//开启相关时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
//利用结构体配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;                     
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
//选择中断线
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
//利用结构体配置EXTI
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line14;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
//利用结构体配置NVIC
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
&#125;
uint16_t CountSensor_Get(void)
&#123;
    return CountSensor_Count;
&#125;
void EXTI15_10_IRQHandler(void)       //中断函数，函数名不可自定义
&#123;
    if (EXTI_GetITStatus(EXTI_Line14) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
        &#123;
            CountSensor_Count ++;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line14);
    &#125;
&#125;
</code> </pre> </details>
**螺旋编码器计次**

<p>螺旋编码器可用于测量位置，速度或旋转方向，当其旋转轴旋转时，其输出端额可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度与方向。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160531114.png" class="" title="image-20230804160531114">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160614690.png" class="" title="image-20230804160614690">

<p>默认无旋转时，此时上拉为高电平，并输出到A端口，当旋转时内部触电导通，此时因为连接GND，A端口就为低电平。</p>
<p>旋转轴旋转时，此时两触点以相位相差90度的方式交替导通。</p>
<p>示例连接图：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804161013946.png" class="" title="image-20230804161013946">

<details> 
<summary><font size="4" color="orange">主函数</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Encoder.h"
int16_t Num;
int main(void)
&#123;
    OLED_Init();                     //初始化OLED屏幕
    Encoder_Init();
    OLED_ShowString(1, 1, "Num:");   //OLED显示函数
    while (1)
    &#123;
        Num += Encoder_Get();
        OLED_ShowSignedNum(1, 5, Num, 5);
    &#125;
&#125;
</code>
</pre> </details>

<details> 
<summary><font size="4" color="orange">Encoder.c</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
int16_t Encoder_Count;
//初始化，配置相关IO口，中断。
void Encoder_Init(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);
    GP_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    NVIC_Init(&NVIC_InitStructure);
&#125;
//放回count的变化值
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = Encoder_Count;
    Encoder_Count = 0;
    return Temp;
&#125;
//中断程序，执行计数
void EXTI0_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line0) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
            &#123;
                Encoder_Count --;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line0);
    &#125;
&#125;
void EXTI1_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line1) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
            &#123;
                Encoder_Count ++;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line1);
    &#125;
&#125;
</code>
</pre> </details>


<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h2><p>•TIM（Timer）定时器</p>
<p>•定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p>
<p>•16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p>
<p>•不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p>
<p>•根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
<p>应用：利用输出比较功能，可以产生PWM波形，驱动电机。输入捕获功能，可以实现测量方波频率。定时器的编码器接口，也可以更方便的读取正交编码器的输出波形。</p>
<h2 id="定时器类型"><a href="#定时器类型" class="headerlink" title="定时器类型"></a>定时器类型</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230805151849133.png" class="" title="image-20230805151849133">

<p>高级定时器可用于三相无刷电机。</p>
<p>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4。</p>
<h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813094959667.png" class="" title="image-20230813094959667">

<p>基本定时器一般是连接到内部时钟（72MHz），经过预分频器进行分频。比如：预分频器写0就是不分频或者（1分频），输出频率&#x3D;输入频率&#x3D;72M，写1就是二分频，输出&#x3D;输入&#x2F;2&#x3D;36M，以此类推。这个预分频器是16位，最大值可填65535，也就是65536分频。分频后计数器（16位）会不断自增，通过自动重装寄存器（16位）可以控制计数时间。当计数&#x3D;自动重装值，计数清零，输出中断。</p>
<p><strong>主从模式触发ADC</strong>  </p>
<p>能让内部的硬件在不受程序的控制下实现自动运行。</p>
<h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100353705.png" class="" title="image-20230813100353705">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100243577.png" class="" title="image-20230813100243577">

<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100827977.png" class="" title="image-20230813100827977">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100920081.png" class="" title="image-20230813100920081">

<h2 id="定时器结构详解"><a href="#定时器结构详解" class="headerlink" title="定时器结构详解"></a>定时器结构详解</h2><h3 id="定时中断基本结构图"><a href="#定时中断基本结构图" class="headerlink" title="定时中断基本结构图"></a>定时中断基本结构图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113020376.png" class="" title="image-20230813113020376">

<h3 id="预分频器时序"><a href="#预分频器时序" class="headerlink" title="预分频器时序"></a>预分频器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113501182.png" class="" title="image-20230813113501182">

<p>•计数器计数频率：CK_CNT &#x3D; CK_PSC &#x2F; (PSC + 1)</p>
<h3 id="计数器时序"><a href="#计数器时序" class="headerlink" title="计数器时序"></a>计数器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813121832130.png" class="" title="image-20230813121832130">

<p>•计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)&#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p>
<h4 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h4> <img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122009533.png" class="" title="image-20230813122009533">

<h4 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122038841.png" class="" title="image-20230813122038841">

<p>如果引入影子寄存器，当自动加载寄存器的值更改后，当前计数周期结束后，才会更改自动加载寄存器的值。实际上为了同步，让值的变化和事件的更新同步发生，防止运行途中由于更改所造成的错误。</p>
<p>比如：原本计时50秒，闹钟响起。计时到45秒时，改为计时到30秒响起闹钟。那么则是45-&gt;60-&gt;0-&gt;30，闹钟才会想起。引入影子寄存器后，则是45-&gt;50，响起闹钟，下一个周期：0-&gt;30再响起一次闹钟。</p>
<h3 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h3><p>STM32用来产生和配置时钟.并吧配置好的时钟发送到各个外设系统。SystemInit就是用来配置时钟树的。</p>
<img src="STM32%E5%BD%92%E6%A1%A3/image-20230813124428753.png" alt="image-20230813124428753" style="zoom:150%;" />

<p>左边是产生时钟电路，右边则是分配电路。两个高速时钟是为系统提供时钟的。一般外部晶振比内部稳定，所以一般使用外部晶振。</p>
<p>SystemInit配置时钟过程：先开启内部8Mhz晶振作为系统时钟，再开启外部时钟（一般为8M），经过倍频且稳定后变为72M，再代替原来内部的8M作为系统时钟。所以，如果外部时钟出了问题，则切换为内部时钟。8M和72M相比，大概慢了10倍。</p>
<h3 id="示例程序-2"><a href="#示例程序-2" class="headerlink" title="示例程序"></a>示例程序</h3><h4 id="配置过程（内部时钟为例）："><a href="#配置过程（内部时钟为例）：" class="headerlink" title="配置过程（内部时钟为例）："></a>配置过程（内部时钟为例）：</h4><p>1.　　RCC开启时钟，此时基准时钟和整个外设的工作时钟都被打开。</p>
<p>2.　　选择时基单元的时钟源（内部时钟模式）</p>
<p>3.　　配置时基单元<br>4.　　配置输出中断控制，允许更新中断输出到NVIC<br>5.　　配置NVIC，打开中断通道，并分配优先级</p>
<h4 id="定时器中断（内部时钟）："><a href="#定时器中断（内部时钟）：" class="headerlink" title="定时器中断（内部时钟）："></a>定时器中断（内部时钟）：</h4>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
uint16_t Num; 
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init(); 
//
    OLED_ShowString(1, 1, "Num:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5); // 在OLED屏幕上显示变量Num的值，位于第1行第5列，总宽度为5个字符
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32库的头文件
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 				// 启用TIM2的时钟
    TIM_InternalClockConfig(TIM2); 										// 配置TIM2的时钟源为内部时钟
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;                 //结构体
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		// 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 	// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; 					// ARR自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; 				// PSC预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; 				//重复计数器的值（只有高级定时器才有）
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 				// 初始化TIM2的时间基准单元
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 								// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 							// 启用TIM2的更新中断
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 					// 配置NVIC的优先级分组为组2
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;						// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 					// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 			// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 					// 配置子优先级为1
    NVIC_Init(&NVIC_InitStructure); 									// 初始化NVIC
    TIM_Cmd(TIM2, ENABLE); 												// 启用TIM2定时器
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);         // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
        void Timer_Init(void);
//
#endif
</code> </pre> </details>

<h4 id="定时器外部时钟"><a href="#定时器外部时钟" class="headerlink" title="定时器外部时钟"></a>定时器外部时钟</h4>

<p>使用对射式红外传感器来模拟外部时钟。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
//
uint16_t Num; 
//
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init();
    OLED_ShowString(1, 1, "Num:"); 
    OLED_ShowString(2, 1, "CNT:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5);
        OLED_ShowNum(2, 5, Timer_GetCounter(), 5);
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);       // 启用TIM2的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);     // 启用GPIOA的时钟
//
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;			 // 配置GPIOA的引脚模式为上拉输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 				// 配置GPIOA的引脚为引脚0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 		// 配置GPIOA的引脚速度为50MHz
    GPIO_Init(GPIOA, &GPIO_InitStructure); 					// 初始化GPIOA
// 配置TIM2的外部时钟源模式
    TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x0F); 
//结构体配置
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;				 // 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 		// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10-1; 		// 自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1-1; 		// 预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 	// 初始化TIM2的时间基准单元
//
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 		// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 	// 启用TIM2的更新中断
//
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 配置NVIC的优先级分组为组2
//
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 				// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 				// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 		// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 				// 配置响应优先级为1
    NVIC_Init(&NVIC_InitStructure); 								// 初始化NVIC
//
    TIM_Cmd(TIM2, ENABLE);											 // 使能TIM2定时器
&#125;
//
uint16_t Timer_GetCounter(void)
&#123;
    return TIM_GetCounter(TIM2); // 获取TIM2计数器的当前值
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
void Timer_Init(void);
uint16_t Timer_GetCounter(void);
//
#endif
</code> </pre> </details>


<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>•　PWM（Pulse Width Modulation）脉冲宽度调制</p>
<p>•　在具有<strong>惯性</strong>的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</p>
<p>•　PWM参数：</p>
<p>   频率 &#x3D; 1 &#x2F; TS      占空比 &#x3D; TON &#x2F; TS      分辨率 &#x3D; 占空比变化步距</p>
<p>简单说，Ts代表一个高低电平变换周期的时间，占空比决定PWM等效出来的模拟电压的大小，分辨率则可以理解为变化的精细，比如：1% → 2%，分辨率为1%。1.1% → 1.2%，分辨率为0.1%</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906144618584.png" class="" title="image-20230906144618584"><img src="STM32%E5%BD%92%E6%A1%A3/image-20230906144635542.png" alt="image-20230906144635542" style="zoom:80%;" />



<p>PWM需要用到输出比较，所以先介绍一下stm32的输出比较功能。</p>
<h2 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h2><p>•　OC（Output Compare）输出比较</p>
<p>•　IC（Input Capture） 输入捕获</p>
<p>•　CC（Capture&#x2F;Compare）输出比较和输入捕获</p>
<p>•　输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<p>•　每个高级定时器和通用定时器都拥有4个输出比较通道</p>
<p>•　高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p>
<h3 id="输出比较通道-高级"><a href="#输出比较通道-高级" class="headerlink" title="输出比较通道(高级)"></a>输出比较通道(高级)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906150101596.png" class="" title="image-20230906150101596">

<h3 id="输出比较通道-通用"><a href="#输出比较通道-通用" class="headerlink" title="输出比较通道(通用)"></a>输出比较通道(通用)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906161718832.png" class="" title="image-20230906161718832">

<p>比较CNT（计数器）和CCR（捕获比较寄存器）的值，会改变oc1ref（ref：参考信号）的输出电平。（信号可映射至主模式控制器。）输出经过极性选择（是否翻转电平，0为不翻转），最后输出。</p>
<h2 id="输出比较模式"><a href="#输出比较模式" class="headerlink" title="输出比较模式"></a>输出比较模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906162701392.png" class="" title="image-20230906162701392">



<h2 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906163019452.png" class="" title="image-20230906163019452">

<p>参数计算：</p>
<p>•　PWM频率：　　Freq &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)　　　</p>
<p>•　PWM占空比：　Duty &#x3D; CCR &#x2F; (ARR + 1)</p>
<p>•　PWM分辨率：　Reso &#x3D; 1 &#x2F; (ARR + 1)</p>
<h2 id="示例程序-3"><a href="#示例程序-3" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="配置PWM初始化程序的一般步骤"><a href="#配置PWM初始化程序的一般步骤" class="headerlink" title="配置PWM初始化程序的一般步骤"></a>配置PWM初始化程序的一般步骤</h3><p>1.　开启TIM外设和GPIO外设的时钟。<br>2.　配置时基单元。<br>3.　配置输出比较单元。CCR的值，输出比较模式，极性选择，输出使能<br>4.　配置GPIO，PWM对应的GPIO，配置为复用推挽输出<br>5.　运行控制</p>
<h3 id="PWM驱动LED呼吸灯"><a href="#PWM驱动LED呼吸灯" class="headerlink" title="PWM驱动LED呼吸灯"></a>PWM驱动LED呼吸灯</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"     
#include "OLED.h"      
#include "PWM.h"       
//
uint8_t i; 
//
int main(void)
&#123;
    OLED_Init(); 
    PWM_Init();  
//
    while (1)
    &#123;
        // 增加PWM占空比从0到100，使亮度逐渐增大
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(i); // 设置PWM通道1的占空比
            Delay_ms(10);       
        &#125;
        // 降低PWM占空比从100到0，使亮度逐渐减少
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(100 - i); // 设置PWM通道1的占空比
            Delay_ms(10);             
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
void PWM_Init(void)
&#123;
// 启用TIM2时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置TIM2通道1的GPIO引脚
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;     // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM2为内部时钟
    TIM_InternalClockConfig(TIM2);
// 配置TIM2的时基
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;  // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
// 配置TIM2通道1为PWM输出
    TIM_OCInitTypeDef TIM_OCInitStructure;
    TIM_OCStructInit(&TIM_OCInitStructure);
    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStructure.TIM_Pulse = 0; // CCR
    TIM_OC1Init(TIM2, &TIM_OCInitStructure);
// 启用TIM2
    TIM_Cmd(TIM2, ENABLE);
&#125;
void PWM_SetCompare1(uint16_t Compare)
&#123;
    // 设置TIM2通道1的比较值
    TIM_SetCompare1(TIM2, Compare);
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.h</font></summary>  <pre><code class="language-c">
#ifndef __PWM_H
#define __PWM_H
//
void PWM_Init(void);
void PWM_SetCompare1(uint16_t Compare);
//
#endif
</code> </pre> </details>

<h3 id="PWM驱动舵机"><a href="#PWM驱动舵机" class="headerlink" title="PWM驱动舵机"></a>PWM驱动舵机</h3>

<p>•　舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p>
<p>•　输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms　　　　　　<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907132353584.png" class="" title="image-20230907132353584"></p>
<p>　　　</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"  //延时
#include "OLED.h"   
#include "Servo.h"
#include "Key.h"    //按键
// 全局变量声明
uint8_t KeyNum;
float Angle;
int main(void)
&#123;
    // 初始化OLED显示屏、舵机和按键
    OLED_Init();
    Servo_Init();
    Key_Init();
    OLED_ShowString(1, 1, "Angle:");
    while (1)
    &#123;
        // 获取按键状态
        KeyNum = Key_GetNum();
        // 如果按键被按下
        if (KeyNum == 1)
        &#123;
            Angle += 30;     // 增加角度值
            if (Angle > 180)
            &#123;
                Angle = 0;   // 限制在0到180度之间
            &#125;
        &#125;
        // 设置舵机的角度
        Servo_SetAngle(Angle);
        // 在OLED上显示当前角度
        OLED_ShowNum(1, 7, Angle, 3);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Servo.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
//初始化，和示例一的PWM初始化一致
void Servo_Init(void)
&#123;
    PWM_Init();
&#125;
//设置PWM脉冲宽度，并且与角度用公式转换，便于写入和理解
void Servo_SetAngle(float Angle)
&#123;
    PWM_SetCompare2(Angle / 180 * 2000 + 500);
&#125;
</code> </pre> </details>

<h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><h2 id="输入捕获简介"><a href="#输入捕获简介" class="headerlink" title="输入捕获简介"></a>输入捕获简介</h2><p>•　IC（Input Capture）输入捕获</p>
<p>•　输入捕获模式下，当通道输入引脚出现指定电平跳变时，<strong>当前CNT的值将被锁存到CCR中</strong>，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p>
<p>•　每个高级定时器和通用定时器都拥有4个输入捕获通道</p>
<p>•　可配置为PWMI模式，同时测量频率和占空比</p>
<p>•　<strong>可配合主从触发模式，实现硬件全自动测量</strong></p>
<h2 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135103458.png" class="" title="image-20230907135103458">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135147731.png" class="" title="image-20230907135147731">

<h2 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135338333.png" class="" title="image-20230907135338333">

<p>滤波器控制滤波参数，边沿检测器可以捕获信号的上升沿，如果将信号映射至从模式控制器，则可以再捕获之后自动完成CNT的清零工作。</p>
<h2 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907140812970.png" class="" title="image-20230907140812970">

<p>将定时器的内部信号，映射到TRGO引脚，用于触发其它的外设。选择从模式的触发信号源后，可选择从模式控制自身定时器运行。</p>
<h2 id="输入捕获基本结构"><a href="#输入捕获基本结构" class="headerlink" title="输入捕获基本结构"></a>输入捕获基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907143237498.png" class="" title="image-20230907143237498">

<p>只用了一个通道，所以只能测频率</p>
<h2 id="PWMI基本结构"><a href="#PWMI基本结构" class="headerlink" title="PWMI基本结构"></a>PWMI基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907162801097.png" class="" title="image-20230907162801097">

<p>使用2个通道同时捕获一个引脚，CRR1为一整个周期的计数值，CRR2是高电气期间的计数值。则占空比&#x3D;CCR2&#x2F;CCR1</p>
<h2 id="示例程序-4"><a href="#示例程序-4" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般配置步骤"><a href="#一般配置步骤" class="headerlink" title="一般配置步骤"></a>一般配置步骤</h3><p>1.使用RCC开启TIM和GPIO的时钟。</p>
<p>2.初始化GPIO，配置为输入模式，一般为上拉&#x2F;浮空输入</p>
<p>3.配置时基单元，使CNT计数器在内部时钟的驱动下自增运行</p>
<p>4.配置输入捕获单元（包括滤波器，极性选择，直连通道）</p>
<p>5.选择从模式的触发源，选择TI1FP1。</p>
<p>6.选择从模式的触发动作（Reset，自动清零CNT）</p>
<p>7.调用TIM_cmd()启动定时器计数。</p>
<h3 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h3>



<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 自定义头文件，相关程序参考文章前置相关
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
//
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
    OLED_ShowString(1, 1, "Freq:00000Hz");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO，为上拉输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>

<h3 id="PWMI模式测频率占空比"><a href="#PWMI模式测频率占空比" class="headerlink" title="PWMI模式测频率占空比"></a>PWMI模式测频率占空比</h3>

<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率和占空比。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//自定义头文件
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
// OLED显示信息
    OLED_ShowString(1, 1, "Freq:00000Hz");
    OLED_ShowString(2, 1, "Duty:00%");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率和占空比，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5); // 显示频率
        OLED_ShowNum(2, 6, IC_GetDuty(), 2); // 显示占空比
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32标准库头文件
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO为上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_PWMIConfig(TIM3, &TIM_ICInitStructure); //该函数只需传入一个参数，会自动把剩下的通道初始化为相反的配置，仅适用于通道1和通道2
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3计数器
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
// 获取输入捕获模块测得的占空比
uint32_t IC_GetDuty(void)
&#123;
    return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>


<h2 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h2><h3 id="编码器接口简介"><a href="#编码器接口简介" class="headerlink" title="编码器接口简介"></a>编码器接口简介</h3><p>•Encoder Interface 编码器接口</p>
<p>•编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>•每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>•两个输入引脚借用了输入捕获的通道1和通道2（CH1和CH2引脚）</p>
<h3 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h3><p>正交编码器可以输出两个相位相差90°的方波信号。接入stm32，可看成一个带有方向控制的外部时钟。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908100020216.png" class="" title="image-20230908100020216">

<p>使用正交信号精度更高，相当于AB相都参与计次，提高计次频率的同时，也可以抗干扰。</p>
<h3 id="编码器接口基本结构"><a href="#编码器接口基本结构" class="headerlink" title="编码器接口基本结构"></a>编码器接口基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105311721.png" class="" title="image-20230908105311721">

<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105519483.png" class="" title="image-20230908105519483">

<p><strong>实例（均不反相）</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105542093.png" class="" title="image-20230908105542093">

<p><strong>实例（TI1反相）</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908211901582.png" class="" title="image-20230908211901582">

<p>如果接入编码器后，需要调整数据加减的方向，可直接调用极性选择。</p>
<h3 id="示例程序-5"><a href="#示例程序-5" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>编码器测速</strong></p>


<p>选择上拉输入或下拉输入时，应参考外部模块的默认输出电平，保持一致。防止电平冲突。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"       
#include "Delay.h"             
#include "OLED.h"              
#include "Timer.h"             
#include "Encoder.h"           
//
int16_t Speed;                  
//
int main(void)
&#123;
//初始化
    OLED_Init();               
    Timer_Init();              
    Encoder_Init();            
    OLED_ShowString(1, 1, "Speed:");
    while (1)
    &#123;
        Speed = Encoder_Get();  						 	// 获取编码器的值并存储在Speed变量中
        OLED_ShowSignedNum(1, 7, Speed, 5);   // 在OLED上显示Speed的值
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Speed = Encoder_Get();                            // 获取编码器的值并存储在Speed变量中
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);       // 清除定时器2更新中断标志位
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Encoder.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  // 包含STM32标准库的头文件
void Encoder_Init(void)
&#123;
//开启时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
// 配置GPIO引脚模式、速度、和上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3定时器为编码器模式
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3的输入捕获通道1和通道2
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICStructInit(&TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置编码器接口
    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
// 启动TIM3定时器
    TIM_Cmd(TIM3, ENABLE);  
&#125;
//
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = TIM_GetCounter(TIM3);  // 获取TIM3计数器的值
    TIM_SetCounter(TIM3, 0);     // 清零TIM3计数器的值
    return Temp;                  // 返回获取到的值
&#125;
</code> </pre> </details>


<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>•　ADC（Analog-Digital Converter）模拟 - 数字转换器</p>
<p>　DAC则是数字 - 模拟转换器，一般可用PWM平替DAC输出电机所需电压。DAC则可用于波形生成。</p>
<p>•　ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>•　12位逐次逼近型ADC，1us转换时间</p>
<p>•　输入电压范围：0～3.3V，转换结果范围：0～4095</p>
<p>•　18个输入通道，可测量16个外部和2个内部信号源</p>
<p>•　规则组（常规使用）和注入组（突发事件）两个转换单元</p>
<p>•　模拟看门狗自动监测输入电压范围</p>
<p>•　STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<h2 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909134000653.png" class="" title="image-20230909134000653">

<p>首先在通道选择开关选择一路输入（利用地址锁存和译码选择），再通过比较器进行比较，根据比较结果，改变DAC的值，直到和输入电压近似相等，则DAC的值为相应的数字变量。REF为参考电压。比较时通常用二分法，逐次逼近。</p>
<h2 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141006160.png" class="" title="image-20230909141006160">

<h2 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909140814309.png" class="" title="image-20230909140814309">

<p>触发控制可选择软件触发或者硬件触发。</p>
<h2 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141225078.png" class="" title="image-20230909141225078">

<h2 id="规则组的四种转换模式"><a href="#规则组的四种转换模式" class="headerlink" title="规则组的四种转换模式"></a>规则组的四种转换模式</h2><h3 id="单次转换，非扫描模式"><a href="#单次转换，非扫描模式" class="headerlink" title="单次转换，非扫描模式"></a>单次转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141515783.png" class="" title="image-20230909141515783">

<p>将需要转换的通道2写入序列1，触发转换即可，完成后将数据放入寄存器，同时将EOC（标志位）置1。下次转换将再次实行以上步骤。</p>
<h3 id="连续转换，非扫描模式"><a href="#连续转换，非扫描模式" class="headerlink" title="连续转换，非扫描模式"></a>连续转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145103684.png" class="" title="image-20230909145103684">

<p>与单次转换不同，转换结束后将立即开始下一轮转换。即，触发一次，转换会一直进行下去。</p>
<h3 id="单次转换，扫描模式"><a href="#单次转换，扫描模式" class="headerlink" title="单次转换，扫描模式"></a>单次转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145559280.png" class="" title="image-20230909145559280">

<p>相较于单次转换，非扫描模式，可填入多个通道进行转换。</p>
<h3 id="连续转换，扫描模式"><a href="#连续转换，扫描模式" class="headerlink" title="连续转换，扫描模式"></a>连续转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145836537.png" class="" title="image-20230909145836537">

<h2 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145914699.png" class="" title="image-20230909145914699">

<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150013914.png" class="" title="image-20230909150013914">

<p>一般使用右对齐，可直接得出结果。也可以使用左对齐，然后裁剪数据分辨率。</p>
<h2 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h2><p>•　AD转换的步骤：采样，保持，量化，编码</p>
<p>•　STM32 ADC的总转换时间为：</p>
<p>　 TCONV &#x3D; 采样时间 + 12.5个ADC周期</p>
<p>•　例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期</p>
<p>　 TCONV &#x3D; 1.5 + 12.5 &#x3D; 14个ADC周期 &#x3D; 1μs</p>
<h2 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h2><p>•　ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p>
<p>•　建议在每次上电后执行一次校准</p>
<p>•　启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p>
<h2 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150438360.png" class="" title="image-20230909150438360">

<h2 id="示例程序-6"><a href="#示例程序-6" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>１．开启RCC时钟，ADC,GPIO。</p>
<p>２．配置GPIO为模拟输入。</p>
<p>３．配置多路开关，将所要转换的通道接入规则组。</p>
<p>４．配置ADC转换器</p>
<p>５．调用ADC_cmd()函数使能ADC。</p>
<h3 id="AD单通道"><a href="#AD单通道" class="headerlink" title="AD单通道"></a>AD单通道</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"         
//
uint16_t ADValue;       // 存储AD转换后的数值
float Voltage;          // 存储计算后的电压值
//
int main(void)
&#123;
// 初始化
    OLED_Init();         
    AD_Init();         
    OLED_ShowString(1, 1, "ADValue:");    
    OLED_ShowString(2, 1, "Volatge:0.00V"); 
    while (1)
    &#123;
        ADValue = AD_GetValue();    // 获取AD转换后的数值
        Voltage = (float)ADValue / 4095 * 3.3; // 计算电压值
        // 在OLED上显示AD值和电压值（带小数点）
        OLED_ShowNum(1, 9, ADValue, 4);
        OLED_ShowNum(2, 9, Voltage, 1);
        // 在OLED上显示电压值的小数部分（两位小数）
        OLED_ShowNum(2, 11, (uint16_t)(Voltage * 100) % 100, 2);
        Delay_ms(100);  // 延时100毫秒
        &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  // 配置引脚为模拟输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;      
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
//利用结构体配置ADC
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                   // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;      // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                      // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                						 // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                      						 // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  // 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); // 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  // 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  // 等待校准完成
&#125;
//转换函数
uint16_t AD_GetValue(void)
&#123;
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);                    // 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);    // 等待转换完成
    return ADC_GetConversionValue(ADC1);                       // 获取ADC转换结果
&#125;
</code> </pre> </details>

<h3 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h3>

<p>采用扫描模式实现多通道，最好配合DMA防止数据覆盖。</p>
<p>本次利用单次转换非扫描模式，只需在每次触发转换之前，手动更改一下列表第一个位置通道即可。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"        
// 存储四个ADC通道的转换值
uint16_t AD0, AD1, AD2, AD3; 
int main(void)
&#123;
// 初始化
    OLED_Init();   
    AD_Init();     
    OLED_ShowString(1, 1, "AD0:"); 
    OLED_ShowString(2, 1, "AD1:"); 
    OLED_ShowString(3, 1, "AD2:"); 
    OLED_ShowString(4, 1, "AD3:"); 
    while (1)
    &#123;
        // 获取ADC通道的转换值
        AD0 = AD_GetValue(ADC_Channel_0); 
        AD1 = AD_GetValue(ADC_Channel_1); 
        AD2 = AD_GetValue(ADC_Channel_2); 
        AD3 = AD_GetValue(ADC_Channel_3); 
     // 在OLED上显示
        OLED_ShowNum(1, 5, AD0, 4);
        OLED_ShowNum(2, 5, AD1, 4);
        OLED_ShowNum(3, 5, AD2, 4);
        OLED_ShowNum(4, 5, AD3, 4);
     // 延时100毫秒
        Delay_ms(100); 
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO引脚为模拟输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间等参数
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                  // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;    // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                    // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                         // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                               // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  													// 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); 	// 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  													// 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  			// 等待校准完成
&#125;
//
uint16_t AD_GetValue(uint8_t ADC_Channel)
&#123;
    ADC_RegularChannelConfig(ADC1, ADC_Channel, 1, ADC_SampleTime_55Cycles5);	// 配置ADC
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);  									// 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); 					// 等待转换完成
    return ADC_GetConversionValue(ADC1);  										// 获取ADC转换结果
&#125;
</code> </pre> </details>


<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><p>•　DMA（Direct Memory Access）直接存储器存取</p>
<p>•　DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源（可直接访问32内部存储器，包括内存SRAM，Flash）</p>
<p>•　12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）</p>
<p>•　每个通道都支持软件触发和特定的硬件触发</p>
<p>•　STM32F103C8T6 DMA资源：DMA1（7个通道）</p>
<h2 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212035982.png" class="" title="image-20230913212035982">

<h2 id="DMA框图"><a href="#DMA框图" class="headerlink" title="DMA框图"></a>DMA框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212111665.png" class="" title="image-20230913212111665">

<h2 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212244338.png" class="" title="image-20230913212244338">

<p>DMA无法进行SRAM到Flash，Flash到Flash操作。M2M用于选择硬件触发或软件触发，EN位为DMA的开关控制。</p>
<h2 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212521710.png" class="" title="image-20230913212521710">

<p>使用硬件触发需选择专门的通道，选择软件触发则可任意选择。</p>
<h2 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213052577.png" class="" title="image-20230913213052577">

<p>源端宽度&#x3D;目标宽度，数据正常传输。</p>
<p>源端宽度＜目标宽度，目标前面空位补零。</p>
<p>源端宽度＞目标宽度，舍弃源端高位。</p>
<h2 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213356192.png" class="" title="image-20230913213356192">

<p>将DataA转运到DataB，外设地址给DataA数组地址，存储器地址给DataB的首地址，宽度都为8位传输，且两地址都自增，传输计数器赋值为7，无需自动重装，使用软件触发，调用DMA_cmd();</p>
<h2 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213909958.png" class="" title="image-20230913213909958">

<h2 id="示例程序-7"><a href="#示例程序-7" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="DMA数据转运"><a href="#DMA数据转运" class="headerlink" title="DMA数据转运"></a>DMA数据转运</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"     // 包含STM32标准库的头文件
#include "Delay.h"         // 包含自定义延时函数的头文件
#include "OLED.h"          // 包含OLED显示屏的头文件
#include "MyDMA.h"         // 包含自定义DMA初始化和传输函数的头文件
// 定义两个数组，DataA和DataB，分别用于存储数据
uint8_t DataA[] = &#123;0x01, 0x02, 0x03, 0x04&#125;;
uint8_t DataB[] = &#123;0, 0, 0, 0&#125;;
int main(void)
&#123;
// 初始化OLED显示屏
    OLED_Init();
// 使用自定义的DMA初始化函数初始化DMA，并配置数据源和目标地址
    MyDMA_Init((uint32_t)DataA, (uint32_t)DataB, 4);
// 在OLED上显示文本和数据的初始状态
    OLED_ShowString(1, 1, "DataA");
    OLED_ShowString(3, 1, "DataB");
    OLED_ShowHexNum(1, 8, (uint32_t)DataA, 8);
    OLED_ShowHexNum(3, 8, (uint32_t)DataB, 8);
    while (1)
    &#123;
// 修改DataA数组的值
        DataA[0]++;
        DataA[1]++;
        DataA[2]++;
        DataA[3]++;
// 在OLED上显示DataA和DataB的各个元素的值
        OLED_ShowHexNum(2, 1, DataA[0], 2);
        OLED_ShowHexNum(2, 4, DataA[1], 2);
        OLED_ShowHexNum(2, 7, DataA[2], 2);
        OLED_ShowHexNum(2, 10, DataA[3], 2);
        OLED_ShowHexNum(4, 1, DataB[0], 2);
        OLED_ShowHexNum(4, 4, DataB[1], 2);
        OLED_ShowHexNum(4, 7, DataB[2], 2);
        OLED_ShowHexNum(4, 10, DataB[3], 2);    
// 使用自定义的延时函数延时1秒
        Delay_ms(1000);   
// 使用DMA传输数据
        MyDMA_Transfer();
// 再次在OLED上显示DataA和DataB的各个元素的值
        OLED_ShowHexNum(2, 1, DataA[0], 2);
        OLED_ShowHexNum(2, 4, DataA[1], 2);
        OLED_ShowHexNum(2, 7, DataA[2], 2);
        OLED_ShowHexNum(2, 10, DataA[3], 2);
        OLED_ShowHexNum(4, 1, DataB[0], 2);
        OLED_ShowHexNum(4, 4, DataB[1], 2);
        OLED_ShowHexNum(4, 7, DataB[2], 2);
        OLED_ShowHexNum(4, 10, DataB[3], 2);
// 使用自定义的延时函数延时1秒
        Delay_ms(1000);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MyDMA.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
// 定义一个全局变量，用于存储DMA传输的数据大小
uint16_t MyDMA_Size; 
// DMA初始化函数，用于配置DMA通道
void MyDMA_Init(uint32_t AddrA, uint32_t AddrB, uint16_t Size)
&#123;
    MyDMA_Size = Size;                                      // 将传入的数据大小保存到全局变量中
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);     // 启用DMA1时钟
//结构体配置DMA
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;                          // 配置外设基地址
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;    // 配置外设数据大小为字节
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;            // 允许外设地址递增
    DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;                              // 配置内存基地址
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;            // 配置内存数据大小为字节
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                    // 允许内存地址递增
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                         // 数据传输方向：从外设到内存
    DMA_InitStructure.DMA_BufferSize = Size;                                   // 配置DMA传输的数据大小
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                              // DMA工作模式为普通模式
    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;                                // 启用内存到内存传输
    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;                      // 配置DMA优先级为中等
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);                               // 使用通道1初始化DMA
// 禁用DMA通道1，等待启动传输
    DMA_Cmd(DMA1_Channel1, DISABLE); 
&#125;
// DMA传输函数，用于启动DMA传输
void MyDMA_Transfer(void)
&#123;
    DMA_Cmd(DMA1_Channel1, DISABLE);                         // 禁用DMA通道1，准备重新配置
    DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);       // 配置当前数据传输计数器的值
    DMA_Cmd(DMA1_Channel1, ENABLE);                          // 启用DMA通道1，开始传输
    while (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);       // 等待传输完成，检查传输完成标志
    DMA_ClearFlag(DMA1_FLAG_TC1);                            // 清除传输完成标志
&#125;
</code> </pre> </details>



<h3 id="DMA-AD多通道"><a href="#DMA-AD多通道" class="headerlink" title="DMA+AD多通道"></a>DMA+AD多通道</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "AD.h"        
#include "OLED.h"      
#include "Delay.h"     
int main(void)
&#123;
// 初始化	
    OLED_Init();     
    AD_Init();       
    OLED_ShowString(1, 1, "AD0:");
    OLED_ShowString(2, 1, "AD1:");
    OLED_ShowString(3, 1, "AD2:");
    OLED_ShowString(4, 1, "AD3:");
    while (1)
    &#123;
// 读取ADC模块的四个通道（AD0、AD1、AD2、AD3）的值，并显示在OLED屏上
        OLED_ShowNum(1, 5, AD_Value[0], 4);
        OLED_ShowNum(2, 5, AD_Value[1], 4);
        OLED_ShowNum(3, 5, AD_Value[2], 4);
        OLED_ShowNum(4, 5, AD_Value[3], 4);
// 延时100毫秒
        Delay_ms(100); 
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 用于存储ADC模块的转换结果
uint16_t AD_Value[4]; 
void AD_Init(void)
&#123;
// 启用ADC1、GPIOA和DMA1的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置ADC通道对应的GPIO引脚为模拟输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC通道和采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);
// 配置ADC工作模式和DMA模式
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
    ADC_InitStructure.ADC_ScanConvMode = ENABLE;
    ADC_InitStructure.ADC_NbrOfChannel = 4;
    ADC_Init(ADC1, &ADC_InitStructure);
// 配置DMA通道，用于传输ADC数据
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value;
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_BufferSize = 4;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);
// 启用DMA通道
    DMA_Cmd(DMA1_Channel1, ENABLE);
// 启用ADC的DMA传输
    ADC_DMACmd(ADC1, ENABLE);
// 启用ADC
    ADC_Cmd(ADC1, ENABLE);
// 复位ADC校准
    ADC_ResetCalibration(ADC1);
    while (ADC_GetResetCalibrationStatus(ADC1) == SET);
// 开始ADC校准
    ADC_StartCalibration(ADC1);
    while (ADC_GetCalibrationStatus(ADC1) == SET);
// 启动ADC转换
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
&#125;
</code> </pre> </details>


<h1 id="USART串口"><a href="#USART串口" class="headerlink" title="USART串口"></a>USART串口</h1><h2 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h2><p>•　通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p>
<p>•　通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230923092407230.png" class="" title="image-20230923092407230">

<p><strong>引脚：</strong><br>TX：数据发送引脚</p>
<p>RX：数据接收引脚</p>
<p>SCL：时钟线</p>
<p>SDA：数据线</p>
<p>SCLK：时钟</p>
<p>MOSI：主机输出数据脚</p>
<p>MISO：主机输入数据脚</p>
<p>CS：片选，用于指定通信对象</p>
<p>CAN和USB：表中的双引脚用于表示差分信号。</p>
<p><strong>双工：</strong></p>
<p>全双工：双方可同时互相发送和接受信息。</p>
<p>半双工：任意一方发送的时候，另一方只能接收。</p>
<p>单工：只能一方发送，另一方接收，单向传输。</p>
<p><strong>时钟：</strong></p>
<p>同步：双方通信配有时钟线</p>
<p>异步：自定义时钟</p>
<p>单端：引脚的高低电平为GND的电压差，所以双方需要共地。</p>
<h2 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h2><p>•　简单双向串口通信有两根通信线（发送端TX和接收端RX）</p>
<p>•　TX与RX要交叉连接</p>
<p>•　当只需单向的数据传输时，可以只接一根通信线</p>
<p>•　当电平标准不一致时，需要加电平转换芯片</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926133507630.png" class="" title="image-20230926133507630">

<h2 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h2><p>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p>
<p>•　TTL电平：+3.3V或+5V表示1，0V表示0</p>
<p>•　RS232电平：-3 ~ -15V表示1，+3 ~ +15V表示0</p>
<p>•　RS485电平：两线压差+2 ~ +6V表示1，-2 ~ -6V表示0（差分信号）</p>
<h2 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h2><p>•　波特率：串口通信的速率</p>
<p>•　起始位：标志一个数据帧的开始，固定为低电平</p>
<p>•　数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行</p>
<p>•　校验位：用于数据验证，根据数据位计算得来</p>
<p>•　停止位：用于数据帧间隔，固定为高电平</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134153532.png" class="" title="image-20230926134153532">

<p>右图RB8&#x2F;TB8为奇偶校验位。</p>
<h3 id="串口时序"><a href="#串口时序" class="headerlink" title="串口时序"></a>串口时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134322264.png" class="" title="image-20230926134322264">

<p>各种情况下，串口发送数据的时序。</p>
<h2 id="USART外设简介"><a href="#USART外设简介" class="headerlink" title="USART外设简介"></a>USART外设简介</h2><p>•　USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器</p>
<p>•　USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p>
<p>•　自带波特率发生器，最高达4.5Mbits&#x2F;s（可理解为分频器）</p>
<p>•　可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2）</p>
<p>•　可选校验位（无校验&#x2F;奇校验&#x2F;偶校验）</p>
<p>•　支持同步模式（CLK时钟输出）、硬件流控制、DMA、智能卡、IrDA、LIN</p>
<p>•　STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p>
<h2 id="USART框图"><a href="#USART框图" class="headerlink" title="USART框图"></a>USART框图</h2><img src="STM32%E5%BD%92%E6%A1%A3/image-20230926210423747.png" alt="image-20230926210423747" style="zoom:200%;" />

<h2 id="USART基本结构"><a href="#USART基本结构" class="headerlink" title="USART基本结构"></a>USART基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210537974.png" class="" title="image-20230926210537974">

<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210641784.png" class="" title="image-20230926210641784">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210653469.png" class="" title="image-20230926210653469">

<h3 id="起始位侦测"><a href="#起始位侦测" class="headerlink" title="起始位侦测"></a>起始位侦测</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210745962.png" class="" title="image-20230926210745962">

<h3 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210802474.png" class="" title="image-20230926210802474">

<h2 id="波特率发生器"><a href="#波特率发生器" class="headerlink" title="波特率发生器"></a>波特率发生器</h2><p>•　发送器和接收器的波特率由波特率寄存器BRR里的DIV确定</p>
<p>•　计算公式：波特率 &#x3D; fPCLK2&#x2F;1 &#x2F; (16 * DIV)</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210847282.png" class="" title="image-20230926210847282">

<h2 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h2><p>•　HEX模式&#x2F;十六进制模式&#x2F;二进制模式：以原始数据的形式显示</p>
<p>•　文本模式&#x2F;字符模式：以原始数据编码后的形式显示</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210952604.png" class="" title="image-20230926210952604"><img src="STM32%E5%BD%92%E6%A1%A3/image-20230926211002416.png" alt="image-20230926211002416" style="zoom: 67%;" />

<h2 id="示例程序-8"><a href="#示例程序-8" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="串口发送-x2F-接收数据"><a href="#串口发送-x2F-接收数据" class="headerlink" title="串口发送&#x2F;接收数据"></a>串口发送&#x2F;接收数据</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
//定义接收数据
uint8_t RxData;
int main(void)
&#123;
//初始化数据
    OLED_Init();
    OLED_ShowString(1, 1, "RxData:");
    Serial_Init();
    while (1)
    &#123;
//实现功能为数据互传，当上位机发送数据，从机接收到数据时，将收到的数据回传发送。
        if (Serial_GetRxFlag() == 1)
        &#123;
            RxData = Serial_GetRxData();
            Serial_SendByte(RxData);
            OLED_ShowHexNum(1, 8, RxData, 2);
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include <stdio.h>
#include <stdarg.h>
//定义临时变量
uint8_t Serial_RxData;
uint8_t Serial_RxFlag;
//初始化函数
void Serial_Init(void)
&#123;
//开启GPIO和USART的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//初始化GPIO
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   //复用推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//用于接收
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  //上拉输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;    //配置波特率
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  //不使用硬件流控制
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;  //配置USART为发送和接收模式
    USART_InitStructure.USART_Parity = USART_Parity_No;   //配置校验位，无校验
    USART_InitStructure.USART_StopBits = USART_StopBits_1;   //停止位为1位
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;  //子长为8字节
    USART_Init(USART1, &USART_InitStructure);
//开启USART中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
//用NVIC进行分组
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
//配置中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
//使能USART
    USART_Cmd(USART1, ENABLE);
&#125;
//发送一个字节，调用标准库函数发送字节，并判断标志位等待发送。
void Serial_SendByte(uint8_t Byte)  
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
//发送一个数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
//发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
//求平方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
//发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
//printf调用fputc打印，此函数使fputc为发送到串口。
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
//printf重定向，用于在程序中，调用printf，可打印数据至串口
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
//自定义函数，获取读标志位
uint8_t Serial_GetRxFlag(void)
&#123;
    if (Serial_RxFlag == 1)
    &#123;
        Serial_RxFlag = 0;
        return 1;
    &#125;
    return 0;
&#125;
//自定义函数，获取读标志位
uint8_t Serial_GetRxData(void)
&#123;
    return Serial_RxData;
&#125;
//USART中断，读取接收数据
void USART1_IRQHandler(void)
&#123;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        Serial_RxData = USART_ReceiveData(USART1);
        Serial_RxFlag = 1;
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<p>具体函数功能已有注释，值得一提的是发送数字的功能，除了示例程序中，求数字次方再提取数字（此方法在博客C语言循环结构中的题目《计数问题》有更好的处理）。也可以利用发送字符串的功能。利用C语言函数，可将数字转换为字符串再发送。当然，别忘了引入C语言头文件&lt;stdio.h&gt;。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> VoltageStr[<span class="number">10</span>];  <span class="comment">// 定义一个足够大的字符数组来存储转换后的字符串    </span></span><br><span class="line">Num = <span class="number">1245</span>;    </span><br><span class="line"><span class="built_in">sprintf</span>(VoltageStr, <span class="string">&quot;%d&quot;</span>, Num);  <span class="comment">// 使用sprintf将整数转换为字符串     </span></span><br><span class="line">SendString(VoltageStr);  <span class="comment">// 发送字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p><strong>HEX数据包</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112711694.png" class="" title="image-20230928112711694">

<p><strong>文本数据包</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112818035.png" class="" title="image-20230928112818035">

<p><strong>HEX数据包接收</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113322761.png" class="" title="image-20230928113322761">

<p><strong>文本数据包接收</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113344291.png" class="" title="image-20230928113344291">

<p>在程序设计中，需设计一个能记住不同状态的机制，称为状态机。</p>
<p><strong>示例程序</strong></p>
<p><strong>串口收发HEX数据包</strong></p>


<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "Key.h"
// 用于存储按键的状态
uint8_t KeyNum;  
int main(void)
&#123;
//初始化
    OLED_Init();   
    Key_Init();    
    Serial_Init(); 
    OLED_ShowString(1, 1, "TxPacket"); 
    OLED_ShowString(3, 1, "RxPacket");
// 预设串口发送数据的内容
    Serial_TxPacket[0] = 0x01; 
    Serial_TxPacket[1] = 0x02;
    Serial_TxPacket[2] = 0x03;
    Serial_TxPacket[3] = 0x04;
    while (1)
    &#123;
//获取按键状态
        KeyNum = Key_GetNum(); 
// 如果按键被按下，将递增串口发送数据的内容
        if (KeyNum == 1) 
        &#123;
            Serial_TxPacket[0]++;
            Serial_TxPacket[1]++;
            Serial_TxPacket[2]++;
            Serial_TxPacket[3]++;
// 发送串口数据
            Serial_SendPacket(); 
// 在OLED上显示发送数据的十六进制值
            OLED_ShowHexNum(2, 1, Serial_TxPacket[0], 2);
            OLED_ShowHexNum(2, 4, Serial_TxPacket[1], 2);
            OLED_ShowHexNum(2, 7, Serial_TxPacket[2], 2);
            OLED_ShowHexNum(2, 10, Serial_TxPacket[3], 2);
        &#125;
// 如果收到串口接收标志位
        if (Serial_GetRxFlag() == 1) 
        &#123;
// 在OLED上显示接收到的数据的十六进制值
            OLED_ShowHexNum(4, 1, Serial_RxPacket[0], 2);
            OLED_ShowHexNum(4, 4, Serial_RxPacket[1], 2);
            OLED_ShowHexNum(4, 7, Serial_RxPacket[2], 2);
            OLED_ShowHexNum(4, 10, Serial_RxPacket[3], 2);
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  // 包含STM32的设备头文件
#include <stdio.h>
#include <stdarg.h>
//定义数据
uint8_t Serial_TxPacket[4];  // 用于存储串口发送的数据
uint8_t Serial_RxPacket[4];  // 用于存储串口接收的数据
uint8_t Serial_RxFlag;       // 串口接收标志位
// 初始化串口
void Serial_Init(void)
&#123;
// 使能USART1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//配置GPIO发送端口
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;         // USART1的TX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置GPIO接收端口
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;        // USART1的RX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;         // 波特率设置为9600
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_Init(USART1, &USART_InitStructure);
// 使能USART1的接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);     
// 设置NVIC的优先级分组为组2
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);    
// 配置USART1的中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;  
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
// 使能USART1
    USART_Cmd(USART1, ENABLE);                         
&#125;
// 发送单个字节
void Serial_SendByte(uint8_t Byte)
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
// 发送字节数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
// 发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
// 计算X的Y次方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
// 发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
// 重定向printf函数
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
// 带格式的字符串发送
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
// 发送串口数据包
void Serial_SendPacket(void)
&#123;
    Serial_SendByte(0xFF);                 //数据包包头
    Serial_SendArray(Serial_TxPacket, 4);  //数据包数据
    Serial_SendByte(0xFE);                 //数据包包尾
&#125;
// 获取串口接收标志位
uint8_t Serial_GetRxFlag(void)
&#123;
    if (Serial_RxFlag == 1)
    &#123;
        Serial_RxFlag = 0;
        return 1;
    &#125;
    return 0;
&#125;
// USART1的中断处理函数，内有状态机，处理数据包各种情况
void USART1_IRQHandler(void)
&#123;
    static uint8_t RxState = 0;
    static uint8_t pRxPacket = 0;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        uint8_t RxData = USART_ReceiveData(USART1);
        if (RxState == 0)
        &#123;
            if (RxData == 0xFF)
            &#123;
                RxState = 1;
                pRxPacket = 0;
            &#125;
        &#125;
        else if (RxState == 1)
        &#123;
            Serial_RxPacket[pRxPacket] = RxData;
            pRxPacket ++;
            if (pRxPacket >= 4)
            &#123;
                RxState = 2;
            &#125;
        &#125;
        else if (RxState == 2)
        &#123;
            if (RxData == 0xFE)
            &#123;
                RxState = 0;
                Serial_RxFlag = 1;
            &#125;
        &#125;
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.h</font></summary>  <pre><code class="language-c">
#ifndef __SERIAL_H
#define __SERIAL_H
//
#include <stdio.h>
//定义变量时用extern，可被主函数调用。
extern uint8_t Serial_TxPacket[];
extern uint8_t Serial_RxPacket[];
//
void Serial_Init(void);                                          //初始化
void Serial_SendByte(uint8_t Byte);                              //发送字节
void Serial_SendArray(uint8_t *Array, uint16_t Length);          //发送数组
void Serial_SendString(char *String);                            //发送字符串
void Serial_SendNumber(uint32_t Number, uint8_t Length);         //发送数字
void Serial_Printf(char *format, ...);                           //打印至串口
void Serial_SendPacket(void);                                    //发送数据包
uint8_t Serial_GetRxFlag(void);                                  //获取接收标志位
//
#endif
</code> </pre> </details>

<p>这里引入.h文件是因为定义到Sericl.c的变量，需要在main.c调用。</p>
<p>各函数功能和串口收发数据区别不大，但在中断函数中引入的状态机，先等待包头，收到包头后开启接受数据的函数，并保存至数组。接受完毕后等待包尾，完成一个数据包的传输。</p>
<p>主函数的功能是按下按钮时，将发送以“FF 02 03 04 05 FE”为格式的数据包，按键每按下一次，数据包内的数据将自增1。也可以用同样的格式发送数据包，发送和接受的数据包的数据（不含包头包尾）将在OLED显示。</p>
<p><strong>串口收发文本数据包</strong></p>


<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "LED.h"
#include "string.h"
int main(void)
&#123;
//初始化
    OLED_Init();        
    LED_Init();         
    Serial_Init();      
    OLED_ShowString(1, 1, "TxPacket");
    OLED_ShowString(3, 1, "RxPacket");
    while (1)
    &#123;
        if (Serial_RxFlag == 1)  // 如果收到串口接收标志位
        &#123;
            OLED_ShowString(4, 1, "                ");  // 清除OLED上的数据
            OLED_ShowString(4, 1, Serial_RxPacket);     // 在OLED上显示收到的数据
            if (strcmp(Serial_RxPacket, "LED_ON") == 0)  // 如果收到 "LED_ON" 命令
            &#123;
                LED1_ON();  // 打开LED1
                Serial_SendString("LED_ON_OK\r\n");         // 发送成功消息给串口
                OLED_ShowString(2, 1, "                ");  // 清除OLED上的数据
                OLED_ShowString(2, 1, "LED_ON_OK");         // 在OLED上显示 "LED_ON_OK"
            &#125;
            else if (strcmp(Serial_RxPacket, "LED_OFF") == 0)  // 如果收到 "LED_OFF" 命令
            &#123;
                LED1_OFF();  // 关闭LED1
                Serial_SendString("LED_OFF_OK\r\n");         // 发送成功消息给串口
                OLED_ShowString(2, 1, "                ");   // 清除OLED上的数据
                OLED_ShowString(2, 1, "LED_OFF_OK");         // 在OLED上显示 "LED_OFF_OK"
            &#125;
            else
            &#123;
                Serial_SendString("ERROR_COMMAND\r\n");      // 发送错误消息给串口
                OLED_ShowString(2, 1, "                ");   // 清除OLED上的数据
                OLED_ShowString(2, 1, "ERROR_COMMAND");      // 在OLED上显示 "ERROR_COMMAND"
            &#125;
            Serial_RxFlag = 0;  // 重置串口接收标志位
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include <stdio.h>
#include <stdarg.h>
//
char Serial_RxPacket[100]; // 存储串口接收的数据，最大长度为100
uint8_t Serial_RxFlag;     // 串口接收标志位
// 初始化串口
void Serial_Init(void)
&#123;
// 使能USART1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//配置GPIO发送端
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;      // USART1的TX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置GPIO接收端
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;     // USART1的RX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;      // 波特率设置为9600
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_Init(USART1, &USART_InitStructure);
// 使能USART1的接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);  
// 设置NVIC的优先级分组为组2
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 
// 配置USART1的中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; 
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
// 使能USART1
    USART_Cmd(USART1, ENABLE);                      
&#125;
// 发送单个字节
void Serial_SendByte(uint8_t Byte)
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
// 发送字节数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
// 发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
// 计算X的Y次方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
// 发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
// 重定向printf函数
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
// 带格式的字符串发送
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
// USART1的中断处理函数，内有状态机，处理数据包各种情况
void USART1_IRQHandler(void)
&#123;
    static uint8_t RxState = 0;
    static uint8_t pRxPacket = 0;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        uint8_t RxData = USART_ReceiveData(USART1);
        if (RxState == 0)
        &#123;
            if (RxData == '@' && Serial_RxFlag == 0) // 如果接收到'@'字符且标志位为0
            &#123;
                RxState = 1;
                pRxPacket = 0;
            &#125;
        &#125;
        else if (RxState == 1)
        &#123;
            if (RxData == '\r') // 如果接收到'\r'字符
            &#123;
                RxState = 2;
            &#125;
            else
            &#123;
                Serial_RxPacket[pRxPacket] = RxData; // 存储接收到的字符
                pRxPacket ++;
            &#125;
        &#125;
        else if (RxState == 2)
        &#123;
            if (RxData == '\n') // 如果接收到'\n'字符
            &#123;
                RxState = 0;
                Serial_RxPacket[pRxPacket] = '\0'; // 在末尾添加字符串结束符
                Serial_RxFlag = 1; // 设置串口接收标志位为1，表示接收完成
            &#125;
        &#125;
//清除标志位
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.h</font></summary>  <pre><code class="language-c">
#ifndef __SERIAL_H
#define __SERIAL_H
#include <stdio.h>
// 定义串口接收缓冲区和接收标志位，这些变量可在main中引用
extern char Serial_RxPacket[];
extern uint8_t Serial_RxFlag;
//
void Serial_Init(void);                                  // 串口初始化函数
void Serial_SendByte(uint8_t Byte);                      // 发送单个字节到串口
void Serial_SendArray(uint8_t *Array, uint16_t Length);  // 发送字节数组到串口
void Serial_SendString(char *String);                    // 发送字符串到串口
void Serial_SendNumber(uint32_t Number, uint8_t Length); // 发送一个数字到串口，Length 表示数字的位数
void Serial_Printf(char *format, ...);                   // 带格式的字符串发送，类似于 printf
//
#endif
</code> </pre> </details>

<p>和HEX数据包类似，只是将数据形式换成了字符型。就不做过多说明。</p>
<p>main函数实现的功能为，在上位机输入‘@’为包头，输入‘LED_ON’为数据，换行为包尾，发送后将点亮LED，并回传“LED_ON_OK”，输入‘LED_OFF’为数据，发送后将熄灭LED，并回传“LED_OFF_OK”。输入其它指令将无法控制LED，并收到回传“ERROE_COMMAND”。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag"># 单片机</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/" rel="prev" title="stm32综述">
                  <i class="fa fa-chevron-left"></i> stm32综述
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/02/STM32%E6%A0%87%E5%87%86%E5%BA%93/" rel="next" title="STM32标准库">
                  STM32标准库 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">星戏溪行</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">64k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:52</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("2023/07/01 11:45:43");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "Shelter已建立 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-ecru-theta.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"初相遇，若重逢。右边的猫猫正盯着你，它对君的赠言充满希冀。（或许你需要一个梯子登高阁，拂笔于此）"},"avatar":"mp","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2023/08/02/STM32%E5%BD%92%E6%A1%A3/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-tororo"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
