<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="函数定义（C 语言自定义函数）函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言函数">
<meta property="og:url" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="来自星星的弦乐">
<meta property="og:description" content="函数定义（C 语言自定义函数）函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710211606098.png">
<meta property="og:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710214033219.png">
<meta property="og:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710231414691.png">
<meta property="og:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112109326.png">
<meta property="og:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112233095.png">
<meta property="article:published_time" content="2023-07-10T09:30:36.000Z">
<meta property="article:modified_time" content="2023-07-11T04:26:04.877Z">
<meta property="article:author" content="星戏溪行">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710211606098.png">


<link rel="canonical" href="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","path":"2023/07/10/C语言函数/","title":"C语言函数"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言函数 | 来自星星的弦乐</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2adf217e938bc0432386afe319c0e750"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">来自星星的弦乐</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">| ❀ ❀ ❀ 踏梦携猫荡蓝海 ❀ ❀ ❀| | ☆ ☆ ☆ 引虹径行启银光 ☆ ☆ ☆|</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-茶馆"><a href="/comments/" rel="section"><i class="fas fa-comments fa-fw"></i>茶馆</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%EF%BC%88C-%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">函数定义（C 语言自定义函数）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">无参函数的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.</span> <span class="nav-text">有参函数的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.</span> <span class="nav-text">函数不能嵌套定义</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="nav-number">2.</span> <span class="nav-text">函数的形参和实参</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%EF%BC%88%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">形参（形式参数）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E5%8F%82%EF%BC%88%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">实参（实际参数）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">2.3.</span> <span class="nav-text">形参和实参的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">函数声明以及函数原型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.</span> <span class="nav-text">C 语言变量的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">函数内部定义的变量（局部变量）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">所有函数外部定义的变量（全局变量）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9D%97%E7%BA%A7%E5%8F%98%E9%87%8F%EF%BC%88%E5%9C%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E5%86%85%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">块级变量（在代码块内部定义的变量）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.4.</span> <span class="nav-text">再谈作用域</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%EF%BC%88%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">递归函数（递归调用）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">递归的条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">中间递归函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">多层递归函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E4%BC%98%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">递归函数的缺陷和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%A9%BA%E9%97%B4%E5%BC%80%E9%94%80"><span class="nav-number">6.1.</span> <span class="nav-text">递归函数的空间开销</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80"><span class="nav-number">6.2.</span> <span class="nav-text">递归函数的时间开销</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E6%9D%A5%E6%9B%BF%E6%8D%A2%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">使用迭代来替换递归函数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->
			<link rel="stylesheet" href="/dist/APlayer.min.css">  
			<div id="aplayer"></div>
			<script type="text/javascript" src="/dist/APlayer.min.js"></script>
			<script type="text/javascript" src="/dist/music.js"></script>
        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="星戏溪行"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">星戏溪行</p>
  <div class="site-description" itemprop="description">我和挚友的Shelter</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="星戏溪行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="来自星星的弦乐">
      <meta itemprop="description" content="我和挚友的Shelter">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言函数 | 来自星星的弦乐">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言函数
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-10 17:30:36" itemprop="dateCreated datePublished" datetime="2023-07-10T17:30:36+08:00">2023-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-11 12:26:04" itemprop="dateModified" datetime="2023-07-11T12:26:04+08:00">2023-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" itemprop="url" rel="index"><span itemprop="name">C语言学习之路</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span id="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/" class="post-meta-item twikoo_visitors" data-flag-title="C语言函数" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="twikoo_visitors"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h5 id="函数定义（C-语言自定义函数）"><a href="#函数定义（C-语言自定义函数）" class="headerlink" title="函数定义（C 语言自定义函数）"></a>函数定义（C 语言自定义函数）</h5><p>函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。<span id="more"></span>接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明，根据这一点可以将函数分为有参函数和无参函数。<br>将代码段封装成函数的过程叫做函数定义。  </p>
<h6 id="无参函数的定义"><a href="#无参函数的定义" class="headerlink" title="无参函数的定义"></a>无参函数的定义</h6><p>如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br></pre></td></tr></table></figure>

<p>dataType 是返回值类型，它可以是 C 语言中的任意数据类型，例如 int、 float、 char 等。<br>functionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。<br>body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由{ }包围。<br>如果有返回值，在函数体中使用 return 语句返回。 return 出来的数据的类型要和 dataType 一样  </p>
<p>无返回值函数<br>有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">printf(&quot;Hello,world \n&quot;); //没有返回值就不需要 return 语句 &#125;</span><br></pre></td></tr></table></figure>

<p>void 是 C 语言中的一个关键字，表示“空类型”或“无类型”，绝大部分情况下也就意味着没有 return 语句。</p>
<h6 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h6><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dataType1 param1, dataType2 param2 …是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由,分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。  </p>
<p>数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部。  </p>
<p>例如：计算从 m 加到 n 的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>调用 sum() 函数时，需要给它传递两份数据，一份传递给 m，一份传递给 n。你可以直接传递整数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = sum(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">//1 传递给 m， 100 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以传递变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> begin = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">86</span>;</span><br><span class="line"><span class="type">int</span> result = sum(begin, end); <span class="comment">//begin 传递给 m， end 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以整数和变量一起传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">33</span>;</span><br><span class="line"><span class="type">int</span> result = sum(num, <span class="number">80</span>); <span class="comment">//num 传递给 m， 80 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。<br>原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。  </p>
<h6 id="函数不能嵌套定义"><a href="#函数不能嵌套定义" class="headerlink" title="函数不能嵌套定义"></a>函数不能嵌套定义</h6><p>强调一点， C 语言不允许函数嵌套定义；也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。 main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。</p>
<p>函数不能嵌套定义，但可以嵌套调用，也就是在一个函数的定义或调用过程中允许出现对另外一个函数的调用。</p>
<h5 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h5><h6 id="形参（形式参数）"><a href="#形参（形式参数）" class="headerlink" title="形参（形式参数）"></a>形参（形式参数）</h6><p>在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。</p>
<h6 id="实参（实际参数）"><a href="#实参（实际参数）" class="headerlink" title="实参（实际参数）"></a>实参（实际参数）</h6><p>函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。<br>形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。</p>
<h6 id="形参和实参的区别和联系"><a href="#形参和实参的区别和联系" class="headerlink" title="形参和实参的区别和联系"></a>形参和实参的区别和联系</h6><p>(1) 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。<br>(2)  实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。<br>(4)  实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。<br>(5)  函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//计算从m加到n的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    total = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d\n&quot;</span>, total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers: 1 100↙<br>a&#x3D;1, b&#x3D;100<br>total&#x3D;5050</p>
<p>在这段代码中，函数定义处的 m、 n 是形参，函数调用处的 a、 b 是实参。通过 scanf() 可以读取用户输入的数据，并赋值给 a、 b，在调用 sum() 函数时，这份数据会传递给形参 m、 n。</p>
<p>从运行情况看，输入 a 值为 1，即实参 a 的值为 1，把这个值传递给函数 sum() 后，形参 m 的初始值也为 1，在函数执行过程中，形参 m 的值变为 5050。函数运行结束后，输出实参 a 的值仍为 1，可见实参的值不会随形参的变化而变化。</p>
<p>以上调用 sum() 时是将变量作为函数实参，除此以外，你也可以将常量、表达式、函数返回值作为实参，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = sum(<span class="number">10</span>, <span class="number">98</span>); <span class="comment">//将常量作为实参</span></span><br><span class="line">total = sum(a + <span class="number">10</span>, b - <span class="number">3</span>); <span class="comment">//将表达式作为实参</span></span><br><span class="line">total = sum(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="built_in">abs</span>(<span class="number">-100</span>)); <span class="comment">//将函数返回值作为实参</span></span><br></pre></td></tr></table></figure>

<p>(6) 形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效。  </p>
<h5 id="函数声明以及函数原型"><a href="#函数声明以及函数原型" class="headerlink" title="函数声明以及函数原型"></a>函数声明以及函数原型</h5><p>函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号;，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>也可以不写形参，只写数据类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1, dataType2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，称为函数原型（Function Prototype） 。函数原型的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。  </p>
<p>一般情况下，将函数定义放到 main() 的后面，将函数声明放到 main() 的前面，这样就使得代码结构清晰明了，主次分明。  </p>
<h5 id="C-语言变量的作用域"><a href="#C-语言变量的作用域" class="headerlink" title="C 语言变量的作用域"></a>C 语言变量的作用域</h5><p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。   </p>
<h6 id="函数内部定义的变量（局部变量）"><a href="#函数内部定义的变量（局部变量）" class="headerlink" title="函数内部定义的变量（局部变量）"></a>函数内部定义的变量（局部变量）</h6><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable） 。函数的形参也是局部变量，也只能在函数内部使用。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//m、 n、 i、 sum 都是局部变量，只能在 sum() 内部使用</span></span><br><span class="line">    <span class="keyword">for</span>(i=m; i&lt;=n; i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">5</span>, end = <span class="number">86</span>;</span><br><span class="line">    <span class="type">int</span> result = sum(begin, end);</span><br><span class="line">    <span class="comment">//begin、 end、 result 也都是局部变量，只能在 main() 内部使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum from %d to %d is %d\n&quot;</span>, begin, end, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>m、 n、 i、 sum 是局部变量，只能在 sum() 内部使用； begin、 end、 result 也是局部变量，只能在 main() 内部使用。<br>对局部变量的两点说明：<br>    main() 也是一个函数，在 main() 内部定义的变量也是局部变量，只能在 main() 函数内部使用。  </p>
<p>​	形参也是局部变量，将实参传递给形参的过程，就是用实参给局部变量赋值的过程，它和 a&#x3D;b; sum&#x3D;m+n;这样的赋值没有什么区别  </p>
<h6 id="所有函数外部定义的变量（全局变量）"><a href="#所有函数外部定义的变量（全局变量）" class="headerlink" title="所有函数外部定义的变量（全局变量）"></a>所有函数外部定义的变量（全局变量）</h6><p>全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件） 。如果给全局变量加上 static 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。</p>
<p>例：定义一个函数，根据长方体的长宽高求它的体积以及三个面的面积。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义三个全局变量，分别表示三个面的面积</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vs</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width, <span class="type">int</span> height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> v; <span class="comment">//体积</span></span><br><span class="line">    v = length * width * height;</span><br><span class="line">    s1 = length * width;</span><br><span class="line">    s2 = width * height;</span><br><span class="line">    s3 = length * height;	</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    v = vs(<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    v = vs(<span class="number">5</span>, <span class="number">17</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>v&#x3D;9000, s1&#x3D;300, s2&#x3D;600, s3&#x3D;450<br>v&#x3D;680, s1&#x3D;85, s2&#x3D;136, s3&#x3D;40  </p>
<p>通过变量的使用可以得到： 在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。  </p>
<p>C 语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：<br>    不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；<br>    函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。  </p>
<p>当函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。</p>
<p>变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。另外，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>; <span class="comment">//局部变量</span></span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>func1 n: 20<br>func2 n: 30<br>func3 n: 10<br>main n: 30</p>
<p>代码中虽然定义了多个同名变量 n，但它们的作用域不同，所有不会产生命名冲突。</p>
<p>下面是对输出结果的分析：<br>    对于 func1()，输出结果为 20，显然使用的是 func1() 内部的 n，而不是外部的 n。<br>    调用 func2() 时，会把 main() 中的实参 n 传递给 func2() 中的形参 n，此时形参 n 的值变为 30。形参 n 也<br>是局部变量，所以就使用它了。<br>    func3() 输出 10，使用的是全局变量，因为在 func3() 中不存在局部变量 n，所以编译器只能到函数外部，也<br>就是全局作用域中去寻找变量 n。<br>     main() 中 printf() 语句输出 30，说明使用的是 main() 中的 n，而不是外部的 n。  </p>
<h6 id="块级变量（在代码块内部定义的变量）"><a href="#块级变量（在代码块内部定义的变量）" class="headerlink" title="块级变量（在代码块内部定义的变量）"></a>块级变量（在代码块内部定义的变量）</h6><p>C 语言允许在代码块内部定义变量，这样的变量具有块级作用域；换句话说，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">22</span>; <span class="comment">//编号①</span></span><br><span class="line">    <span class="comment">//由&#123; &#125;包围的代码块</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">40</span>; <span class="comment">//编号②</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>block n: 40<br>main n: 22  </p>
<h6 id="再谈作用域"><a href="#再谈作用域" class="headerlink" title="再谈作用域"></a>再谈作用域</h6><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">822</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;if m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = i % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">2</span> &amp;&amp; n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;else m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710211606098.png" class="" title="image-20230710211606098">

<p>蓝色表示作用域的名称， 红色表示作用域中的变量， global 表示全局作用域。在灰色背景的作用域中，我们使用到了 m 变量，而该变量位于全局作用域中，所以得穿越好几层作用域才能找到 m。</p>
<h5 id="递归函数（递归调用）"><a href="#递归函数（递归调用）" class="headerlink" title="递归函数（递归调用）"></a>递归函数（递归调用）</h5><p>个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。  </p>
<p>以求阶乘为例，阶乘 n! 的计算公式如下：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710214033219.png" class="" title="image-20230710214033219">

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Factorial(%d) = %ld\n&quot;</span>, a, factorial(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 5↙<br>Factorial(5) &#x3D; 120  </p>
<p>factorial() 就是一个典型的递归函数。调用 factorial() 后即进入函数体，只有当 n&#x3D;&#x3D;0 或 n&#x3D;&#x3D;1 时函数才会执行结<br>束，否则就一直调用它自身。</p>
<p>由于每次调用的实参为 n-1，即把 n-1 的值赋给形参 n，所以每次递归实参的值都减 1，直到最后 n-1 的值为 1时再作递归调用，形参 n 的值也为 1，递归就终止了，会逐层退出。  </p>
<p>下表列出了逐层进入的过程：</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>实参&#x2F;形参</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>需要等待的结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>n&#x3D;5</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的结果</td>
</tr>
<tr>
<td>2</td>
<td>n&#x3D;4</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的结果</td>
</tr>
<tr>
<td>3</td>
<td>n&#x3D;3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的结果</td>
</tr>
<tr>
<td>4</td>
<td>n&#x3D;2</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的结果</td>
</tr>
<tr>
<td>5</td>
<td>n&#x3D;1</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
</tr>
</tbody></table>
<p>当递归进入到最内层的时候，递归就结束了，就开始逐层退出了，也就是逐层执行 return 语句。  </p>
<p>下表列出了逐层退出的过程</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>从内层递归得到的结果 （内层函数的返回值）</th>
<th>表达式的值 （当次调用的结果）</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的返回值，也就是 1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的返回值，也就是 2</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的返回值，也就是 6</td>
<td>24</td>
</tr>
<tr>
<td>1</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的返回值，也就是 24</td>
<td>120</td>
</tr>
</tbody></table>
<h6 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h6><p>每一个递归函数都应该只进行有限次的递归调用，否则它就会进入死胡同，永远也不能退出了，这样的程序是没有意义的。</p>
<p>要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题：<br>    存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束<br>了。<br>    每次递归调用之后越来越接近这个限制条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n<br>的值逐渐减小，越来越趋近于 1 或 0。  </p>
<h6 id="中间递归函数"><a href="#中间递归函数" class="headerlink" title="中间递归函数"></a>中间递归函数</h6><p>所谓中间递归，就是发生递归的位置在函数体的中间，而不是末尾。<br>尾递归在逐层退出时除了 return 语句，一般不再执行其他操作；而中间递归在逐层退出时还要执行一些其他的操作，所以比较复杂。</p>
<p>例如：字符串反转（逆置）函数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//反转（逆置）字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">reverse</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> ctemp = str[<span class="number">0</span>];</span><br><span class="line">            str[<span class="number">0</span>] = str[len - <span class="number">1</span>];</span><br><span class="line">            str[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//最后一个字符在下次递归时不再处理</span></span><br><span class="line">            reverse(str + <span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">            str[len - <span class="number">1</span>] = ctemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, reverse(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>987654321</p>
<p>每次调用函数，都会把字符串的第 0 个字符保存到 ctemp 变量，并把最后一个字符填充到第 0 个字符的位置，同时用’\0’来填充最后一个字符的位置。  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710231414691.png" class="" title="image-20230710231414691">

<p>reverse() 的整体思路是，每次调用函数只交换字符串开头和末尾的两个字符，其它字符一律不管，并且这个交换过程也是分两个阶段完成的：</p>
<p>在逐层进入递归的阶段， reverse() 只是把字符串的最后一个字符移动到最前边，但是并没有把最前边一个字符移动到最后边，而是把最前边的字符保存到 ctemp 变量。</p>
<p>在逐层退出递归的阶段， reverse() 才把 ctemp 变量中保存的字符放到字符串的最前边。</p>
<p>两个阶段相互合作，才能最终完成两个字符的交换。  </p>
<h6 id="多层递归函数"><a href="#多层递归函数" class="headerlink" title="多层递归函数"></a>多层递归函数</h6><p>多层递归的调用关系比较复杂，整体上看起来像一颗倒立的树：对于双层递归，树的每个节点有两个分叉；对<br>于三层递归，树的每个节点有三个分叉；以此类推……<br>下面以「求菲波那契数」为例:</p>
<p>菲波那契数就是一个数列，数列中每个数的值就是它前面两个数的和，这种关系常常用以下形式进行描述：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112109326.png" class="" title="image-20230711112109326">

<p>代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 7↙<br>Fib(7) &#x3D; 13  </p>
<p>当 n≥2 时，每次调用 fib(n) 都要等待 fib(n-1) 和 fib(n-2) 的结果，这种调用关系看起来就像一棵倒立的二叉树，如下图所示：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112233095.png" class="" title="image-20230711112233095">

<p>双层递归的调用关系和数据结构中二叉树的结构完全吻合，所以双层递归常用于二叉树的遍历。</p>
<p>单层递归每次只等待一个函数的结果，双层递归每次要等待两个函数的结果，这就是它们之间最本质的区别。  </p>
<h5 id="递归函数的缺陷和优化"><a href="#递归函数的缺陷和优化" class="headerlink" title="递归函数的缺陷和优化"></a>递归函数的缺陷和优化</h5><h6 id="递归函数的空间开销"><a href="#递归函数的空间开销" class="headerlink" title="递归函数的空间开销"></a>递归函数的空间开销</h6><p>递归函数内部嵌套了对自身的调用，除非等到最内层的函数调用结束，否则外层的所有函数都不会调用结束。</p>
<p>通俗地讲，外层函数被卡主了，它要等待所有的内层函数调用完成后，它自己才能调用完成。</p>
<p>每一层的递归调用都会在栈上分配一块内存， 有多少层递归调用就分配多少块相似的内存，所有内存加起来的总和是相当恐怖的，很容易超过栈内存的大小限制，这个时候就会导致程序崩溃。</p>
<p>例如，一个递归函数需要递归 10000 次，每次需要 1KB 的内存，那么最终就需要 10MB 的内存  </p>
<h6 id="递归函数的时间开销"><a href="#递归函数的时间开销" class="headerlink" title="递归函数的时间开销"></a>递归函数的时间开销</h6><p>每次调用函数都会在栈上分配内存，函数调用结束后再释放这一部分内存，内存的分配和释放都是需要时间的。<br>每次调用函数还会多次修改寄存器的值，函数调用结束后还需要找到上层函数的位置再继续执行，这也是需要时间的。 </p>
<p>以「求斐波那契数」为例  ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>   </span></span><br><span class="line"><span class="comment">// 递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start, time_end;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    time_start = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    time_end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end - time_start)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 42↙<br>Fib(42) &#x3D; 267914296<br>run time: 0.833000s</p>
<p>可以看到，求 42 的斐波那契数程序所用的时间为 0.83 秒。  </p>
<h6 id="使用迭代来替换递归函数"><a href="#使用迭代来替换递归函数" class="headerlink" title="使用迭代来替换递归函数"></a>使用迭代来替换递归函数</h6><p>递归函数应为原理层面的缺陷，无法优化，但大部分能用递归解决的问题也能用迭代来解决。所谓迭代，就是循环。</p>
<p>许多问题是以递归的形式进行解释的，这只是因为它比非递归形式更为清晰。但是， 这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性可能稍差一些。  </p>
<p>还是以求斐波那契数为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_recursion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib_recursion(n - <span class="number">1</span>) + fib_recursion(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_iteration</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="type">long</span> previous_result;</span><br><span class="line">    <span class="type">long</span> next_older_result;</span><br><span class="line">    result = previous_result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        next_older_result = previous_result;</span><br><span class="line">        previous_result = result;</span><br><span class="line">        result = previous_result + next_older_result;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start_recursion, time_end_recursion;</span><br><span class="line">    <span class="type">clock_t</span> time_start_iteration, time_end_iteration;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="comment">//递归的时间</span></span><br><span class="line">    time_start_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_recursion(%d) = %ld\n&quot;</span>, a, fib_recursion(a));</span><br><span class="line">    time_end_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with recursion: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_recursion -</span><br><span class="line">    time_start_recursion)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="comment">//迭代的时间</span></span><br><span class="line">    time_start_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_iteration(%d) = %ld\n&quot;</span>, a, fib_iteration(a));</span><br><span class="line">    time_end_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with iteration: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_iteration - time_start_iteration)</span><br><span class="line">    / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>Input a number: 42<br>Fib_recursion(42) &#x3D; 267914296<br>run time with recursion: 0.854000s<br>Fib_iteration(42) &#x3D; 267914296<br>run time with iteration: 0.000000s</p>
<p>可以看出迭代还是比递归快一点点的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/09/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/" rel="prev" title="C语言数组">
                  <i class="fa fa-chevron-left"></i> C语言数组
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/10/%E7%AB%A5%E5%B9%B4%E7%9A%84%E6%AD%A3%E5%8D%88%E5%B0%8F%E8%B7%AF/" rel="next" title="童年的正午小路">
                  童年的正午小路 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">星戏溪行</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">88k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:21</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("2023/07/01 11:45:43");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "Shelter已建立 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":true,"envId":"https://xxdg.wearexc.xyz","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

  

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
