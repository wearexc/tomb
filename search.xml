<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言函数</title>
    <url>/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h5 id="函数定义（C-语言自定义函数）"><a href="#函数定义（C-语言自定义函数）" class="headerlink" title="函数定义（C 语言自定义函数）"></a>函数定义（C 语言自定义函数）</h5><p>函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。<span id="more"></span>接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明，根据这一点可以将函数分为有参函数和无参函数。<br>将代码段封装成函数的过程叫做函数定义。  </p>
<h6 id="无参函数的定义"><a href="#无参函数的定义" class="headerlink" title="无参函数的定义"></a>无参函数的定义</h6><p>如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br></pre></td></tr></table></figure>

<p>dataType 是返回值类型，它可以是 C 语言中的任意数据类型，例如 int、 float、 char 等。<br>functionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。<br>body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由{ }包围。<br>如果有返回值，在函数体中使用 return 语句返回。 return 出来的数据的类型要和 dataType 一样  </p>
<p>无返回值函数<br>有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">printf(&quot;Hello,world \n&quot;); //没有返回值就不需要 return 语句 &#125;</span><br></pre></td></tr></table></figure>

<p>void 是 C 语言中的一个关键字，表示“空类型”或“无类型”，绝大部分情况下也就意味着没有 return 语句。</p>
<h6 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h6><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dataType1 param1, dataType2 param2 …是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由,分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。  </p>
<p>数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部。  </p>
<p>例如：计算从 m 加到 n 的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>调用 sum() 函数时，需要给它传递两份数据，一份传递给 m，一份传递给 n。你可以直接传递整数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = sum(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">//1 传递给 m， 100 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以传递变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> begin = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">86</span>;</span><br><span class="line"><span class="type">int</span> result = sum(begin, end); <span class="comment">//begin 传递给 m， end 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以整数和变量一起传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">33</span>;</span><br><span class="line"><span class="type">int</span> result = sum(num, <span class="number">80</span>); <span class="comment">//num 传递给 m， 80 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。<br>原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。  </p>
<h6 id="函数不能嵌套定义"><a href="#函数不能嵌套定义" class="headerlink" title="函数不能嵌套定义"></a>函数不能嵌套定义</h6><p>强调一点， C 语言不允许函数嵌套定义；也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。 main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。</p>
<p>函数不能嵌套定义，但可以嵌套调用，也就是在一个函数的定义或调用过程中允许出现对另外一个函数的调用。</p>
<h5 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h5><h6 id="形参（形式参数）"><a href="#形参（形式参数）" class="headerlink" title="形参（形式参数）"></a>形参（形式参数）</h6><p>在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。</p>
<h6 id="实参（实际参数）"><a href="#实参（实际参数）" class="headerlink" title="实参（实际参数）"></a>实参（实际参数）</h6><p>函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。<br>形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。</p>
<h6 id="形参和实参的区别和联系"><a href="#形参和实参的区别和联系" class="headerlink" title="形参和实参的区别和联系"></a>形参和实参的区别和联系</h6><p>(1) 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。<br>(2)  实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。<br>(4)  实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。<br>(5)  函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//计算从m加到n的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    total = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d\n&quot;</span>, total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers: 1 100↙<br>a&#x3D;1, b&#x3D;100<br>total&#x3D;5050</p>
<p>在这段代码中，函数定义处的 m、 n 是形参，函数调用处的 a、 b 是实参。通过 scanf() 可以读取用户输入的数据，并赋值给 a、 b，在调用 sum() 函数时，这份数据会传递给形参 m、 n。</p>
<p>从运行情况看，输入 a 值为 1，即实参 a 的值为 1，把这个值传递给函数 sum() 后，形参 m 的初始值也为 1，在函数执行过程中，形参 m 的值变为 5050。函数运行结束后，输出实参 a 的值仍为 1，可见实参的值不会随形参的变化而变化。</p>
<p>以上调用 sum() 时是将变量作为函数实参，除此以外，你也可以将常量、表达式、函数返回值作为实参，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">total = sum(<span class="number">10</span>, <span class="number">98</span>); <span class="comment">//将常量作为实参</span></span><br><span class="line">total = sum(a + <span class="number">10</span>, b - <span class="number">3</span>); <span class="comment">//将表达式作为实参</span></span><br><span class="line">total = sum(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="built_in">abs</span>(<span class="number">-100</span>)); <span class="comment">//将函数返回值作为实参</span></span><br></pre></td></tr></table></figure>

<p>(6) 形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效。  </p>
<h5 id="函数声明以及函数原型"><a href="#函数声明以及函数原型" class="headerlink" title="函数声明以及函数原型"></a>函数声明以及函数原型</h5><p>函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号;，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>也可以不写形参，只写数据类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1, dataType2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，称为函数原型（Function Prototype） 。函数原型的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。  </p>
<p>一般情况下，将函数定义放到 main() 的后面，将函数声明放到 main() 的前面，这样就使得代码结构清晰明了，主次分明。  </p>
<h5 id="C-语言变量的作用域"><a href="#C-语言变量的作用域" class="headerlink" title="C 语言变量的作用域"></a>C 语言变量的作用域</h5><p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。   </p>
<h6 id="函数内部定义的变量（局部变量）"><a href="#函数内部定义的变量（局部变量）" class="headerlink" title="函数内部定义的变量（局部变量）"></a>函数内部定义的变量（局部变量）</h6><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable） 。函数的形参也是局部变量，也只能在函数内部使用。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//m、 n、 i、 sum 都是局部变量，只能在 sum() 内部使用</span></span><br><span class="line">    <span class="keyword">for</span>(i=m; i&lt;=n; i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">5</span>, end = <span class="number">86</span>;</span><br><span class="line">    <span class="type">int</span> result = sum(begin, end);</span><br><span class="line">    <span class="comment">//begin、 end、 result 也都是局部变量，只能在 main() 内部使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum from %d to %d is %d\n&quot;</span>, begin, end, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>m、 n、 i、 sum 是局部变量，只能在 sum() 内部使用； begin、 end、 result 也是局部变量，只能在 main() 内部使用。<br>对局部变量的两点说明：<br>    main() 也是一个函数，在 main() 内部定义的变量也是局部变量，只能在 main() 函数内部使用。  </p>
<p>​	形参也是局部变量，将实参传递给形参的过程，就是用实参给局部变量赋值的过程，它和 a&#x3D;b; sum&#x3D;m+n;这样的赋值没有什么区别  </p>
<h6 id="所有函数外部定义的变量（全局变量）"><a href="#所有函数外部定义的变量（全局变量）" class="headerlink" title="所有函数外部定义的变量（全局变量）"></a>所有函数外部定义的变量（全局变量）</h6><p>全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件） 。如果给全局变量加上 static 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。</p>
<p>例：定义一个函数，根据长方体的长宽高求它的体积以及三个面的面积。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义三个全局变量，分别表示三个面的面积</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vs</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width, <span class="type">int</span> height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> v; <span class="comment">//体积</span></span><br><span class="line">    v = length * width * height;</span><br><span class="line">    s1 = length * width;</span><br><span class="line">    s2 = width * height;</span><br><span class="line">    s3 = length * height;	</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    v = vs(<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    v = vs(<span class="number">5</span>, <span class="number">17</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>v&#x3D;9000, s1&#x3D;300, s2&#x3D;600, s3&#x3D;450<br>v&#x3D;680, s1&#x3D;85, s2&#x3D;136, s3&#x3D;40  </p>
<p>通过变量的使用可以得到： 在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。  </p>
<p>C 语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：<br>    不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；<br>    函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。  </p>
<p>当函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。</p>
<p>变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。另外，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>; <span class="comment">//局部变量</span></span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>func1 n: 20<br>func2 n: 30<br>func3 n: 10<br>main n: 30</p>
<p>代码中虽然定义了多个同名变量 n，但它们的作用域不同，所有不会产生命名冲突。</p>
<p>下面是对输出结果的分析：<br>    对于 func1()，输出结果为 20，显然使用的是 func1() 内部的 n，而不是外部的 n。<br>    调用 func2() 时，会把 main() 中的实参 n 传递给 func2() 中的形参 n，此时形参 n 的值变为 30。形参 n 也<br>是局部变量，所以就使用它了。<br>    func3() 输出 10，使用的是全局变量，因为在 func3() 中不存在局部变量 n，所以编译器只能到函数外部，也<br>就是全局作用域中去寻找变量 n。<br>     main() 中 printf() 语句输出 30，说明使用的是 main() 中的 n，而不是外部的 n。  </p>
<h6 id="块级变量（在代码块内部定义的变量）"><a href="#块级变量（在代码块内部定义的变量）" class="headerlink" title="块级变量（在代码块内部定义的变量）"></a>块级变量（在代码块内部定义的变量）</h6><p>C 语言允许在代码块内部定义变量，这样的变量具有块级作用域；换句话说，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">22</span>; <span class="comment">//编号①</span></span><br><span class="line">    <span class="comment">//由&#123; &#125;包围的代码块</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">40</span>; <span class="comment">//编号②</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>block n: 40<br>main n: 22  </p>
<h6 id="再谈作用域"><a href="#再谈作用域" class="headerlink" title="再谈作用域"></a>再谈作用域</h6><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">822</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;if m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = i % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">2</span> &amp;&amp; n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;else m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710211606098.png" class="" title="image-20230710211606098">

<p>蓝色表示作用域的名称， 红色表示作用域中的变量， global 表示全局作用域。在灰色背景的作用域中，我们使用到了 m 变量，而该变量位于全局作用域中，所以得穿越好几层作用域才能找到 m。</p>
<h5 id="递归函数（递归调用）"><a href="#递归函数（递归调用）" class="headerlink" title="递归函数（递归调用）"></a>递归函数（递归调用）</h5><p>个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。  </p>
<p>以求阶乘为例，阶乘 n! 的计算公式如下：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710214033219.png" class="" title="image-20230710214033219">

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Factorial(%d) = %ld\n&quot;</span>, a, factorial(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 5↙<br>Factorial(5) &#x3D; 120  </p>
<p>factorial() 就是一个典型的递归函数。调用 factorial() 后即进入函数体，只有当 n&#x3D;&#x3D;0 或 n&#x3D;&#x3D;1 时函数才会执行结<br>束，否则就一直调用它自身。</p>
<p>由于每次调用的实参为 n-1，即把 n-1 的值赋给形参 n，所以每次递归实参的值都减 1，直到最后 n-1 的值为 1时再作递归调用，形参 n 的值也为 1，递归就终止了，会逐层退出。  </p>
<p>下表列出了逐层进入的过程：</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>实参&#x2F;形参</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>需要等待的结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>n&#x3D;5</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的结果</td>
</tr>
<tr>
<td>2</td>
<td>n&#x3D;4</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的结果</td>
</tr>
<tr>
<td>3</td>
<td>n&#x3D;3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的结果</td>
</tr>
<tr>
<td>4</td>
<td>n&#x3D;2</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的结果</td>
</tr>
<tr>
<td>5</td>
<td>n&#x3D;1</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
</tr>
</tbody></table>
<p>当递归进入到最内层的时候，递归就结束了，就开始逐层退出了，也就是逐层执行 return 语句。  </p>
<p>下表列出了逐层退出的过程</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>从内层递归得到的结果 （内层函数的返回值）</th>
<th>表达式的值 （当次调用的结果）</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的返回值，也就是 1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的返回值，也就是 2</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的返回值，也就是 6</td>
<td>24</td>
</tr>
<tr>
<td>1</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的返回值，也就是 24</td>
<td>120</td>
</tr>
</tbody></table>
<h6 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h6><p>每一个递归函数都应该只进行有限次的递归调用，否则它就会进入死胡同，永远也不能退出了，这样的程序是没有意义的。</p>
<p>要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题：<br>    存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束<br>了。<br>    每次递归调用之后越来越接近这个限制条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n<br>的值逐渐减小，越来越趋近于 1 或 0。  </p>
<h6 id="中间递归函数"><a href="#中间递归函数" class="headerlink" title="中间递归函数"></a>中间递归函数</h6><p>所谓中间递归，就是发生递归的位置在函数体的中间，而不是末尾。<br>尾递归在逐层退出时除了 return 语句，一般不再执行其他操作；而中间递归在逐层退出时还要执行一些其他的操作，所以比较复杂。</p>
<p>例如：字符串反转（逆置）函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//反转（逆置）字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">reverse</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> ctemp = str[<span class="number">0</span>];</span><br><span class="line">            str[<span class="number">0</span>] = str[len - <span class="number">1</span>];</span><br><span class="line">            str[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//最后一个字符在下次递归时不再处理</span></span><br><span class="line">            reverse(str + <span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">            str[len - <span class="number">1</span>] = ctemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, reverse(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>987654321</p>
<p>每次调用函数，都会把字符串的第 0 个字符保存到 ctemp 变量，并把最后一个字符填充到第 0 个字符的位置，同时用’\0’来填充最后一个字符的位置。  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710231414691.png" class="" title="image-20230710231414691">

<p>reverse() 的整体思路是，每次调用函数只交换字符串开头和末尾的两个字符，其它字符一律不管，并且这个交换过程也是分两个阶段完成的：</p>
<p>在逐层进入递归的阶段， reverse() 只是把字符串的最后一个字符移动到最前边，但是并没有把最前边一个字符移动到最后边，而是把最前边的字符保存到 ctemp 变量。</p>
<p>在逐层退出递归的阶段， reverse() 才把 ctemp 变量中保存的字符放到字符串的最前边。</p>
<p>两个阶段相互合作，才能最终完成两个字符的交换。  </p>
<h6 id="多层递归函数"><a href="#多层递归函数" class="headerlink" title="多层递归函数"></a>多层递归函数</h6><p>多层递归的调用关系比较复杂，整体上看起来像一颗倒立的树：对于双层递归，树的每个节点有两个分叉；对<br>于三层递归，树的每个节点有三个分叉；以此类推……<br>下面以「求菲波那契数」为例:</p>
<p>菲波那契数就是一个数列，数列中每个数的值就是它前面两个数的和，这种关系常常用以下形式进行描述：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112109326.png" class="" title="image-20230711112109326">

<p>代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 7↙<br>Fib(7) &#x3D; 13  </p>
<p>当 n≥2 时，每次调用 fib(n) 都要等待 fib(n-1) 和 fib(n-2) 的结果，这种调用关系看起来就像一棵倒立的二叉树，如下图所示：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112233095.png" class="" title="image-20230711112233095">

<p>双层递归的调用关系和数据结构中二叉树的结构完全吻合，所以双层递归常用于二叉树的遍历。</p>
<p>单层递归每次只等待一个函数的结果，双层递归每次要等待两个函数的结果，这就是它们之间最本质的区别。  </p>
<h5 id="递归函数的缺陷和优化"><a href="#递归函数的缺陷和优化" class="headerlink" title="递归函数的缺陷和优化"></a>递归函数的缺陷和优化</h5><h6 id="递归函数的空间开销"><a href="#递归函数的空间开销" class="headerlink" title="递归函数的空间开销"></a>递归函数的空间开销</h6><p>递归函数内部嵌套了对自身的调用，除非等到最内层的函数调用结束，否则外层的所有函数都不会调用结束。</p>
<p>通俗地讲，外层函数被卡主了，它要等待所有的内层函数调用完成后，它自己才能调用完成。</p>
<p>每一层的递归调用都会在栈上分配一块内存， 有多少层递归调用就分配多少块相似的内存，所有内存加起来的总和是相当恐怖的，很容易超过栈内存的大小限制，这个时候就会导致程序崩溃。</p>
<p>例如，一个递归函数需要递归 10000 次，每次需要 1KB 的内存，那么最终就需要 10MB 的内存  </p>
<h6 id="递归函数的时间开销"><a href="#递归函数的时间开销" class="headerlink" title="递归函数的时间开销"></a>递归函数的时间开销</h6><p>每次调用函数都会在栈上分配内存，函数调用结束后再释放这一部分内存，内存的分配和释放都是需要时间的。<br>每次调用函数还会多次修改寄存器的值，函数调用结束后还需要找到上层函数的位置再继续执行，这也是需要时间的。 </p>
<p>以「求斐波那契数」为例  ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>   </span></span><br><span class="line"><span class="comment">// 递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start, time_end;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    time_start = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    time_end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end - time_start)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 42↙<br>Fib(42) &#x3D; 267914296<br>run time: 0.833000s</p>
<p>可以看到，求 42 的斐波那契数程序所用的时间为 0.83 秒。  </p>
<h6 id="使用迭代来替换递归函数"><a href="#使用迭代来替换递归函数" class="headerlink" title="使用迭代来替换递归函数"></a>使用迭代来替换递归函数</h6><p>递归函数应为原理层面的缺陷，无法优化，但大部分能用递归解决的问题也能用迭代来解决。所谓迭代，就是循环。</p>
<p>许多问题是以递归的形式进行解释的，这只是因为它比非递归形式更为清晰。但是， 这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性可能稍差一些。  </p>
<p>还是以求斐波那契数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_recursion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib_recursion(n - <span class="number">1</span>) + fib_recursion(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_iteration</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="type">long</span> previous_result;</span><br><span class="line">    <span class="type">long</span> next_older_result;</span><br><span class="line">    result = previous_result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        next_older_result = previous_result;</span><br><span class="line">        previous_result = result;</span><br><span class="line">        result = previous_result + next_older_result;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start_recursion, time_end_recursion;</span><br><span class="line">    <span class="type">clock_t</span> time_start_iteration, time_end_iteration;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="comment">//递归的时间</span></span><br><span class="line">    time_start_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_recursion(%d) = %ld\n&quot;</span>, a, fib_recursion(a));</span><br><span class="line">    time_end_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with recursion: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_recursion -</span><br><span class="line">    time_start_recursion)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="comment">//迭代的时间</span></span><br><span class="line">    time_start_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_iteration(%d) = %ld\n&quot;</span>, a, fib_iteration(a));</span><br><span class="line">    time_end_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with iteration: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_iteration - time_start_iteration)</span><br><span class="line">    / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>Input a number: 42<br>Fib_recursion(42) &#x3D; 267914296<br>run time with recursion: 0.854000s<br>Fib_iteration(42) &#x3D; 267914296<br>run time with iteration: 0.000000s</p>
<p>可以看出迭代还是比递归快一点点的。</p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础概念</title>
    <url>/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h6 id="原码，反码和补码"><a href="#原码，反码和补码" class="headerlink" title="原码，反码和补码"></a>原码，反码和补码</h6><p>数据在C语言是以二进制的方式存储。因为二进制的加减运算问题。数据存储为补码。反码是原码逐一取反，补码为反码+1。</p>
<span id="more"></span>

<h6 id="进制中小数的转换"><a href="#进制中小数的转换" class="headerlink" title="进制中小数的转换"></a>进制中小数的转换</h6><p>十进制小数转换成 N 进制小数采用“乘 N 取整，顺序排列”法。具体做法是：<br>　　用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分；<br>　　将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积；<br>　　再将积的整数部分取出，继续用 N 乘以余下的小数部分；<br>　　……<br>　　如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求<br>的精度为止。  </p>
<img src="/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/002.png" class="">

<p>　十进制小数 0.6875 转换成二进制小数的结果为 0.1011。  </p>
<h6 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h6><p>　　当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory） 。  </p>
<h6 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h6><p>　　用固定的二进制数表示固定的字符。各国字符集在ASCII基础上扩展，原来 ASCII 中已经包含的字符，在国家编码（地区编码）中的位置不变（也就是编码值不变），只是在这些字符的后面增添了新的字符。  </p>
<h6 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h6><p>UTF-8：一种变长的编码方案，使用 1~6 个字节来存储；</p>
<p>如果只有一个字节， 那么最高的比特位为 0，这样可以兼容 ASCII；<br>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的<br>字节均以 10 开头。</p>
<p>UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</p>
<p>特点：空间换效率</p>
<p>UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。  </p>
<h6 id="全角和半角输入法的区别"><a href="#全角和半角输入法的区别" class="headerlink" title="全角和半角输入法的区别"></a>全角和半角输入法的区别</h6><p>在计算机屏幕上，一个汉字要占两个英文字符的位置，人们把一个英文字符所占的位置称为“半角”，相对地把一个汉字所占的位置称为“全角”。</p>
<p> “相同”字符在全角和半角状态下对应的编码值（例如 Unicode 编码、 GBK 编码等）不一样，所以它们是不同的字符。  </p>
<h6 id="C语言程序的执行"><a href="#C语言程序的执行" class="headerlink" title="C语言程序的执行"></a>C语言程序的执行</h6><p>先把代码编译（转换成二进制），再链接（“打包”将所有二进制形式的目标文件和系统组件组合成一个可执行文件  ）。最后生成可执行文件。</p>
<h6 id="整形的长度"><a href="#整形的长度" class="headerlink" title="整形的长度"></a>整形的长度</h6><p>C 语言并没有严格规定 short、 int、 long 的长度，只做了宽泛的限制：<br>　short 至少占用 2 个字节。<br>　int 建议为一个机器字长。 32 位环境下机器字长为 4 字节， 64 位环境下机器字长为 8 字节。<br>　short 的长度不能大于 int， long 的长度不能小于 int。  </p>
<p>  获取某个数据类型的长度可以使用 sizeof 操作符  </p>
<h6 id="进制的表示"><a href="#进制的表示" class="headerlink" title="进制的表示"></a>进制的表示</h6><img src="/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/001.png" class="">

<h6 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h6><p>​        转义字符以\或者\x 开头，以\开头表示后跟八进制形式的编码值，以\x 开头表示后跟十六进制形式的编码值。 对于<br>转义字符来说，只能使用八进制或者十六进制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\x31\x32\x33\x61\x62\x63&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果为“123abc”</p>
<h6 id="加减乘除的优先性"><a href="#加减乘除的优先性" class="headerlink" title="加减乘除的优先性"></a>加减乘除的优先性</h6><p>和数学上的优先级相同。如果符号的优先级相同，则更具结合性判断。先执行左边的叫左结合性，先执行右边的叫右结合性。  </p>
<h6 id="对取余运算的说明"><a href="#对取余运算的说明" class="headerlink" title="对取余运算的说明"></a>对取余运算的说明</h6><p>余数可以是正数也可以是负数，由 % 左边的整数决定：<br>　　如果 % 左边是正数，那么余数也是正数；<br>　　如果 % 左边是负数，那么余数也是负数  </p>
<h6 id="printf-的高级用法"><a href="#printf-的高级用法" class="headerlink" title="printf() 的高级用法"></a>printf() 的高级用法</h6><p>printf() 格式控制符的完整形式如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flag][width][.precision]type</span><br></pre></td></tr></table></figure>

<p>[ ] 表示此处的内容可有可无，是可以省略的。  </p>
<p>　　type 表示输出类型，比如 %d、 %f、 %c、 %lf， type 就分别对应 d、 f、 c、 lf；再如， %-9d 中 type 对应 d。<br>type 这一项必须有，这意味着输出时必须要知道是什么类型。<br>　　width 表示最小输出宽度，也就是至少占用几个字符的位置；例如， %-9d 中 width 对应 9，表示输出结果最少<br>占用 9 个字符的宽度。<br>　　当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；当输出结果的<br>宽度超过 width 时， width 不再起作用，按照数据本身的宽度来输出。  </p>
<h6 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h6><p>　　缓冲区位于用户程序和硬件设备之间，用来缓存数据，目的是让快速的 CPU 不必等待慢速的输入输出设备，同时减少操作硬件的次数。对于 IO 密集型的网络应用程序，比如网站、数据库、 DNS、 CDN 等，缓冲区的设计至关重要，它能十倍甚至一百倍得提高程序性能。  </p>
<h6 id="scanf-控制字符串"><a href="#scanf-控制字符串" class="headerlink" title="scanf()控制字符串"></a>scanf()控制字符串</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;*&#125; &#123;width&#125; type</span><br></pre></td></tr></table></figure>

<p>其中， { } 表示可有可无。各个部分的具体含义是：</p>
<p>type 表示读取什么类型的数据，例如 %d、 %s、 %[a-z]、 %[^\n] 等； type 必须有。</p>
<p>width 表示最大读取宽度，可有可无。<br>*表示丢弃读取到的数据，可有可无。</p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针</title>
    <url>/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h5 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h5><h6 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h6><p>定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">datatype *name;</span><br></pre></td></tr></table></figure>

<span id="more"></span>或者

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">datatype *name = value;</span><br></pre></td></tr></table></figure>

<p>*表示这是一个指针变量， datatype 表示该指针变量所指向的数据的类型 。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1;</span><br></pre></td></tr></table></figure>

<p>p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p_a = &amp;a;</span><br></pre></td></tr></table></figure>

<p>在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址， a 前面必须要加取地址符&amp;，否则是不对的。 和普通变量一样，指针变量也可以被多次写入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义普通变量 float a = 99.5, b = 10.6;</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;@&#x27;</span>, d = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//定义指针变量 float *p1 = &amp;a; char *p2 = &amp;c;</span></span><br><span class="line"><span class="comment">//修改指针变量的值 p1 = &amp;b; p2 = &amp;d;</span></span><br></pre></td></tr></table></figure>

<p>定义指针变量时必须带 *给指针变量赋值时不能带 *</p>
<p>假设变量 a、 b、 c、 d 的地址分别为 0X1000、 0X1004、 0X2000、 0X2004，下面的示意图很好地反映了 p1、 p2 指向的变化：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717102521773.png" class="" title="image-20230717102521773">

<p>另外，p1、 p2 的类型分别是 float *和 char *，而不是 float 和 char，它们是完全不同的数据类型。</p>
<h6 id="通过指针变量取得数据"><a href="#通过指针变量取得数据" class="headerlink" title="通过指针变量取得数据"></a>通过指针变量取得数据</h6><p>指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pointer;</span><br></pre></td></tr></table></figure>

<p>这里的 * 称为指针运算符，用来取得某个地址上的数据，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>; <span class="type">int</span> *p = &amp;a; <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a, *p); <span class="comment">//两种方式都可以输出a的值 return 0; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>15, 15  </p>
<p>假设变量 a、 p 的地址分别为 0X1000、 0XF0A0，它们的指向关系如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717103956709.png" class="" title="image-20230717103956709">

<p>程序被编译和链接后， a、 p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。  </p>
<p><strong>那么，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</strong>  </p>
<p>另外，给指针变量本身赋值时不能加 *，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>指针变量也可以出现在普通变量能出现的任何表达式中，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y, *px = &amp;x, *py = &amp;y;</span><br><span class="line">y = *px + <span class="number">5</span>; <span class="comment">//表示把x的内容加5并赋给y， *px+5相当于(*px)+5</span></span><br><span class="line">y = ++*px; <span class="comment">//px的内容加上1之后赋给y， ++*px相当于++(*px)</span></span><br><span class="line">y = *px++; <span class="comment">//相当于y=(*px)++</span></span><br><span class="line">py = px; <span class="comment">//把一个指针的值赋给另一个指针 </span></span><br></pre></td></tr></table></figure>

<h6 id="关于-和-amp-的拓展"><a href="#关于-和-amp-的拓展" class="headerlink" title="关于 * 和 &amp;的拓展"></a>关于 * 和 &amp;的拓展</h6><p>假设有一个 int 类型的变量 a， pa 是指向它的指针，那么* &amp;a 和&amp;* pa 分别是什么意思呢？</p>
<ul>
<li>&amp;a 可以理解为*(&amp;a)， &amp;a 表示取变量 a 的地址（等价于 pa）， *(&amp;a)表示取这个地址上的数据（等价于 <em>pa），绕来绕去，又回到了原点， * &amp;a 仍然等价于 a。<br>&amp;</em> pa 可以理解为&amp;(<em>pa)， * pa 表示取得 pa 指向的数据（等价于 a）， &amp;(</em> pa)表示数据的地址（等价于 &amp;a），所以&amp;*pa 等价于 pa。</li>
</ul>
<h6 id="指针变量的运算"><a href="#指针变量的运算" class="headerlink" title="指针变量的运算"></a>指针变量的运算</h6><p>指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, *pa = &amp;a, *paa = &amp;a;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">99.9</span>, *pb = &amp;b;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;@&#x27;</span>, *pc = &amp;c;</span><br><span class="line"><span class="comment">//最初的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%#X, &amp;b=%#X, &amp;c=%#X\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);</span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line">    pa++; pb++; pc++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);  </span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line">    pa -= <span class="number">2</span>; pb -= <span class="number">2</span>; pc -= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);</span><br><span class="line"><span class="comment">//比较运算</span></span><br><span class="line">    <span class="keyword">if</span>(pa == paa)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *paa);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>&amp;a&#x3D;0X62FDFC, &amp;b&#x3D;0X62FDF0, &amp;c&#x3D;0X62FDEF<br>pa&#x3D;0X62FDFC, pb&#x3D;0X62FDF0, pc&#x3D;0X62FDEF<br>pa&#x3D;0X62FE00, pb&#x3D;0X62FDF8, pc&#x3D;0X62FDF0<br>pa&#x3D;0X62FDF8, pb&#x3D;0X62FDE8, pc&#x3D;0X62FDEE<br>4203849</p>
<p>从运算结果可以看出： pa、 pb、 pc 每次加 1，它们的地址分别增加 4、 8、 1，正好是 int、 double、 char 类型的长度；减 2 时，地址分别减少 8、 16、 2，正好是 int、 double、 char 类型长度的 2 倍 。</p>
<p>以 a 和 pa 为例， a 的类型为 int，占用 4 个字节， pa 是指向 a 的指针，如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110027660.png" class="" title="image-20230717110027660">

<p>这个时候 pa 指向整数 a 的中间， *pa 使用的是橙色虚线画出的 4 个字节，其中前 3 个是变量 a 的，后面 1 个是其它数据的，把它们“搅和”在一起显然没有实际的意义，取得的数据也会非常怪异。<br>如果 pa++;使得地址加 4 的话，正好能够完全跳过整数 a，指向它后面的内存，如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110107877.png" class="" title="image-20230717110107877">

<p>数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，这样指针的加减运算就具有了现实的意义。</p>
<p>但是，C 语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。    </p>
<h5 id="数组指针（指向数组的指针）"><a href="#数组指针（指向数组的指针）" class="headerlink" title="数组指针（指向数组的指针）"></a>数组指针（指向数组的指针）</h5><p>数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以 int arr[] &#x3D; { 99, 15, 100, 888, 252 };为例，该数组在内存中的分布如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110323031.png" class="" title="image-20230717110323031">

<p>定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。 在 C 语言中，我们将第 0 个元素的地址称为数组的首地址。 以上面的数组为例，下图是 arr 的指向：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110348101.png" class="" title="image-20230717110348101">

<p>以指针的方式遍历数组元素为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">99</span>,<span class="number">15</span>,<span class="number">100</span>,<span class="number">888</span>,<span class="number">252</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">//求数组长度</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(arr+i)); <span class="comment">//*(arr+i)等价于arr[i]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>99 15 100 888 252</p>
<p>第 5 行代码用来求数组的长度， sizeof(arr) 会获得整个数组所占用的字节数， sizeof(int) 会获得一个数组元素所占用的字节数，它们相除的结果就是数组包含的元素个数，也即数组长度。<br>第 8 行代码中我们使用了*(arr+i)这个表达式， arr 是数组名，指向数组的第 0 个元素，表示数组首地址， arr+i 指向数组的第 i 个元素， *(arr+i) 表示取第 i 个元素的数据，它等价于 arr[i]。  </p>
<p>我们也可以定义一个指向数组的指针，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p>arr 本身就是一个指针，可以直接赋值给指针变量 p。 arr 是数组第 0 个元素的地址，所以 int *p &#x3D; arr;也可以写作int *p &#x3D; &amp;arr[0];。也就是说， arr、 p、 &amp;arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头 。</p>
<p>引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。  </p>
<p>(1) 使用下标<br>也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。</p>
<p>(2) 使用指针<br>也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。</p>
<p>不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。  </p>
<h6 id="关于数组指针的拓展"><a href="#关于数组指针的拓展" class="headerlink" title="关于数组指针的拓展"></a>关于数组指针的拓展</h6><p>假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、 *++p、 (*p)++ 分别是什么意思呢？</p>
<p>*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素。</p>
<p>*++p 等价于 * (++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 * (p+1)，所以会获得第 n+1 个数组元素的值。<br>(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0 个元素，并且第个元素的值为 99，执行完该语句后，第 0 个元素的值就会变为 100。  </p>
<h5 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h5><p>C 语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中 ，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str), i;</span><br><span class="line">	<span class="comment">//直接输出字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="comment">//每次输出一个字符</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<p>wearexc.github.io</p>
<p>使用指针的方式来输出字符串：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *pstr = str;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str), i;  <span class="comment">//strlen是计算数组的长度 </span></span><br><span class="line">	<span class="comment">//使用*(pstr+i)</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(pstr+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//使用pstr[i]</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, pstr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//使用*(str+i)</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(str+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了字符数组， C 语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str = <span class="string">&quot;wearexc.github.io&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p>但需要注意的是，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。</p>
<h5 id="二级指针（指向指针的指针）"><a href="#二级指针（指向指针的指针）" class="headerlink" title="二级指针（指向指针的指针）"></a>二级指针（指向指针的指针）</h5><p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。</p>
<p>假设有一个 int 类型的变量 a， p1 是指向 a 的指针变量， p2 又是指向 p1 的指针变量，它们的关系如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717141917427.png" class="" title="image-20230717141917427">

<p>即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a =100;</span><br><span class="line">int *p1 = &amp;a;</span><br><span class="line">int **p2 = &amp;p1;</span><br></pre></td></tr></table></figure>

<p>指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。 C 语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 * 。 p1 是一级指针，指向普通类型的数据，定义时有一个 * ； p2 是二级指针，指向一级指针 p1，定义时有两个*。</p>
<p>如果我们希望再定义一个三级指针 p3，让它指向 p2，那么可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure>

<p>四级指针也是类似的道理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ****p4 = &amp;p3;  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p1;</span><br><span class="line">    <span class="type">int</span> ***p3 = &amp;p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d\n&quot;</span>, a, *p1, **p2, ***p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p2 = %#X, p3 = %#X\n&quot;</span>, &amp;p2, p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n&quot;</span>, &amp;p1, p2, *p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n&quot;</span>, &amp;a, p1, *p2, **p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>100, 100, 100, 100<br>&amp;p2 &#x3D; 0X62FE00, p3 &#x3D; 0X62FE00<br>&amp;p1 &#x3D; 0X62FE08, p2 &#x3D; 0X62FE08, *p3 &#x3D; 0X62FE08<br> &amp;a &#x3D; 0X62FE14, p1 &#x3D; 0X62FE14, *p2 &#x3D; 0X62FE14, **p3 &#x3D; 0X62FE14</p>
<p>以三级指针 p3 为例来分析上面的代码。 *<em><em>p3 等价于</em>(</em> (*p3))。 *p3 得到的是 p2 的值，也即 p1 的地址； * (<em>p3)得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后， * (</em> (*p3)) 得到的才是 a 的值。</p>
<h5 id="指针数组（数组每个元素都是指针）"><a href="#指针数组（数组每个元素都是指针）" class="headerlink" title="指针数组（数组每个元素都是指针）"></a>指针数组（数组每个元素都是指针）</h5><p>如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType *arrayName[length];</span><br></pre></td></tr></table></figure>

<p>[ ]的优先级高于*，该定义形式应该理解为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType *(arrayName[length]);</span><br></pre></td></tr></table></figure>

<p>括号里面说明 arrayName 是一个数组，包含了 le  ngth 个元素，括号外面说明每个元素的类型为 dataType *。<br>除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">16</span>, b = <span class="number">932</span>, c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个指针数组</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//也可以不指定长度，直接写作 int *parr[]</span></span><br><span class="line">    <span class="comment">//定义一个指向指针数组的指针</span></span><br><span class="line">    <span class="type">int</span> **parr = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, *arr[<span class="number">0</span>], *arr[<span class="number">1</span>], *arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, **(parr+<span class="number">0</span>), **(parr+<span class="number">1</span>), **(parr+<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>16, 932, 100<br>16, 932, 100</p>
<p>arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、 b、 c 的地址对它进行了初始化，这和普通数组是多么地类似。</p>
<p>parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为 int *(<em>parr)，括号中的</em>表示 parr 是一个指针，括号外面的 int *表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，</p>
<p>所以在定义 parr 时要加两个 *。</p>
<p>第一个 printf() 语句中， arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。</p>
<p>第二个 printf() 语句中， parr+i 表示第 i 个元素的地址， *(parr+i) 表示获取第 i 个元素的值（该元素是一个指针），<br>**(parr+i) 表示获取第 i 个元素指向的数据。  </p>
<h5 id="二维数组指针（指向二维数组的指针）"><a href="#二维数组指针（指向二维数组的指针）" class="headerlink" title="二维数组指针（指向二维数组的指针）"></a>二维数组指针（指向二维数组的指针）</h5><p>二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;  </span><br></pre></td></tr></table></figure>

<p>从概念上理解， a 的分布像一个矩阵：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>但在内存中， a 的分布是一维线性的，整个数组占用一块连续的内存：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717205537599.png" class="" title="image-20230717205537599">

<p>C 语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) &#x3D; 48 个字节。<br>C 语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、 a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0] [0]、 a[0] [1]、 a[0] [2]、 a[0] [3]。<br>假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717205632015.png" class="" title="image-20230717205632015">

<p>为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = a;</span><br></pre></td></tr></table></figure>

<p>括号中的 * 表明 p 是一个指针，它指向一个数组，数组的类型为 int [4]，这正是 a 所包含的每个一维数组的类型。</p>
<p>[ ]的优先级高于*， ( )是必须要加的，如果赤裸裸地写作 int *p[4]，那么应该理解为 int *(p[4])， p 就成了一个指针数组，而不是二维数组指针。<br>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关， p 指向的数据类型是 int [4]，那么 p+1 就前进 4×4 &#x3D; 16 个字节， p-1 就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说， p+1 会使得指针指向二维数组的下一行， p-1 会使得指针指向数组的上一行。</p>
<p>那么，可以知道</p>
<p>(1) p 指向数组 a 的开头，也即第 0 行； p+1 前进一行，指向第 1 行。<br>(2) *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素。    </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(p+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>16  </p>
<p>(3) *(p+1)+1 表示第 1 行第 1 个元素的地址。如何理解呢？</p>
<p>*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；</p>
<p>就像一维数组的名字，在定义时或者和 sizeof、 &amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。</p>
<p>(4) *( *(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。<br>根据上面的结论，可以很容易推出以下的等价关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a+i == p+i</span><br><span class="line">a[i] == p[i] == *(a+i) == *(p+i)</span><br><span class="line">a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)  </span><br></pre></td></tr></table></figure>

<h6 id="指针数组和二维数组指针的区别"><a href="#指针数组和二维数组指针的区别" class="headerlink" title="指针数组和二维数组指针的区别"></a>指针数组和二维数组指针的区别</h6><p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *(p1[<span class="number">5</span>]); <span class="comment">//指针数组，可以去掉括号直接写作 int *p1[5];</span></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>]; <span class="comment">//二维数组指针，不能去掉括号 </span></span><br></pre></td></tr></table></figure>

<p> 指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1为例，在 32 位环境下它占用 4×5 &#x3D; 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。  </p>
<h5 id="函数指针（指向函数的指针）"><a href="#函数指针（指向函数的指针）" class="headerlink" title="函数指针（指向函数的指针）"></a>函数指针（指向函数的指针）</h5><p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。<br>函数指针的定义形式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);  </span><br></pre></td></tr></table></figure>

<p>returnType 为函数返回值类型， pointerNmae 为指针名称， param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。<br>注意( )的优先级高于*，第一个括号不能省略，如果写作 returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为 returnType *。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//返回两个数中较大的一个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, maxval;</span><br><span class="line">    <span class="comment">//定义函数指针</span></span><br><span class="line">    <span class="type">int</span> (*pmax)(<span class="type">int</span>, <span class="type">int</span>) = max; <span class="comment">//也可以写作int (*pmax)(int a, int b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    maxval = (*pmax)(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value: %d\n&quot;</span>, maxval);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers:10 50↙<br>Max value: 50</p>
<p>第 14 行代码对函数进行了调用。 pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。注意( )的优先级高于*，第一个括号不能省略。  </p>
<h5 id="对-C-语言指针的总结"><a href="#对-C-语言指针的总结" class="headerlink" title="对 C 语言指针的总结"></a>对 C 语言指针的总结</h5><p>指针（Pointer）就是内存的地址， C 语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。</p>
<p>程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。</p>
<p>常见指针变量的定义</p>
<table>
<thead>
<tr>
<th>定 义</th>
<th>含 义</th>
</tr>
</thead>
<tbody><tr>
<td>int *p;</td>
<td>p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。</td>
</tr>
<tr>
<td>int **p;</td>
<td>p 为二级指针，指向 int * 类型的数据。</td>
</tr>
<tr>
<td>int *p[n];</td>
<td>p 为指针数组。 [ ] 的优先级高于 *，所以应该理解为 int *(p[n]);</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言数组</title>
    <url>/2023/07/09/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h5 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h5><h6 id="数组的概念和定义"><a href="#数组的概念和定义" class="headerlink" title="数组的概念和定义"></a>数组的概念和定义</h6><p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这样，就在内存中分配了 4 个 int 类型的内存空间，共 4×4&#x3D;16 个字节，并为它们起了一个名字， 叫 a。<span id="more"></span><br>我们把这样的一组数据的集合称为数组（Array） ，它所包含的每一个数据叫做数组元素（Element） ，所包含的数据的个数称为数组长度（Length） ，例如 int a[4];就定义了一个长度为 4 的整型数组，名字是 a。<br>数组中的每个元素都有一个序号，这个序号从 0 开始，而不是从我们熟悉的 1 开始，称为下标（Index） 。使用数组元素时，指明下标即可，形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arrayName[index]</span><br></pre></td></tr></table></figure>

<p>arrayName 为数组名称， index 为下标。例如， a[0] 表示第 0 个元素， a[3] 表示第 3 个元素。    </p>
<p>所以数组的定义方式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType arrayName[length];  </span><br></pre></td></tr></table></figure>

<p>dataType 为数据类型， arrayName 为数组名称， length 为数组长度。  </p>
<h6 id="数组内存是连续的"><a href="#数组内存是连续的" class="headerlink" title="数组内存是连续的"></a>数组内存是连续的</h6><p>数组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。   </p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组定义的一般形式是：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType arrayName[length1][length2];  </span><br></pre></td></tr></table></figure>

<p>其中， dataType 为数据类型， arrayName 为数组名， length1 为第一维下标的长度， length2 为第二维下标的长度。<br>我们可以将二维数组看做一个 Excel 表格，有行有列， length1 表示行数， length2 表示列数，要在二维数组中定位某个元素，必须同时指明行和列。 例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];  </span><br></pre></td></tr></table></figure>

<p>定义了一个 3 行 4 列的二维数组，共有 3×4&#x3D;12 个元素，数组名为 a，即：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">0</span>][<span class="number">1</span>], a[<span class="number">0</span>][<span class="number">2</span>], a[<span class="number">0</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，二维数组是按行排列的。 也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4)&#x3D;48 个字节。<br>可以认为，二维数组是由多个长度相同的一维数组构成的。</p>
<h6 id="二维数组的初始化（赋值）"><a href="#二维数组的初始化（赋值）" class="headerlink" title="二维数组的初始化（赋值）"></a>二维数组的初始化（赋值）</h6><p>二维数组的初始化可以按行分段赋值，也可按行连续赋值。</p>
<p>例如，对于数组 a[5][3]，按行分段赋值应该写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;, &#123;<span class="number">61</span>,<span class="number">65</span>,<span class="number">71</span>&#125;, &#123;<span class="number">59</span>,<span class="number">63</span>,<span class="number">70</span>&#125;, &#123;<span class="number">85</span>,<span class="number">87</span>,<span class="number">90</span>&#125;, &#123;<span class="number">76</span>,<span class="number">77</span>,<span class="number">85</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>按行连续赋值应该写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>]=&#123;<span class="number">80</span>, <span class="number">75</span>, <span class="number">92</span>, <span class="number">61</span>, <span class="number">65</span>, <span class="number">71</span>, <span class="number">59</span>, <span class="number">63</span>, <span class="number">70</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">90</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">85</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这两种赋初值的结果是完全相同的。    </p>
<p>对于二维数组的初始化还要注意以下几点：  </p>
<p>(1) 可以只对部分元素赋值，未赋值的元素自动取“零”值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>是对每一行的第一列元素赋值，未赋值的元素的值为 0。赋值后各元素的值为：<br>1 0 0<br>2 0 0<br>3 0 0<br>再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值后各元素的值为：<br>0 1 0<br>0 0 2<br>3 0 0<br>(2)如果对全部元素赋值，那么第一维的长度可以不给出。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;  </span><br></pre></td></tr></table></figure>



<p>(3) 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当<br>然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组， C 语言允许这种分解。<br>例如，二维数组 a[3][4]可分解为三个一维数组，它们的数组名分别为 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>]、 a[<span class="number">1</span>]、 a[<span class="number">2</span>]  </span><br></pre></td></tr></table></figure>

<p>这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素，比如，一维数组 a[0] 的元素为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]、 a[<span class="number">0</span>][<span class="number">1</span>]、a[<span class="number">0</span>][<span class="number">2</span>]、 a[<span class="number">0</span>][<span class="number">3</span>]。  </span><br></pre></td></tr></table></figure>

<h5 id="C-语言字符数组和字符串"><a href="#C-语言字符数组和字符串" class="headerlink" title="C 语言字符数组和字符串"></a>C 语言字符数组和字符串</h5><h6 id="字符数组的格式"><a href="#字符数组的格式" class="headerlink" title="字符数组的格式"></a>字符数组的格式</h6><p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>]; <span class="comment">//一维字符数组</span></span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>][<span class="number">10</span>]; <span class="comment">//二维字符数组</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">20</span>] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span> &#125;; <span class="comment">// 给部分数组元素赋值</span></span><br><span class="line"><span class="type">char</span> d[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span> &#125;; <span class="comment">//对全体元素赋值时可以省去长度  </span></span><br></pre></td></tr></table></figure>

<p>字符数组实际上是一系列字符的集合，也就是字符串（String） 。在 C 语言中，没有专门的字符串变量，没有 string类型，通常就用一个字符数组来存放一个字符串。  </p>
<p>C 语言规定，可以将字符串直接赋值给字符数组，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = &#123; <span class="string">&quot;c.biancheng.net&quot;</span> &#125;; </span><br><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = <span class="string">&quot;c.biancheng.net&quot;</span>; <span class="comment">//这种形式更加简洁，实际开发中常用</span></span><br></pre></td></tr></table></figure>

<p>数组第 0 个元素为’c’，第 1 个元素为’.’，第 2 个元素为’b’，后面的元素以此类推。</p>
<p>为了方便，你也可以不指定数组长度，从而写作： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123; <span class="string">&quot;c.biancheng.net&quot;</span> &#125;;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;c.biancheng.net&quot;</span>; <span class="comment">//这种形式更加简洁，实际开发中常用  </span></span><br></pre></td></tr></table></figure>

<p>这里需要留意一个坑，字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了。请看下面的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">7</span>];</span><br><span class="line">str = <span class="string">&quot;abc123&quot;</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; str[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; str[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">str[<span class="number">3</span>] = <span class="string">&#x27;1&#x27;</span>; str[<span class="number">4</span>] = <span class="string">&#x27;2&#x27;</span>; str[<span class="number">5</span>] = <span class="string">&#x27;3&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<h6 id="字符串结束标志"><a href="#字符串结束标志" class="headerlink" title="字符串结束标志"></a>字符串结束标志</h6><p>在 C 语言中，字符串总是以’\0’作为结尾，所以’\0’也被称为字符串结束标志，或者字符串结束符。  </p>
<p>由” “包围的字符串会自动在末尾添加’\0’。 例如， “abc123”从表面看起来只包含了 6 个字符，其实不然， C 语言会在最后隐式地添加一个’\0’。</p>
<p>比如”C program”在内存中的存储情形：  </p>
<img src="/2023/07/09/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/image-20230710153027537.png" class="" title="image-20230710153027537">

<p>需要注意的是，逐个字符地给数组赋值并不会自动添加’\0’，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;  </span><br></pre></td></tr></table></figure>

<p>数组 str 的长度为 3，而不是 4，因为最后没有’\0’。<br>当用字符数组存储字符串时，要特别注意’\0’，要为’\0’留个位置；这意味着，字符数组的长度至少要比字符串的长度大 1。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">7</span>] = <span class="string">&quot;abc123&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p>“bc123”看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的’\0’。如果将 str 的长度定义为 6，它就无法容纳’\0’了  。</p>
<p>另外，在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的“零”值。 </p>
<h6 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h6><p>字符串长度，就是字符串包含了多少个字符（不包括最后的结束符’\0’）。例如”abc”的长度是 3，而不是 4。  </p>
<p>在 C 语言中，我们使用 string.h 头文件中的 strlen() 函数来求字符串的长度，它的用法为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">length <span class="title function_">strlen</span><span class="params">(strname)</span>;  </span><br></pre></td></tr></table></figure>

<p>strname 是字符串的名字，或者字符数组的名字； length 是使用 strlen() 后得到的字符串长度，是一个整数。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//记得引入该头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line"><span class="type">long</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The lenth of the string is %ld.\n&quot;</span>, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>The lenth of the string is 17.  </p>
<h6 id="补充：字符串的输入"><a href="#补充：字符串的输入" class="headerlink" title="补充：字符串的输入"></a>补充：字符串的输入</h6><p>在 C 语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：<br>     scanf()：通过格式控制符%s 输入字符串。除了字符串， scanf() 还能输入其他类型的数据。<br>    gets()：直接输入字符串，并且只能输入字符串。</p>
<p>但是， scanf() 和 gets() 是有区别的：</p>
<p>​	scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，一般无法读取含有空格的字符串。<br>​	 gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说， gets() 用来读取一整行字符串。  </p>
<p>其实 scanf() 也可以读取带空格的字符串。在C语言基础概念结尾有scanf()函数格式。</p>
<h5 id="拓展：C-语言字符串处理函数"><a href="#拓展：C-语言字符串处理函数" class="headerlink" title="拓展：C 语言字符串处理函数"></a>拓展：C 语言字符串处理函数</h5><p>string.h 是一个专门用来处理字符串的头文件，它包含了很多字符串处理函数，由于篇幅限制，本节仅讲解几个常用的。</p>
<h6 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat()"></a>字符串连接函数 strcat()</h6><p>strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1、 arrayName2 为需要拼接的字符串。<br>strcat() 将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志’\0’。 这意味arrayName1 必须足够长，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）。</p>
<p>strcat() 的返回值为 arrayName1 的地址。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;The URL is &quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">60</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input a URL: &quot;</span>);</span><br><span class="line">gets(str2);</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<p>Input a URL: wearexc.github.io<br>The URL is wearexc.github.io</p>
<h6 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy()"></a>字符串复制函数 strcpy()</h6><p>strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(arrayName1, arrayName2);  </span><br></pre></td></tr></table></figure>

<p>strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志’\0’也一同拷贝。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">50</span>] = <span class="string">&quot;随便什么东西&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">50</span>]=<span class="string">&quot;wearex&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>str1: wearex</p>
<p>另外， strcpy() 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。  </p>
<h6 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp()"></a>字符串比较函数 strcmp()</h6><p>strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1 和 arrayName2 是需要比较的两个字符串。<br>字符本身没有大小之分， strcmp() 以各个字符对应的 ASCII 码值进行比较。 strcmp() 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。<br>返回值：若 arrayName1 和 arrayName2 相同，则返回 0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于 0 的值。  </p>
<p>例如：对4 组字符串进行比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> a[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">        <span class="type">char</span> b[] = <span class="string">&quot;AbCdEf&quot;</span>;</span><br><span class="line">        <span class="type">char</span> c[] = <span class="string">&quot;aacdef&quot;</span>;</span><br><span class="line">        <span class="type">char</span> d[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS b: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS c: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, c));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS d: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>a VS b: 32<br>a VS c: -31<br>a VS d: 0  </p>
<h5 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h5><h6 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h6><p>对数组元素进行排序的方法有很多种，比如冒泡排序、归并排序、选择排序、 插入排序、快速排序等，其中最经典最需要掌握的是「冒泡排序」。  </p>
<p>以从小到大排序为例，冒泡排序的整体思想是这样的：</p>
<p>​	从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。  </p>
<p>第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。</p>
<p>以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。  </p>
<p>整个排序过程就好像气泡不断从水里冒出来，最大的先出来，次大的第二出来，最小的最后出来，所以将这种排序<br>方式称为冒泡排序（Bubble Sort） 。</p>
<p>下面我们以“3 2 4 1”为例对冒泡排序进行说明。</p>
<p>第一轮 排序过程<br>3 2 4 1 （最初）<br>2 3 4 1 （比较 3 和 2，交换）<br>2 3 4 1 （比较 3 和 4，不交换）<br>2 3 1 4 （比较 4 和 1，交换）<br>第一轮结束，最大的数字 4 已经在最后面，因此第二轮排序只需要对前面三个数进行比较。</p>
<p>第二轮 排序过程<br>2 3 1 4 （第一轮排序结果）<br>2 3 1 4 （比较 2 和 3，不交换）<br>2 1 3 4 （比较 3 和 1，交换）<br>第二轮结束，次大的数字 3 已经排在倒数第二个位置，所以第三轮只需要比较前两个元素。</p>
<p>第三轮 排序过程<br>2 1 3 4 （第二轮排序结果）<br>1 2 3 4 （比较 2 和 1，交换）</p>
<p>至此，排序结束  </p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i, j, temp;</span><br><span class="line"><span class="comment">//冒泡排序算法：进行 n-1 轮比较  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">//每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">10</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = nums[j];</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出排序后的数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h6><p>上面的算法是大部分教材中提供的算法，其中有一点是可以优化的：当比较到第 i 轮的时候，如果剩下的元素已经排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。</p>
<p>优化后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i, j, temp, isSorted;</span><br><span class="line"><span class="comment">//优化算法：最多进行 n-1 轮比较</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    isSorted = <span class="number">1</span>; <span class="comment">//假设剩下的元素已经排序好了</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">10</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp = nums[j];</span><br><span class="line">            nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            isSorted = <span class="number">0</span>; <span class="comment">//一旦需要交换数组元素，就说明剩下的元素没有排序好</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) <span class="keyword">break</span>; <span class="comment">//如果没有发生交换，说明剩下的元素已经排序好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言知识点补充</title>
    <url>/2023/07/18/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h5 id="typedef-的用法"><a href="#typedef-的用法" class="headerlink" title="typedef 的用法"></a>typedef 的用法</h5><p>C 语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。<span id="more"></span>例如有一个结构体的名字是 stu，要想定义一个结构体变量就得这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure>

<p>struct 看起来就是多余的，但不写又会报错。如果为 struct stu 起了一个别名 STU，书写起来就简单了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU stu1;</span><br></pre></td></tr></table></figure>

<p>这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。<br>使用关键字 typedef 可以为类型起一个新的别名。 typedef 的用法一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> oldName newName;  </span><br></pre></td></tr></table></figure>

<p>ldName 是类型原来的名字， newName 是类型新的名字。例如  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>INTEGER a, b;等效于 int a, b;。</p>
<p>typedef 还可以给数组、 指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ARRAY20[<span class="number">20</span>]  </span><br></pre></td></tr></table></figure>

<p>表示 ARRAY20 是类型 char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARRAY20 a1, a2, s1, s2;</span><br></pre></td></tr></table></figure>

<p>它等价于：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>]  </span><br></pre></td></tr></table></figure>

<p>为结构体类型定义别名：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; STU;  </span><br></pre></td></tr></table></figure>

<p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU body1,body2;</span><br></pre></td></tr></table></figure>

<p>它等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">body1</span>, <span class="title">body2</span>;</span>  </span><br></pre></td></tr></table></figure>

<p>为指针类型定义别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_ARR)</span>[4];  </span><br></pre></td></tr></table></figure>

<p>表示 PTR_TO_ARR 是类型 int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTR_TO_ARR p1, p2;</span><br></pre></td></tr></table></figure>

<p>按照类似的写法，还可以为函数指针类型定义别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">PTR_TO_FUNC pfunc;  </span><br></pre></td></tr></table></figure>

<h6 id="typedef-和-define-的区别"><a href="#typedef-和-define-的区别" class="headerlink" title="typedef 和 #define 的区别"></a>typedef 和 #define 的区别</h6><p>typedef 在表现上有时候类似于 #define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把 typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。  </p>
<p>(1) 可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERGE int</span></span><br><span class="line"><span class="type">unsigned</span> INTERGE n; <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTERGE;</span><br><span class="line"><span class="type">unsigned</span> INTERGE n; <span class="comment">//错误，不能在 INTERGE 前面添加 unsigned  </span></span><br></pre></td></tr></table></figure>

<p>(2) 在连续定义几个变量的时候， typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_INT int *</span></span><br><span class="line">PTR_INT p1, p2;  </span><br></pre></td></tr></table></figure>

<p>经过宏替换以后，第二行变为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1, p2;  </span><br></pre></td></tr></table></figure>

<p>这使得 p1、 p2 成为不同的类型： p1 是指向 int 类型的指针， p2 是 int 类型。<br>相反，在下面的代码中 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_INT</span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure>

<p>p1、 p2 类型相同，它们都是指向 int 类型的指针。  </p>
<h5 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h5><p>有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用 const 关键字对变量加以限定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNum = <span class="number">100</span>; <span class="comment">//班级的最大人数</span></span><br></pre></td></tr></table></figure>

<p>这样 MaxNum 的值就不能被修改了，任何对 MaxNum 赋值的行为都将引发错误：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MaxNum = <span class="number">90</span>; <span class="comment">//错误，试图向 const 变量写入数据</span></span><br></pre></td></tr></table></figure>

<p>我们经常将 const 变量称为常量（Constant） 。创建常量的格式通常为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> type name = value;</span><br></pre></td></tr></table></figure>

<p>const 和 type 都是用来修饰变量的，它们的位置可以互换，也就是将 type 放在 const 前面：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="type">const</span> name = value;</span><br></pre></td></tr></table></figure>

<p>但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。</p>
<p>由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。一如既往，初始化常量可以使用任意形式的表达式，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">90</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum1 = getNum(); <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum2 = n; <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum3 = <span class="number">80</span>; <span class="comment">//编译时初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, MaxNum1, MaxNum2, MaxNum3); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>100, 90, 80  </p>
<h6 id="const-和指针"><a href="#const-和指针" class="headerlink" title="const 和指针"></a>const 和指针</h6><p>const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。 const 和指针一起使用会有几种不同的顺序，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p1;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p2;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p3;  </span><br></pre></td></tr></table></figure>

<p>在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、 p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。<br>当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p4;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p5;</span><br></pre></td></tr></table></figure>

<p>const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。  </p>
<h6 id="const-和函数形参"><a href="#const-和函数形参" class="headerlink" title="const 和函数形参"></a>const 和函数形参</h6><p>在 C 语言中，单独定义 const 变量没有明显的优势，完全可以使用#define 命令代替。 const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。  </p>
<p>在 C 语言标准库中，有很多函数的形参都被 const 限制了，下面是部分函数的原型：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* command)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;  </span><br></pre></td></tr></table></figure>

<p>我们自己在定义函数时也可以使用 const 对形参加以限制，例如查找字符串中某个字符出现的次数：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strnchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="number">0</span>, len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(str[i] == ch)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n = strnchr(str, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>3<br>根据 strnchr() 的功能可以推断，函数内部要对字符串 str 进行遍历，不应该有修改的动作，用 const 加以限制，不但可以防止由于程序员误操作引起的字符串修改，还可以给用户一个提示，函数不会修改你提供的字符串，请你放心。  </p>
<h6 id="const-和非-const-类型转换"><a href="#const-和非-const-类型转换" class="headerlink" title="const 和非 const 类型转换"></a>const 和非 const 类型转换</h6><p>当一个指针变量 str1 被 const 限制时，并且类似 const char *str1 这种形式，说明指针指向的数据不能被修改；如果将 str1 赋值给另外一个未被 const 修饰的指针变量 str2，就有可能发生危险。因为通过 str1 不能修改数据，</p>
<p>而赋值后通过 str2 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。<br>也就是说， const char *和 char *是不同的类型，不能将 const char *类型的数据赋值给 char *类型的变量。但反过来是可以的，编译器允许将 char *类型的数据赋值给 const char *类型的变量。</p>
<p>这种限制很容易理解， char *指向的数据有读取和写入权限，而 const char *指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。</p>
<p>下面是一个将 const 类型赋值给非 const 类型的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *str)</span>&#123; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str2 = str1;</span><br><span class="line">    func(str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 7、 8 行代码分别通过赋值、传参（传参的本质也是赋值）将 const 类型的数据交给了非 const 类型的变量，编译器不会容忍这种行为，会给出警告，甚至直接报错。  </p>
<h5 id="随机数：-rand-和-srand-函数"><a href="#随机数：-rand-和-srand-函数" class="headerlink" title="随机数： rand()和 srand()函数"></a>随机数： rand()和 srand()函数</h5><p>我们一般使用 &lt;stdlib.h&gt; 头文件中的 rand() 函数来生成随机数，它的用法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>void 表示不需要传递参数。<br>C 语言中还有一个 random() 函数可以获取随机数，但是 random() 不是标准函数，不能在 VC&#x2F;VS 等编译器通过，<br>所以比较少用。</p>
<p>rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。</p>
<p>RAND_MAX 是 &lt;stdlib.h&gt; 头文件中的一个宏，它用来指明 rand() 所能返回的随机数的最大值。 C 语言标准并没有规定 RAND_MAX 的具体数值，只是规定它的值至少为 32767。在实际编程中，我们也不需要知道 RAND_MAX的具体值，把它当做一个很大的数来对待即可。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>41</p>
<h6 id="随机数的本质"><a href="#随机数的本质" class="headerlink" title="随机数的本质"></a>随机数的本质</h6><p>多次运行，我们发现上面的代码产生的随机数都一样。因为， rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布，如下图所示：  </p>
<img src="/2023/07/18/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/image-20230719211647507.png" class="" title="image-20230719211647507">

<p>种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。  </p>
<h6 id="重新播种"><a href="#重新播种" class="headerlink" title="重新播种"></a>重新播种</h6><p>我们可以通过 srand() 函数来重新“播种”，这样种子就会发生改变。 srand() 的用法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure>

<p>它需要一个 unsigned int 类型的参数。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。<br>使用 &lt;time.h&gt; 头文件中的 time() 函数即可得到当前的时间（精确到秒），就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));  </span><br></pre></td></tr></table></figure>

<p>对上面的代码进行修改，生成随机数之前先进行播种：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>多次运行程序，会发现每次生成的随机数都不一样了。但是，这些随机数会有逐渐增大或者逐渐减小的趋势，这是因为我们以时间为种子，时间是逐渐增大的，结合上面的正态分布图，很容易推断出随机数也会逐渐增大或者减小。  </p>
<h6 id="生成一定范围内的随机数"><a href="#生成一定范围内的随机数" class="headerlink" title="生成一定范围内的随机数"></a>生成一定范围内的随机数</h6><p>我们可以利用取模的方法，产生一定范围的随机数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = rand() % <span class="number">10</span>; <span class="comment">//产生 0~9 的随机数，注意 10 会被整除  </span></span><br></pre></td></tr></table></figure>

<p>如果要规定上下限：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = rand() % <span class="number">51</span> + <span class="number">13</span>; <span class="comment">//产生 13~63 的随机数  </span></span><br></pre></td></tr></table></figure>

<p>分析：取模即取余， rand()%51+13 我们可以看成两部分： rand()%51 是产生 0~50 的随机数，后面+13 保证 a 最小只能是 13，最大就是 50+13&#x3D;63。  </p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言结构体</title>
    <url>/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h5 id="结构体的基本概念"><a href="#结构体的基本概念" class="headerlink" title="结构体的基本概念"></a>结构体的基本概念</h5><p>C 语言结构体（Struct）从本质上讲是一种自定义的数据类型，只不过这种数据类型比较复杂，是由 int、 char、 float等基本类型组成的。你可以认为结构体是一种聚合类型。<span id="more"></span>   </p>
<p>结构体的定义形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">结构体所包含的变量或数组</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member） 。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>stu 为结构体名，它包含了 5 个成员，分别是 name、 num、 age、 group、 score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">注意大括号后面的分号;不能少，这是一条完整的语句。</span><br></pre></td></tr></table></figure>

<p>结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。</p>
<p>像 int、 float、 char 等是由 C 语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可<br>以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为复杂数据类型或构造数据类型。  </p>
<h6 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h6><p>既然结构体是一种数据类型，那么就可以用它来定义变量。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span></span><br></pre></td></tr></table></figure>

<p>定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字 struct 不能少。  </p>
<p>也可以在定义结构体的同时定义结构体变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号  </span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;  </span><br></pre></td></tr></table></figure>

<p>将变量放在结构体定义的最后即可。<br>如果只需要 stu1、 stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//没有写 stu</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;  </span><br></pre></td></tr></table></figure>

<p>理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 stu1、 stu2 的内存<br>分布如下图所示，共占用 4+4+4+1+4 &#x3D; 17 个字节。  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230718181836280.png" class="" title="image-20230718181836280">

<p>但是在编译器的具体实现中，各个成员之间可能会存在缝隙，对于 stu1、 stu2，成员变量 group 和 score 之间就存在 3 个字节的空白填充（见下图）。这样算来， stu1、 stu2 其实占用了 17 + 3 &#x3D; 20 个字节  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230718181858187.png" class="" title="image-20230718181858187">

<h6 id="成员的获取和赋值"><a href="#成员的获取和赋值" class="headerlink" title="成员的获取和赋值"></a>成员的获取和赋值</h6><p>结构体使用点号.获取单个成员。获取结构体成员的一般格式为 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">结构体变量名.成员名;  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">        <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">        <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">        <span class="type">char</span> group; <span class="comment">//所在小组  </span></span><br><span class="line">        <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">    &#125; stu1;</span><br><span class="line">    <span class="comment">//给结构体成员赋值</span></span><br><span class="line">    stu1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    stu1.num = <span class="number">12</span>;</span><br><span class="line">    stu1.age = <span class="number">18</span>;</span><br><span class="line">    stu1.group = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    stu1.score = <span class="number">136.5</span>;</span><br><span class="line">    <span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, stu1.name, stu1.num, stu1.age,</span><br><span class="line">    stu1.group, stu1.score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果<br>Tom 的学号是 12，年龄是 18，在 A 组，今年的成绩是 136.5！ </p>
<p> 除了可以对成员进行逐一赋值，也可以在定义时整体赋值，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;;  </span><br></pre></td></tr></table></figure>

<p>不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。</p>
<p>需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储 。</p>
<h5 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h5><p>所谓结构体数组，是指数组中的每个元素都是一个结构体。在实际应用中， C 语言结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。  </p>
<p>定义结构体数组和定义结构体变量的方式类似，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组  </span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[5];</span></span><br></pre></td></tr></table></figure>

<p>表示一个班级有 5 个学生。<br>结构体数组在定义的同时也可以初始化，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[5] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>当对数组中全部元素赋值时，也可不给出数组长度，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>结构体数组的使用也很简单，例如，获取 Wang ming 的成绩：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>[4].<span class="title">score</span>;</span></span><br></pre></td></tr></table></figure>

<p>修改 Li ping 的学习小组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>[0].<span class="title">group</span> =</span> <span class="string">&#x27;B&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<h5 id="结构体指针（指向结构体的指针）"><a href="#结构体指针（指向结构体的指针）" class="headerlink" title="结构体指针（指向结构体的指针）"></a>结构体指针（指向结构体的指针）</h5><p>当一个指针变量指向结构体时，我们就称它为结构体指针。 C 语言结构体指针的定义形式一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *变量名;</span></span><br></pre></td></tr></table></figure>

<p>例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;;</span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu1;  </span><br></pre></td></tr></table></figure>

<p>也可以在定义结构体的同时定义结构体指针：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;, *pstu = &amp;stu1;  </span><br></pre></td></tr></table></figure>

<p>注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表<br>达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp;，所以给 pstu 赋值只能写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu1;</span><br></pre></td></tr></table></figure>

<p>而不能写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> stu1;</span><br></pre></td></tr></table></figure>

<p>还应该注意，结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不会为它分配内存空间，就像 int、 float、 char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。</p>
<p>下面的写法是错误的，不可能去取一个结构体名的地址，也不能将它赋值给其他变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> stu;  </span><br></pre></td></tr></table></figure>

<h6 id="获取结构体成员"><a href="#获取结构体成员" class="headerlink" title="获取结构体成员"></a>获取结构体成员</h6><p>通过结构体指针可以获取结构体成员，一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure>

<p>第一种写法中， .的优先级高于* ， ( * pointer)两边的括号不能少。如果去掉括号写作* pointer.memberName，那么就<br>等效于*(pointer.memberName)，这样意义就完全不对了。<br>第二种写法中，-&gt;是一个新的运算符，有了它，可以通过结构体指针直接取得结构体成员；</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄  </span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;, *pstu = &amp;stu1;</span><br><span class="line"><span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, (*pstu).name, (*pstu).num,(*pstu).age, (*pstu).group, (*pstu).score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age,pstu-&gt;group, pstu-&gt;score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！<br>Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！</p>
<h6 id="结构体指针作为函数参数"><a href="#结构体指针作为函数参数" class="headerlink" title="结构体指针作为函数参数"></a>结构体指针作为函数参数</h6><p>结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编<br>译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运<br>行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。  </p>
<p>【示例】计算全班学生的总成绩、平均成绩和以及 140 分以下的人数。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;stus[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">average</span><span class="params">(<span class="keyword">struct</span> stu *ps, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(stus) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu);</span><br><span class="line">    average(stus, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">average</span><span class="params">(<span class="keyword">struct</span> stu *ps, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, num_140 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> average, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        sum += (ps + i) -&gt; score;  </span><br><span class="line">    <span class="keyword">if</span>((ps + i)-&gt;score &lt; <span class="number">140</span>) num_140++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%.2f\naverage=%.2f\nnum_140=%d\n&quot;</span>, sum, sum/<span class="number">5</span>, num_140);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>sum&#x3D;707.50<br>average&#x3D;141.50<br>num_140&#x3D;2  </p>
<h5 id="枚举类型（enum-关键字）"><a href="#枚举类型（enum-关键字）" class="headerlink" title="枚举类型（enum 关键字）"></a>枚举类型（enum 关键字）</h5><p>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。</p>
<p>以每周七天为例，我们可以使用#define 命令来给每天指定一个名字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mon 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tues 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Wed 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Thurs 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fri 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sun 7</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> Mon: <span class="built_in">puts</span>(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tues: <span class="built_in">puts</span>(<span class="string">&quot;Tuesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Wed: <span class="built_in">puts</span>(<span class="string">&quot;Wednesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Thurs: <span class="built_in">puts</span>(<span class="string">&quot;Thursday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Fri: <span class="built_in">puts</span>(<span class="string">&quot;Friday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sat: <span class="built_in">puts</span>(<span class="string">&quot;Saturday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sun: <span class="built_in">puts</span>(<span class="string">&quot;Sunday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>5↙<br>Friday  </p>
<p>#define 命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。 C 语言提供了一种枚举（Enum）类型，能够列出所有可能的取值，并给它们取一个名字。  </p>
<p>枚举类型的定义形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;  </span><br></pre></td></tr></table></figure>

<p>enum 是一个新的关键字，专门用来定义枚举类型，这也是它在 C 语言中的唯一用途； typeName 是枚举类型的名字； valueName1, valueName2, valueName3, ……是每个值对应的名字的列表。</p>
<p>例如，列出一个星期有几天：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（增）；也就是说， week 中的 Mon、 Tues …… Sun 对应的值分别为 0、 1 …… 6。<br>我们也可以给每个名字都指定一个值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>更为简单的方法是只给第一个名字指定值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>这样枚举值就从 1 开始递增，跟上面的写法是等效的。<br>枚举是一种类型，通过它可以定义枚举变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>

<p>也可以在定义枚举类型的同时定义变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a, b, c;</span><br></pre></td></tr></table></figure>

<p>有了枚举变量，就可以把列表中的值赋给它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br><span class="line">enum week a = Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a = Mon, b = Wed, c = Sat;  </span><br></pre></td></tr></table></figure>

<p>【示例】判断用户输入的是星期几。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;  </span><br><span class="line">    <span class="keyword">case</span> Mon: <span class="built_in">puts</span>(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Tues: <span class="built_in">puts</span>(<span class="string">&quot;Tuesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Wed: <span class="built_in">puts</span>(<span class="string">&quot;Wednesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Thurs: <span class="built_in">puts</span>(<span class="string">&quot;Thursday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fri: <span class="built_in">puts</span>(<span class="string">&quot;Friday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sat: <span class="built_in">puts</span>(<span class="string">&quot;Saturday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sun: <span class="built_in">puts</span>(<span class="string">&quot;Sunday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>4↙<br>Thursday</p>
<p>需要注意的两点是：</p>
<p>(1) 枚举列表中的 Mon、 Tues、 Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。</p>
<p>(2) Mon、 Tues、 Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。</p>
<p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可<br>以将枚举理解为编译阶段的宏。  </p>
<h5 id="共用体（union-关键字）"><a href="#共用体（union-关键字）" class="headerlink" title="共用体（union 关键字）"></a>共用体（union 关键字）</h5><p>共用体（Union）和结构体的语法类似 ，它的定义格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">成员列表</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。</p>
<p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。  </p>
<p>共用体也是一种自定义类型，可以通过它来创建变量，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;  </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125; a, b, c;  </span><br></pre></td></tr></table></figure>

<p>如果不再定义新的变量，也可以将共用体的名字省略：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125; a, b, c;  </span><br></pre></td></tr></table></figure>

<p>共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、 b、 c）也占用 8 个字节的内存，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> data) );</span><br><span class="line">    a.n = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.ch = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.m = <span class="number">0x2059</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>4, 4<br>40, @, 40<br>39, 9, 39<br>2059, Y, 2059<br>3E25AD54, T, AD54</p>
<p>这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。<br>要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的data 为例，各个成员在内存中的分布如下：  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230719001444454.png" class="" title="image-20230719001444454">

<p>成员 n、 ch、 m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对n 赋值修改的是全部字节。也就是说， ch、 m 会影响到 n 的一部分数据，而 n 会影响到 ch、 m 的全部数据。  </p>
<p>上图是在绝大多数 PC 机上的内存分布情况，如果是 51 单片机，情况就会有所不同：  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230719001645782.png" class="" title="image-20230719001645782">

<p>这是和机器的存储模式，大端小端有关。</p>
<h6 id="共用体的应用"><a href="#共用体的应用" class="headerlink" title="共用体的应用"></a>共用体的应用</h6><p>共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：  </p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Num</th>
<th>Sex</th>
<th>Profession</th>
<th>Score &#x2F; Course</th>
</tr>
</thead>
<tbody><tr>
<td>HanXiaoXiao</td>
<td>501</td>
<td>f</td>
<td>s</td>
<td>89.5</td>
</tr>
<tr>
<td>YanWeiMin</td>
<td>1011</td>
<td>m</td>
<td>t</td>
<td>math</td>
</tr>
<tr>
<td>LiuZhenTao</td>
<td>109</td>
<td>f</td>
<td>t</td>
<td>English</td>
</tr>
<tr>
<td>ZhaoFeiYan</td>
<td>982</td>
<td>m</td>
<td>s</td>
<td>95.0</td>
</tr>
</tbody></table>
<p>f 和 m 分别表示女性和男性， s 表示学生， t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。</p>
<p>如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。</p>
<p>经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 4 <span class="comment">//人员总数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> profession;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">        <span class="type">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc;</span><br><span class="line">&#125; bodys[TOTAL];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input info: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %c %c&quot;</span>, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession));</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex,bodys[i].profession, bodys[i].sc.score);  </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex,</span><br><span class="line">bodys[i].profession, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input info: HanXiaoXiao 501 f s 89.5↙<br>Input info: YanWeiMin 1011 m t math↙<br>Input info: LiuZhenTao 109 f t English↙<br>Input info: ZhaoFeiYan 982 m s 95.0↙</p>
<p>Name Num Sex Profession Score &#x2F; Course<br>HanXiaoXiao 501 f s 89.500000<br>YanWeiMin 1011 m t math<br>LiuZhenTao 109 f t English<br>ZhaoFeiYan 982 m s 95.000000  </p>
<h5 id="大端小端以及判别方式"><a href="#大端小端以及判别方式" class="headerlink" title="大端小端以及判别方式"></a>大端小端以及判别方式</h5><p>大端和小端是指数据在内存中的存储模式，它由 CPU 决定：<br>(1) 大端模式（ Big-endian） 是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。</p>
<p>(2) 小端模式（ Little-endian） 是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。  </p>
<h6 id="为什么有大小端模式之分"><a href="#为什么有大小端模式之分" class="headerlink" title="为什么有大小端模式之分"></a>为什么有大小端模式之分</h6><p>计算机中的数据是以字节（ Byte）为单位存储的，每个字节都有不同的地址。现代 CPU 的位数（可以理解为一次能处理的数据的位数）都超过了 8 位（一个字节）， PC 机、服务器的 CPU 基本都是 64 位的，嵌入式系统或单片机系统仍然在使用 32 位和 16 位的 CPU。</p>
<p>对于一次能处理多个字节的 CPU，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以 int 类型的 0x12345678 为例，它占用 4 个字节，如果是小端模式（ Little-endian），那么在内存中的分布情况为（假设从地址 0x 4000 开始存放）：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody><tr>
<td>存放内容</td>
<td>0x78</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>如果是大端模式（ Big-endian），那么分布情况正好相反：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody><tr>
<td>存放内容</td>
<td>0x12</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78</td>
</tr>
</tbody></table>
<p>我们的 PC 机上使用的是 X86 结构的 CPU，它是小端模式； 51 单片机是大端模式；很多 ARM、 DSP 也是小端模式（部分 ARM 处理器还可以由硬件来选择是大端模式还是小端模式）。</p>
<h5 id="位域（位段）"><a href="#位域（位段）" class="headerlink" title="位域（位段）"></a>位域（位段）</h5><p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑， C 语言又提供了一种叫做位域的数据结构。</p>
<p><strong>在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。</strong>  例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> m;</span><br><span class="line">    <span class="type">unsigned</span> n: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ch: <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后面的数字用来限定成员变量占用的位数。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、 ch 被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、 6 位（Bit）的内存。  </p>
<p>C 语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度， :后面的数字不能超过这个长度。  </p>
<p>C 语言标准还规定，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、 signed int 和unsigned int（int 默认就是 signed int）；到了 C99， _Bool 也被支持了。</p>
<h6 id="无名位域"><a href="#无名位域" class="headerlink" title="无名位域"></a>无名位域</h6><p>  位域成员可以没有名称，只给出数据类型和位宽，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> m: <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> : <span class="number">20</span>; <span class="comment">//该位域成员不能使用</span></span><br><span class="line">    <span class="type">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。  </p>
<h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>这个在数字电路和单片机学过，C语言的也一样，仅记录。</p>
<p>C 语言提供了六种位运算符：  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>&amp;</th>
<th>|</th>
<th>^</th>
<th>~</th>
<th>&lt;&lt;</th>
<th>&gt;&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>按位与</td>
<td>按位或</td>
<td>按位异或</td>
<td>取反</td>
<td>左移</td>
<td>右移</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言预处理命令</title>
    <url>/2023/07/11/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h6 id="预处理命令简谈"><a href="#预处理命令简谈" class="headerlink" title="预处理命令简谈"></a>预处理命令简谈</h6><p>使用库函数之前，应该用#include 引入对应的头文件。 这种以#号开<br>头的命令称为预处理命令。  <span id="more"></span></p>
<p>预处理是 C 语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。</p>
<p>编译器会将预处理的结果保存到和源文件同名的.i 文件中，例如 main.c 的预处理结果在 main.i 中。和.c 一样， .i也是文本文件，可以用编辑器打开直接查看内容。</p>
<p>C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。  </p>
<h6 id="include-的用法（文件包含命令）"><a href="#include-的用法（文件包含命令）" class="headerlink" title="#include 的用法（文件包含命令）"></a>#include 的用法（文件包含命令）</h6><p>#include 叫做文件包含命令，用来引入对应的头文件（.h 文件）  </p>
<p>用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdHeader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myHeader.h&quot;</span>  </span></span><br></pre></td></tr></table></figure>

<p>使用尖括号&lt; &gt;和双引号” “的区别在于头文件的搜索路径不同：</p>
<p>​	使用尖括号&lt; &gt;，编译器会到系统路径下查找头文件；</p>
<p>​	而使用双引号” “，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</p>
<p>stdio.h 和 stdlib.h 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。  </p>
<p>例如：</p>
<img src="/2023/07/11/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/image-20230711171446610.png" class="" title="image-20230711171446610">

<p>my.c 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算从m加到n的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>my.h 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>;  </span><br></pre></td></tr></table></figure>

<p>main.c 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>另外，不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。  </p>
<h5 id="宏定义（-define-的用法）"><a href="#宏定义（-define-的用法）" class="headerlink" title="宏定义（#define 的用法）"></a>宏定义（#define 的用法）</h5><p>#define 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">20</span> + N;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>120  </p>
<p>注意第 6 行代码 int sum &#x3D; 20 + N， N 被 100 代替了。</p>
<p>#define N 100 就是宏定义， N 为宏名， 100 是宏的内容（宏所表示的字符串）。在预处理阶段，对程序中所有出现  的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p>
<p>宏定义是由源程序中的宏定义命令#define 完成的，宏替换是由预处理程序完成的。</p>
<p>宏定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></table></figure>

<p>#表示这是一条预处理命令，所有的预处理命令都以 # 开头。 宏名是标识符的一种，命名规则和变量相同。 字符串可以是数字、表达式、 if 语句、函数等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号。</span><br></pre></td></tr></table></figure>

<p>程序中反复使用的表达式就可以使用宏定义，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M (n*n+3*n)</span></span><br></pre></td></tr></table></figure>

<p>它的作用是指定标识符 M 来表示(y<em>y+3</em>y)这个表达式。在编写代码时，所有出现 (y<em>y+3</em>y) 的地方都可以用 M 来表示，而对源程序编译时，将先由预处理程序进行宏代替，即用 (y<em>y+3</em>y) 去替换所有的宏名 M，然后再进行编译。  </p>
<h6 id="对-define-用法的几点说明"><a href="#对-define-用法的几点说明" class="headerlink" title="对 #define 用法的几点说明"></a>对 #define 用法的几点说明</h6><p>(1) 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中<br>可以含任何字符，它可以是常数、表达式、 if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编<br>译已被宏展开后的源程序时发现。<br>(2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。<br>(3) 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef 命令。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>表示 PI 只在 main() 函数中有效，在 func() 中无效。  </p>
<p>(4) 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替，例如 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>OK<br>该例中定义宏名 OK 表示 100，但在 printf 语句中 OK 被引号括起来，因此不作宏替换，而作为字符串处理。  </p>
<p>(5) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S PI*y*y <span class="comment">/* PI 是已定义的宏名*/</span>  </span></span><br></pre></td></tr></table></figure>

<p>对语句：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, S);  </span><br></pre></td></tr></table></figure>

<p>在宏代换后变为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, <span class="number">3.1415926</span>*y*y);  </span><br></pre></td></tr></table></figure>

<p>(6) 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。<br>(7) 可用宏定义表示数据类型，使书写方便。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UINT unsigned int</span></span><br></pre></td></tr></table></figure>

<p>在程序中可用 UINT 作变量说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UINT a, b;</span><br></pre></td></tr></table></figure>

<p>应注意用宏定义表示数据类型和用 typedef 定义数据说明符的区别。 宏定义只是简单的字符串替换，由预处理器来处理；而 typedef 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。<br>请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIN1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *PIN2; <span class="comment">//也可以写作 typedef int (*PIN2);</span></span><br></pre></td></tr></table></figure>

<p>从形式上看这两者相似， 但在实际使用中却不相同。<br>下面用 PIN1， PIN2 说明变量时就可以看出它们的区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIN1 a, b;</span><br></pre></td></tr></table></figure>

<p>在宏代换后变成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a, b;</span><br></pre></td></tr></table></figure>

<p>表示 a 是指向整型的指针变量，而 b 是整型变量。然而：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIN2 a,b;</span><br></pre></td></tr></table></figure>

<p>表示 a、 b 都是指向整型的指针变量。因为 PIN2 是一个新的、完整的数据类型。 由这个例子可见，宏定义虽然也可表示数据类型， 但毕竟只是简单的字符串替换。在使用时要格外小心，以避出错。  </p>
<h5 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h5><p>C 语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。<br>对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。<br>带参宏定义的一般形式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(形参列表) 字符串  </span></span><br></pre></td></tr></table></figure>

<p>在字符串中可以含有各个形参。<br>带参宏调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">宏名(实参列表);  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M(y) y*y+3*y <span class="comment">//宏定义</span></span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">k=M(<span class="number">5</span>); <span class="comment">//宏调用</span></span><br></pre></td></tr></table></figure>

<p>在宏展开时，用实参 5 去代替形参 y，经预处理程序展开后的语句为 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k=<span class="number">5</span>*<span class="number">5</span>+<span class="number">3</span>*<span class="number">5</span>。 </span><br></pre></td></tr></table></figure>

<h6 id="对带参宏定义的说明"><a href="#对带参宏定义的说明" class="headerlink" title="对带参宏定义的说明"></a>对带参宏定义的说明</h6><p>(1) 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。例如把：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b)?a:b</span></span><br></pre></td></tr></table></figure>

<p>写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (a,b) (a&gt;b)?a:b</span></span><br></pre></td></tr></table></figure>

<p>将被认为是无参宏定义，宏名 MAX 代表字符串(a,b) (a&gt;b)?a:b。宏展开时，宏调用语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = MAX(x,y);  </span><br></pre></td></tr></table></figure>

<p>将变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = (a,b)(a&gt;b)?a:b(x,y);</span><br></pre></td></tr></table></figure>

<p>这显然是错误的。  </p>
<p>(2) 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。</p>
<p>这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。  </p>
<p>带参宏定义和函数的区别 ：</p>
<p>带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。  </p>
<h6 id="宏参数的字符串化和宏参数的连接"><a href="#宏参数的字符串化和宏参数的连接" class="headerlink" title="宏参数的字符串化和宏参数的连接"></a>宏参数的字符串化和宏参数的连接</h6><p>在宏定义中，有时还会用到#和##两个符号，它们能够对宏参数进行操作。<br><strong># 的用法</strong><br>#用来将宏参数转换为字符串，也就是在宏参数的开头和末尾添加引号。例如有如下宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) #s</span></span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(c.biancheng.net));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(<span class="string">&quot;c.biancheng.net&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>分别被展开为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;c.biancheng.net&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\&quot;c.biancheng.net\&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现，即使给宏参数“传递”的数据中包含引号，使用#仍然会在两头添加新的引号，而原来的引号会被转义。  </p>
<p><strong>##的用法</strong><br>##称为连接符，用来将宏参数或其他的串连接起来。例如有如下的宏定义：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CON1(a, b) a##e##b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CON2(a, b) a##b##00</span></span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, CON1(<span class="number">8.5</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CON2(<span class="number">12</span>, <span class="number">34</span>));</span><br></pre></td></tr></table></figure>

<p>将被展开为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">8.5e2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123400</span>);  </span><br></pre></td></tr></table></figure>

<h6 id="C-语言中几个预定义宏"><a href="#C-语言中几个预定义宏" class="headerlink" title="C 语言中几个预定义宏"></a>C 语言中几个预定义宏</h6><p>顾名思义，预定义宏就是已经预先定义好的宏，我们可以直接使用，无需再重新定义。<br>ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用：<br>     __LINE__：表示当前源代码的行号；<br>    __FILE__：表示当前源文件的名称；<br>    __DATE__：表示当前的编译日期；<br>    __TIME__：表示当前的编译时间；<br>    __STDC__：当要求程序严格遵循 ANSI C 标准时该标识被赋值为 1；<br>    __cplusplus：当编写 C++程序时该标识符被定义  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Date : %s\n&quot;</span>, __DATE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time : %s\n&quot;</span>, __TIME__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File : %s\n&quot;</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Line : %d\n&quot;</span>, __LINE__);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Date : Jul 12 2023<br>Time : 18:57:36<br>File : C:\Users\90872\Desktop\未命名1.cpp<br>Line : 7</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>简单来说，根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。 条件编译是预处理程序的功能，不是编译器的功能。  </p>
<h6 id="if-的用法"><a href="#if-的用法" class="headerlink" title="#if 的用法"></a>#if 的用法</h6><p>#if 用法的一般格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 整型常量表达式 1</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整型常量表达式 2</span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整型常量表达式 3</span></span><br><span class="line">程序段 <span class="number">3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>它的意思是：如常“表达式 1”的值为真（非 0），就对“程序段 1”进行编译，否则就计算“表达式 2”，结果为真的话就对“程序段 2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>需要注意的是， #if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。  </p>
<p>和 #else 也可以省略，如下所示 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is Windows!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unknown platform!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is Linux!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h6 id="ifdef-的用法"><a href="#ifdef-的用法" class="headerlink" title="#ifdef 的用法"></a>#ifdef 的用法</h6><p>#ifdef 用法的一般格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    程序段 <span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>它的意思是，如果当前的宏已被定义过，则对“程序段 1”进行编译，否则对“程序段 2”进行编译。<br>也可以省略 #else：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<h6 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a>#ifndef 的用法</h6><p>#ifndef 用法的一般格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">	程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段 1”进行编译，否则对“程序段 2”进行编译，这与 #ifdef 的功能正好相反  </p>
<h6 id="三者之间的区别"><a href="#三者之间的区别" class="headerlink" title="三者之间的区别"></a>三者之间的区别</h6><p>最后需要注意的是， #if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。  </p>
<p>#ifdef 可以认为是 #if defined 的缩写  </p>
<h5 id="error-命令，阻止程序编译"><a href="#error-命令，阻止程序编译" class="headerlink" title="#error 命令，阻止程序编译"></a>#error 命令，阻止程序编译</h5><p>#error 指令用于在编译期间产生错误信息，并阻止程序的编译，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> error_message</span></span><br></pre></td></tr></table></figure>

<p>例如，我们的程序针对 Linux 编写，不保证兼容 Windows，那么可以这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> This programme cannot compile at Windows Platform</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>WIN32 是 Windows 下的预定义宏。当用户在 Windows 下编译该程序时，由于定义了 WIN32 这个宏，所以<br>会执行 #error 命令，提示用户发生了编译错误，错误信息是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">This programme cannot compile at Windows Platform</span><br></pre></td></tr></table></figure>

<p>这和发生语法错误的效果是一样的，程序编译失败。</p>
<h5 id="C-语言预处理命令总结"><a href="#C-语言预处理命令总结" class="headerlink" title="C 语言预处理命令总结"></a>C 语言预处理命令总结</h5><p>预处理指令是以#号开头的代码行， # 号必须是该行除了任何空白字符外的第一个字符。 # 后是指令关键字，在关键字和 # 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。  </p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>空指令，无任何效果</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则编译下面代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则编译下面代码</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的#if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个#if……#else 条件编译块</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32归档（上）</title>
    <url>/2023/08/02/STM32%E5%BD%92%E6%A1%A3/</url>
    <content><![CDATA[<p>个人学习笔记，将对知识点进行概述，主要学习请参考B站江科大的视频。或者STM32手册。<span id="more"></span></p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="GPIO简介"><a href="#GPIO简介" class="headerlink" title="GPIO简介"></a>GPIO简介</h2><p>•GPIO（General Purpose Input Output）通用输入输出口</p>
<p>•可配置为8种输入输出模式</p>
<p>•引脚电平：0V~3.3V，部分引脚可容忍5V</p>
<p>•输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</p>
<p>•输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
<h3 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802090509772.png" class="" title="image-20230802090509772">

<p>所有GPIO都挂载在APB2总线上。PA0~PB15为GPIO外设引脚</p>
<p><strong>寄存器</strong>是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，以完成输出电平和读取电平的功能，但只有低16位才有对应端口。</p>
<p><strong>驱动器</strong>负责增大驱动能力。</p>
<h4 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092111160.png" class="" title="image-20230802092111160">

<h2 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092501391.png" class="" title="image-20230802092501391">

<p>推挽输出的高低电平均有较强的驱动能力。</p>
<h3 id="浮空-x2F-上拉-x2F-下拉输入"><a href="#浮空-x2F-上拉-x2F-下拉输入" class="headerlink" title="浮空&#x2F;上拉&#x2F;下拉输入"></a>浮空&#x2F;上拉&#x2F;下拉输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092609813.png" class="" title="image-20230802092609813">

<p>在输入模式下，出入驱动器断开。</p>
<h3 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092744941.png" class="" title="image-20230802092744941">

<p>使用ADC的专用配置。输入和输出驱动器都断开无效，信号从引脚后，直接进入片上外设。</p>
<h3 id="开漏-x2F-推挽输出"><a href="#开漏-x2F-推挽输出" class="headerlink" title="开漏&#x2F;推挽输出"></a>开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093041456.png" class="" title="image-20230802093041456">

<p>一个端口可以有多个输入，但只能有一个输出。通过输出驱动器的MOS管，可以控制输出为推挽或开漏模式。</p>
<h3 id="复用开漏-x2F-推挽输出"><a href="#复用开漏-x2F-推挽输出" class="headerlink" title="复用开漏&#x2F;推挽输出"></a>复用开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093323996.png" class="" title="image-20230802093323996">

<p>输出控制由片上外设控制，输入时，片上外设和输入驱动器都有效。</p>
<h3 id="外设GPIO配置"><a href="#外设GPIO配置" class="headerlink" title="外设GPIO配置"></a>外设GPIO配置</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093547488.png" class="" title="image-20230802093547488">

<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><details>  <summary><font size="4" color="orange">流水灯</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                      // 延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启APB2时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //为结构体命名
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        //设为GPIO为推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;             //所有引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       //输出速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_Write(GPIOA, ~0x0001);	//0000 0000 0000 0001   //一次写入16个端口，控制GPIO
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0002);	//0000 0000 0000 0010
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0004);	//0000 0000 0000 0100
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0008);	//0000 0000 0000 1000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0010);	//0000 0000 0001 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0020);	//0000 0000 0010 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0040);	//0000 0000 0100 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0080);	//0000 0000 1000 0000
        Delay_ms(100);
    &#125;
&#125;
</code> </pre> </details>


<details> 
<summary><font size="4" color="orange">LED闪烁</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                     //延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //结构体，初始化GPIO
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       //推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;              //初始化的引脚为GPIOA的pin0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;      //运行速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_ResetBits(GPIOA, GPIO_Pin_0);             //把pin0置为低电平
        Delay_ms(500);
        GPIO_SetBits(GPIOA, GPIO_Pin_0);               //把pin0置为高电平
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1);
        Delay_ms(500);
    &#125;
&#125;
</code>
</pre> </details>




<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断：　　　　　在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p>
<p>中断优先级：　　当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p>
<p>中断嵌套：　　　当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</p>
<p><strong>中断执行流程</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085322283.png" class="" title="image-20230803085322283">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085339575.png" class="" title="image-20230803085339575">

<p>程序由硬件电路自动跳转到中断程序中</p>
<h3 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a><strong>STM32中断</strong></h3><p>•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p>
<p>•使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。  </p>
<p>内核中断：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804091214547.png" class="" title="image-20230804091214547">

<h3 id="NVIC的基本结构"><a href="#NVIC的基本结构" class="headerlink" title="NVIC的基本结构"></a>NVIC的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140450873.png" class="" title="image-20230804140450873">

<p>一个外设可能占用多个中断通道</p>
<h3 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h3><p>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p>
<p>•抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140815853.png" class="" title="image-20230804140815853">

<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><h3 id="EXTI简介"><a href="#EXTI简介" class="headerlink" title="EXTI简介"></a>EXTI简介</h3><p>•EXTI（Extern Interrupt）外部中断</p>
<p>•EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p>
<p>•支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p>
<p>•支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断。（PA1和PB1不能同时用）</p>
<p>•通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
<p>•触发响应方式：中断响应&#x2F;事件响应</p>
<p>中断响应：让CPU执行中断函数</p>
<p>事件响应：当外部中断检测到引脚变化时，中断信号就不会通向CPU了，而是通到其它外设，用来触发其它外设的操作（ADC,DMA）属于外设之间的联合工作。</p>
<h3 id="EXTI的基本结构"><a href="#EXTI的基本结构" class="headerlink" title="EXTI的基本结构"></a>EXTI的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804141911813.png" class="" title="image-20230804141911813">

<h3 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h3><p>•AFIO主要用于引脚复用功能的选择和重定义</p>
<p>•在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142052238.png" class="" title="image-20230804142052238">

<h3 id="EXTI框图"><a href="#EXTI框图" class="headerlink" title="EXTI框图"></a>EXTI框图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142120741.png" class="" title="image-20230804142120741">

<h3 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>配置过程：</strong></p>
<p>1.　　　　配置RCC,把涉及的外设时钟都打开GPIO,AFIO，（无需：NVIC,EXTI）<br>2.　　　　配置GPIO，选择端口为输入模式<br>3.　　　　配置AFIO，选择所需的GPIO链接EXTI。<br>4.　　　　配置EXTI，选择触发方式和响应方式。（一般为边沿触发，中断响应）<br>5.　　　　配置NVIC，选择合适的优先级。</p>
<p>最后，通过NVIC，外部中断信号进入CPU。</p>
<p><strong>对射式红外传感器计次</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804143658827.png" class="" title="image-20230804143658827">

<p>挡光片在对射式红外传感器中间经过时，D0输出电平跳变，触发PB14号IO口的中断。</p>
<details>  <summary><font size="4" color="orange">代码</font></summary>  <pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
uint16_t CountSensor_Count;
void CountSensor_Init(void)
&#123;
//开启相关时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
//利用结构体配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;                     
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
//选择中断线
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
//利用结构体配置EXTI
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line14;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
//利用结构体配置NVIC
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
&#125;
uint16_t CountSensor_Get(void)
&#123;
    return CountSensor_Count;
&#125;
void EXTI15_10_IRQHandler(void)       //中断函数，函数名不可自定义
&#123;
    if (EXTI_GetITStatus(EXTI_Line14) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
        &#123;
            CountSensor_Count ++;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line14);
    &#125;
&#125;
</code> </pre> </details>
**螺旋编码器计次**

<p>螺旋编码器可用于测量位置，速度或旋转方向，当其旋转轴旋转时，其输出端额可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度与方向。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160531114.png" class="" title="image-20230804160531114">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160614690.png" class="" title="image-20230804160614690">

<p>默认无旋转时，此时上拉为高电平，并输出到A端口，当旋转时内部触电导通，此时因为连接GND，A端口就为低电平。</p>
<p>旋转轴旋转时，此时两触点以相位相差90度的方式交替导通。</p>
<p>示例连接图：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804161013946.png" class="" title="image-20230804161013946">

<details> 
<summary><font size="4" color="orange">主函数</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Encoder.h"
int16_t Num;
int main(void)
&#123;
    OLED_Init();                     //初始化OLED屏幕
    Encoder_Init();
    OLED_ShowString(1, 1, "Num:");   //OLED显示函数
    while (1)
    &#123;
        Num += Encoder_Get();
        OLED_ShowSignedNum(1, 5, Num, 5);
    &#125;
&#125;
</code>
</pre> </details>

<details> 
<summary><font size="4" color="orange">Encoder.c</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
int16_t Encoder_Count;
//初始化，配置相关IO口，中断。
void Encoder_Init(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);
    GP_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    NVIC_Init(&NVIC_InitStructure);
&#125;
//放回count的变化值
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = Encoder_Count;
    Encoder_Count = 0;
    return Temp;
&#125;
//中断程序，执行计数
void EXTI0_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line0) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
            &#123;
                Encoder_Count --;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line0);
    &#125;
&#125;
void EXTI1_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line1) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
            &#123;
                Encoder_Count ++;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line1);
    &#125;
&#125;
</code>
</pre> </details>


<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h2><p>•TIM（Timer）定时器</p>
<p>•定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p>
<p>•16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p>
<p>•不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p>
<p>•根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
<p>应用：利用输出比较功能，可以产生PWM波形，驱动电机。输入捕获功能，可以实现测量方波频率。定时器的编码器接口，也可以更方便的读取正交编码器的输出波形。</p>
<h2 id="定时器类型"><a href="#定时器类型" class="headerlink" title="定时器类型"></a>定时器类型</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230805151849133.png" class="" title="image-20230805151849133">

<p>高级定时器可用于三相无刷电机。</p>
<p>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4。</p>
<h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813094959667.png" class="" title="image-20230813094959667">

<p>基本定时器一般是连接到内部时钟（72MHz），经过预分频器进行分频。比如：预分频器写0就是不分频或者（1分频），输出频率&#x3D;输入频率&#x3D;72M，写1就是二分频，输出&#x3D;输入&#x2F;2&#x3D;36M，以此类推。这个预分频器是16位，最大值可填65535，也就是65536分频。分频后计数器（16位）会不断自增，通过自动重装寄存器（16位）可以控制计数时间。当计数&#x3D;自动重装值，计数清零，输出中断。</p>
<p><strong>主从模式触发ADC</strong>  </p>
<p>能让内部的硬件在不受程序的控制下实现自动运行。</p>
<h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100353705.png" class="" title="image-20230813100353705">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100243577.png" class="" title="image-20230813100243577">

<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100827977.png" class="" title="image-20230813100827977">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100920081.png" class="" title="image-20230813100920081">

<h2 id="定时器结构详解"><a href="#定时器结构详解" class="headerlink" title="定时器结构详解"></a>定时器结构详解</h2><h3 id="定时中断基本结构图"><a href="#定时中断基本结构图" class="headerlink" title="定时中断基本结构图"></a>定时中断基本结构图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113020376.png" class="" title="image-20230813113020376">

<h3 id="预分频器时序"><a href="#预分频器时序" class="headerlink" title="预分频器时序"></a>预分频器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113501182.png" class="" title="image-20230813113501182">

<p>•计数器计数频率：CK_CNT &#x3D; CK_PSC &#x2F; (PSC + 1)</p>
<h3 id="计数器时序"><a href="#计数器时序" class="headerlink" title="计数器时序"></a>计数器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813121832130.png" class="" title="image-20230813121832130">

<p>•计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)&#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p>
<h4 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h4> <img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122009533.png" class="" title="image-20230813122009533">

<h4 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122038841.png" class="" title="image-20230813122038841">

<p>如果引入影子寄存器，当自动加载寄存器的值更改后，当前计数周期结束后，才会更改自动加载寄存器的值。实际上为了同步，让值的变化和事件的更新同步发生，防止运行途中由于更改所造成的错误。</p>
<p>比如：原本计时50秒，闹钟响起。计时到45秒时，改为计时到30秒响起闹钟。那么则是45-&gt;60-&gt;0-&gt;30，闹钟才会想起。引入影子寄存器后，则是45-&gt;50，响起闹钟，下一个周期：0-&gt;30再响起一次闹钟。</p>
<h3 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h3><p>STM32用来产生和配置时钟.并吧配置好的时钟发送到各个外设系统。SystemInit就是用来配置时钟树的。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813124428753.png" class="" title="image-20230813124428753">

<p>左边是产生时钟电路，右边则是分配电路。两个高速时钟是为系统提供时钟的。一般外部晶振比内部稳定，所以一般使用外部晶振。</p>
<p>SystemInit配置时钟过程：先开启内部8Mhz晶振作为系统时钟，再开启外部时钟（一般为8M），经过倍频且稳定后变为72M，再代替原来内部的8M作为系统时钟。所以，如果外部时钟出了问题，则切换为内部时钟。8M和72M相比，大概慢了10倍。</p>
<h3 id="示例程序-2"><a href="#示例程序-2" class="headerlink" title="示例程序"></a>示例程序</h3><h4 id="配置过程（内部时钟为例）："><a href="#配置过程（内部时钟为例）：" class="headerlink" title="配置过程（内部时钟为例）："></a>配置过程（内部时钟为例）：</h4><p>1.　　RCC开启时钟，此时基准时钟和整个外设的工作时钟都被打开。</p>
<p>2.　　选择时基单元的时钟源（内部时钟模式）</p>
<p>3.　　配置时基单元<br>4.　　配置输出中断控制，允许更新中断输出到NVIC<br>5.　　配置NVIC，打开中断通道，并分配优先级</p>
<h4 id="定时器中断（内部时钟）："><a href="#定时器中断（内部时钟）：" class="headerlink" title="定时器中断（内部时钟）："></a>定时器中断（内部时钟）：</h4>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
uint16_t Num; 
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init(); 
//
    OLED_ShowString(1, 1, "Num:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5); // 在OLED屏幕上显示变量Num的值，位于第1行第5列，总宽度为5个字符
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32库的头文件
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 				// 启用TIM2的时钟
    TIM_InternalClockConfig(TIM2); 										// 配置TIM2的时钟源为内部时钟
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;                 //结构体
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		// 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 	// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; 					// ARR自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; 				// PSC预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; 				//重复计数器的值（只有高级定时器才有）
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 				// 初始化TIM2的时间基准单元
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 								// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 							// 启用TIM2的更新中断
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 					// 配置NVIC的优先级分组为组2
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;						// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 					// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 			// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 					// 配置子优先级为1
    NVIC_Init(&NVIC_InitStructure); 									// 初始化NVIC
    TIM_Cmd(TIM2, ENABLE); 												// 启用TIM2定时器
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);         // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
        void Timer_Init(void);
//
#endif
</code> </pre> </details>

<h4 id="定时器外部时钟"><a href="#定时器外部时钟" class="headerlink" title="定时器外部时钟"></a>定时器外部时钟</h4>

<p>使用对射式红外传感器来模拟外部时钟。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
//
uint16_t Num; 
//
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init();
    OLED_ShowString(1, 1, "Num:"); 
    OLED_ShowString(2, 1, "CNT:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5);
        OLED_ShowNum(2, 5, Timer_GetCounter(), 5);
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);       // 启用TIM2的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);     // 启用GPIOA的时钟
//
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;			 // 配置GPIOA的引脚模式为上拉输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 				// 配置GPIOA的引脚为引脚0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 		// 配置GPIOA的引脚速度为50MHz
    GPIO_Init(GPIOA, &GPIO_InitStructure); 					// 初始化GPIOA
// 配置TIM2的外部时钟源模式
    TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x0F); 
//结构体配置
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;				 // 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 		// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10-1; 		// 自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1-1; 		// 预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 	// 初始化TIM2的时间基准单元
//
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 		// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 	// 启用TIM2的更新中断
//
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 配置NVIC的优先级分组为组2
//
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 				// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 				// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 		// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 				// 配置响应优先级为1
    NVIC_Init(&NVIC_InitStructure); 								// 初始化NVIC
//
    TIM_Cmd(TIM2, ENABLE);											 // 使能TIM2定时器
&#125;
//
uint16_t Timer_GetCounter(void)
&#123;
    return TIM_GetCounter(TIM2); // 获取TIM2计数器的当前值
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
void Timer_Init(void);
uint16_t Timer_GetCounter(void);
//
#endif
</code> </pre> </details>


<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>•　PWM（Pulse Width Modulation）脉冲宽度调制</p>
<p>•　在具有<strong>惯性</strong>的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</p>
<p>•　PWM参数：</p>
<p>   频率 &#x3D; 1 &#x2F; TS      占空比 &#x3D; TON &#x2F; TS      分辨率 &#x3D; 占空比变化步距</p>
<p>简单说，Ts代表一个高低电平变换周期的时间，占空比决定PWM等效出来的模拟电压的大小，分辨率则可以理解为变化的精细，比如：1% → 2%，分辨率为1%。1.1% → 1.2%，分辨率为0.1%</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906144618584.png" class="" title="image-20230906144618584"><img src="STM32%E5%BD%92%E6%A1%A3/image-20230906144635542.png" alt="image-20230906144635542" style="zoom:80%;" />



<p>PWM需要用到输出比较，所以先介绍一下stm32的输出比较功能。</p>
<h2 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h2><p>•　OC（Output Compare）输出比较</p>
<p>•　IC（Input Capture） 输入捕获</p>
<p>•　CC（Capture&#x2F;Compare）输出比较和输入捕获</p>
<p>•　输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<p>•　每个高级定时器和通用定时器都拥有4个输出比较通道</p>
<p>•　高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p>
<h3 id="输出比较通道-高级"><a href="#输出比较通道-高级" class="headerlink" title="输出比较通道(高级)"></a>输出比较通道(高级)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906150101596.png" class="" title="image-20230906150101596">

<h3 id="输出比较通道-通用"><a href="#输出比较通道-通用" class="headerlink" title="输出比较通道(通用)"></a>输出比较通道(通用)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906161718832.png" class="" title="image-20230906161718832">

<p>比较CNT（计数器）和CCR（捕获比较寄存器）的值，会改变oc1ref（ref：参考信号）的输出电平。（信号可映射至主模式控制器。）输出经过极性选择（是否翻转电平，0为不翻转），最后输出。</p>
<h2 id="输出比较模式"><a href="#输出比较模式" class="headerlink" title="输出比较模式"></a>输出比较模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906162701392.png" class="" title="image-20230906162701392">



<h2 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906163019452.png" class="" title="image-20230906163019452">

<p>参数计算：</p>
<p>•　PWM频率：　　Freq &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)　　　</p>
<p>•　PWM占空比：　Duty &#x3D; CCR &#x2F; (ARR + 1)</p>
<p>•　PWM分辨率：　Reso &#x3D; 1 &#x2F; (ARR + 1)</p>
<h2 id="示例程序-3"><a href="#示例程序-3" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="配置PWM初始化程序的一般步骤"><a href="#配置PWM初始化程序的一般步骤" class="headerlink" title="配置PWM初始化程序的一般步骤"></a>配置PWM初始化程序的一般步骤</h3><p>1.　开启TIM外设和GPIO外设的时钟。<br>2.　配置时基单元。<br>3.　配置输出比较单元。CCR的值，输出比较模式，极性选择，输出使能<br>4.　配置GPIO，PWM对应的GPIO，配置为复用推挽输出<br>5.　运行控制</p>
<h3 id="PWM驱动LED呼吸灯"><a href="#PWM驱动LED呼吸灯" class="headerlink" title="PWM驱动LED呼吸灯"></a>PWM驱动LED呼吸灯</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"     
#include "OLED.h"      
#include "PWM.h"       
//
uint8_t i; 
//
int main(void)
&#123;
    OLED_Init(); 
    PWM_Init();  
//
    while (1)
    &#123;
        // 增加PWM占空比从0到100，使亮度逐渐增大
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(i); // 设置PWM通道1的占空比
            Delay_ms(10);       
        &#125;
        // 降低PWM占空比从100到0，使亮度逐渐减少
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(100 - i); // 设置PWM通道1的占空比
            Delay_ms(10);             
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
void PWM_Init(void)
&#123;
// 启用TIM2时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置TIM2通道1的GPIO引脚
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;     // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM2为内部时钟
    TIM_InternalClockConfig(TIM2);
// 配置TIM2的时基
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;  // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
// 配置TIM2通道1为PWM输出
    TIM_OCInitTypeDef TIM_OCInitStructure;
    TIM_OCStructInit(&TIM_OCInitStructure);
    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStructure.TIM_Pulse = 0; // CCR
    TIM_OC1Init(TIM2, &TIM_OCInitStructure);
// 启用TIM2
    TIM_Cmd(TIM2, ENABLE);
&#125;
void PWM_SetCompare1(uint16_t Compare)
&#123;
    // 设置TIM2通道1的比较值
    TIM_SetCompare1(TIM2, Compare);
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.h</font></summary>  <pre><code class="language-c">
#ifndef __PWM_H
#define __PWM_H
//
void PWM_Init(void);
void PWM_SetCompare1(uint16_t Compare);
//
#endif
</code> </pre> </details>

<h3 id="PWM驱动舵机"><a href="#PWM驱动舵机" class="headerlink" title="PWM驱动舵机"></a>PWM驱动舵机</h3>

<p>•　舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p>
<p>•　输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms　　　　　　<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907132353584.png" class="" title="image-20230907132353584"></p>
<p>　　　</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"  //延时
#include "OLED.h"   
#include "Servo.h"
#include "Key.h"    //按键
// 全局变量声明
uint8_t KeyNum;
float Angle;
int main(void)
&#123;
    // 初始化OLED显示屏、舵机和按键
    OLED_Init();
    Servo_Init();
    Key_Init();
    OLED_ShowString(1, 1, "Angle:");
    while (1)
    &#123;
        // 获取按键状态
        KeyNum = Key_GetNum();
        // 如果按键被按下
        if (KeyNum == 1)
        &#123;
            Angle += 30;     // 增加角度值
            if (Angle > 180)
            &#123;
                Angle = 0;   // 限制在0到180度之间
            &#125;
        &#125;
        // 设置舵机的角度
        Servo_SetAngle(Angle);
        // 在OLED上显示当前角度
        OLED_ShowNum(1, 7, Angle, 3);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Servo.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
//初始化，和示例一的PWM初始化一致
void Servo_Init(void)
&#123;
    PWM_Init();
&#125;
//设置PWM脉冲宽度，并且与角度用公式转换，便于写入和理解
void Servo_SetAngle(float Angle)
&#123;
    PWM_SetCompare2(Angle / 180 * 2000 + 500);
&#125;
</code> </pre> </details>

<h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><h2 id="输入捕获简介"><a href="#输入捕获简介" class="headerlink" title="输入捕获简介"></a>输入捕获简介</h2><p>•　IC（Input Capture）输入捕获</p>
<p>•　输入捕获模式下，当通道输入引脚出现指定电平跳变时，<strong>当前CNT的值将被锁存到CCR中</strong>，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p>
<p>•　每个高级定时器和通用定时器都拥有4个输入捕获通道</p>
<p>•　可配置为PWMI模式，同时测量频率和占空比</p>
<p>•　<strong>可配合主从触发模式，实现硬件全自动测量</strong></p>
<h2 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135103458.png" class="" title="image-20230907135103458">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135147731.png" class="" title="image-20230907135147731">

<h2 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135338333.png" class="" title="image-20230907135338333">

<p>滤波器控制滤波参数，边沿检测器可以捕获信号的上升沿，如果将信号映射至从模式控制器，则可以再捕获之后自动完成CNT的清零工作。</p>
<h2 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907140812970.png" class="" title="image-20230907140812970">

<p>将定时器的内部信号，映射到TRGO引脚，用于触发其它的外设。选择从模式的触发信号源后，可选择从模式控制自身定时器运行。</p>
<h2 id="输入捕获基本结构"><a href="#输入捕获基本结构" class="headerlink" title="输入捕获基本结构"></a>输入捕获基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907143237498.png" class="" title="image-20230907143237498">

<p>只用了一个通道，所以只能测频率</p>
<h2 id="PWMI基本结构"><a href="#PWMI基本结构" class="headerlink" title="PWMI基本结构"></a>PWMI基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907162801097.png" class="" title="image-20230907162801097">

<p>使用2个通道同时捕获一个引脚，CRR1为一整个周期的计数值，CRR2是高电气期间的计数值。则占空比&#x3D;CCR2&#x2F;CCR1</p>
<h2 id="示例程序-4"><a href="#示例程序-4" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般配置步骤"><a href="#一般配置步骤" class="headerlink" title="一般配置步骤"></a>一般配置步骤</h3><p>1.使用RCC开启TIM和GPIO的时钟。</p>
<p>2.初始化GPIO，配置为输入模式，一般为上拉&#x2F;浮空输入</p>
<p>3.配置时基单元，使CNT计数器在内部时钟的驱动下自增运行</p>
<p>4.配置输入捕获单元（包括滤波器，极性选择，直连通道）</p>
<p>5.选择从模式的触发源，选择TI1FP1。</p>
<p>6.选择从模式的触发动作（Reset，自动清零CNT）</p>
<p>7.调用TIM_cmd()启动定时器计数。</p>
<h3 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h3>



<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 自定义头文件，相关程序参考文章前置相关
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
//
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
    OLED_ShowString(1, 1, "Freq:00000Hz");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO，为上拉输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>

<h3 id="PWMI模式测频率占空比"><a href="#PWMI模式测频率占空比" class="headerlink" title="PWMI模式测频率占空比"></a>PWMI模式测频率占空比</h3>

<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率和占空比。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//自定义头文件
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
// OLED显示信息
    OLED_ShowString(1, 1, "Freq:00000Hz");
    OLED_ShowString(2, 1, "Duty:00%");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率和占空比，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5); // 显示频率
        OLED_ShowNum(2, 6, IC_GetDuty(), 2); // 显示占空比
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32标准库头文件
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO为上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_PWMIConfig(TIM3, &TIM_ICInitStructure); //该函数只需传入一个参数，会自动把剩下的通道初始化为相反的配置，仅适用于通道1和通道2
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3计数器
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
// 获取输入捕获模块测得的占空比
uint32_t IC_GetDuty(void)
&#123;
    return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>


<h2 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h2><h3 id="编码器接口简介"><a href="#编码器接口简介" class="headerlink" title="编码器接口简介"></a>编码器接口简介</h3><p>•Encoder Interface 编码器接口</p>
<p>•编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>•每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>•两个输入引脚借用了输入捕获的通道1和通道2（CH1和CH2引脚）</p>
<h3 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h3><p>正交编码器可以输出两个相位相差90°的方波信号。接入stm32，可看成一个带有方向控制的外部时钟。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908100020216.png" class="" title="image-20230908100020216">

<p>使用正交信号精度更高，相当于AB相都参与计次，提高计次频率的同时，也可以抗干扰。</p>
<h3 id="编码器接口基本结构"><a href="#编码器接口基本结构" class="headerlink" title="编码器接口基本结构"></a>编码器接口基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105311721.png" class="" title="image-20230908105311721">

<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105519483.png" class="" title="image-20230908105519483">

<p><strong>实例（均不反相）</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105542093.png" class="" title="image-20230908105542093">

<p><strong>实例（TI1反相）</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908211901582.png" class="" title="image-20230908211901582">

<p>如果接入编码器后，需要调整数据加减的方向，可直接调用极性选择。</p>
<h3 id="示例程序-5"><a href="#示例程序-5" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>编码器测速</strong></p>


<p>选择上拉输入或下拉输入时，应参考外部模块的默认输出电平，保持一致。防止电平冲突。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"       
#include "Delay.h"             
#include "OLED.h"              
#include "Timer.h"             
#include "Encoder.h"           
//
int16_t Speed;                  
//
int main(void)
&#123;
//初始化
    OLED_Init();               
    Timer_Init();              
    Encoder_Init();            
    OLED_ShowString(1, 1, "Speed:");
    while (1)
    &#123;
        Speed = Encoder_Get();  						 	// 获取编码器的值并存储在Speed变量中
        OLED_ShowSignedNum(1, 7, Speed, 5);   // 在OLED上显示Speed的值
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Speed = Encoder_Get();                            // 获取编码器的值并存储在Speed变量中
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);       // 清除定时器2更新中断标志位
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Encoder.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  // 包含STM32标准库的头文件
void Encoder_Init(void)
&#123;
//开启时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
// 配置GPIO引脚模式、速度、和上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3定时器为编码器模式
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3的输入捕获通道1和通道2
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICStructInit(&TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置编码器接口
    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
// 启动TIM3定时器
    TIM_Cmd(TIM3, ENABLE);  
&#125;
//
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = TIM_GetCounter(TIM3);  // 获取TIM3计数器的值
    TIM_SetCounter(TIM3, 0);     // 清零TIM3计数器的值
    return Temp;                  // 返回获取到的值
&#125;
</code> </pre> </details>


<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>•　ADC（Analog-Digital Converter）模拟 - 数字转换器</p>
<p>　DAC则是数字 - 模拟转换器，一般可用PWM平替DAC输出电机所需电压。DAC则可用于波形生成。</p>
<p>•　ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>•　12位逐次逼近型ADC，1us转换时间</p>
<p>•　输入电压范围：0～3.3V，转换结果范围：0～4095</p>
<p>•　18个输入通道，可测量16个外部和2个内部信号源</p>
<p>•　规则组（常规使用）和注入组（突发事件）两个转换单元</p>
<p>•　模拟看门狗自动监测输入电压范围</p>
<p>•　STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<h2 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909134000653.png" class="" title="image-20230909134000653">

<p>首先在通道选择开关选择一路输入（利用地址锁存和译码选择），再通过比较器进行比较，根据比较结果，改变DAC的值，直到和输入电压近似相等，则DAC的值为相应的数字变量。REF为参考电压。比较时通常用二分法，逐次逼近。</p>
<h2 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141006160.png" class="" title="image-20230909141006160">

<h2 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909140814309.png" class="" title="image-20230909140814309">

<p>触发控制可选择软件触发或者硬件触发。</p>
<h2 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141225078.png" class="" title="image-20230909141225078">

<h2 id="规则组的四种转换模式"><a href="#规则组的四种转换模式" class="headerlink" title="规则组的四种转换模式"></a>规则组的四种转换模式</h2><h3 id="单次转换，非扫描模式"><a href="#单次转换，非扫描模式" class="headerlink" title="单次转换，非扫描模式"></a>单次转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141515783.png" class="" title="image-20230909141515783">

<p>将需要转换的通道2写入序列1，触发转换即可，完成后将数据放入寄存器，同时将EOC（标志位）置1。下次转换将再次实行以上步骤。</p>
<h3 id="连续转换，非扫描模式"><a href="#连续转换，非扫描模式" class="headerlink" title="连续转换，非扫描模式"></a>连续转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145103684.png" class="" title="image-20230909145103684">

<p>与单次转换不同，转换结束后将立即开始下一轮转换。即，触发一次，转换会一直进行下去。</p>
<h3 id="单次转换，扫描模式"><a href="#单次转换，扫描模式" class="headerlink" title="单次转换，扫描模式"></a>单次转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145559280.png" class="" title="image-20230909145559280">

<p>相较于单次转换，非扫描模式，可填入多个通道进行转换。</p>
<h3 id="连续转换，扫描模式"><a href="#连续转换，扫描模式" class="headerlink" title="连续转换，扫描模式"></a>连续转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145836537.png" class="" title="image-20230909145836537">

<h2 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145914699.png" class="" title="image-20230909145914699">

<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150013914.png" class="" title="image-20230909150013914">

<p>一般使用右对齐，可直接得出结果。也可以使用左对齐，然后裁剪数据分辨率。</p>
<h2 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h2><p>•　AD转换的步骤：采样，保持，量化，编码</p>
<p>•　STM32 ADC的总转换时间为：</p>
<p>　 TCONV &#x3D; 采样时间 + 12.5个ADC周期</p>
<p>•　例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期</p>
<p>　 TCONV &#x3D; 1.5 + 12.5 &#x3D; 14个ADC周期 &#x3D; 1μs</p>
<h2 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h2><p>•　ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p>
<p>•　建议在每次上电后执行一次校准</p>
<p>•　启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p>
<h2 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150438360.png" class="" title="image-20230909150438360">

<h2 id="示例程序-6"><a href="#示例程序-6" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>１．开启RCC时钟，ADC,GPIO。</p>
<p>２．配置GPIO为模拟输入。</p>
<p>３．配置多路开关，将所要转换的通道接入规则组。</p>
<p>４．配置ADC转换器</p>
<p>５．调用ADC_cmd()函数使能ADC。</p>
<h3 id="AD单通道"><a href="#AD单通道" class="headerlink" title="AD单通道"></a>AD单通道</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"         
//
uint16_t ADValue;       // 存储AD转换后的数值
float Voltage;          // 存储计算后的电压值
//
int main(void)
&#123;
// 初始化
    OLED_Init();         
    AD_Init();         
    OLED_ShowString(1, 1, "ADValue:");    
    OLED_ShowString(2, 1, "Volatge:0.00V"); 
    while (1)
    &#123;
        ADValue = AD_GetValue();    // 获取AD转换后的数值
        Voltage = (float)ADValue / 4095 * 3.3; // 计算电压值
        // 在OLED上显示AD值和电压值（带小数点）
        OLED_ShowNum(1, 9, ADValue, 4);
        OLED_ShowNum(2, 9, Voltage, 1);
        // 在OLED上显示电压值的小数部分（两位小数）
        OLED_ShowNum(2, 11, (uint16_t)(Voltage * 100) % 100, 2);
        Delay_ms(100);  // 延时100毫秒
        &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  // 配置引脚为模拟输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;      
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
//利用结构体配置ADC
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                   // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;      // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                      // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                						 // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                      						 // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  // 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); // 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  // 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  // 等待校准完成
&#125;
//转换函数
uint16_t AD_GetValue(void)
&#123;
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);                    // 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);    // 等待转换完成
    return ADC_GetConversionValue(ADC1);                       // 获取ADC转换结果
&#125;
</code> </pre> </details>

<h3 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h3>

<p>采用扫描模式实现多通道，最好配合DMA防止数据覆盖。</p>
<p>本次利用单次转换非扫描模式，只需在每次触发转换之前，手动更改一下列表第一个位置通道即可。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"        
// 存储四个ADC通道的转换值
uint16_t AD0, AD1, AD2, AD3; 
int main(void)
&#123;
// 初始化
    OLED_Init();   
    AD_Init();     
    OLED_ShowString(1, 1, "AD0:"); 
    OLED_ShowString(2, 1, "AD1:"); 
    OLED_ShowString(3, 1, "AD2:"); 
    OLED_ShowString(4, 1, "AD3:"); 
    while (1)
    &#123;
        // 获取ADC通道的转换值
        AD0 = AD_GetValue(ADC_Channel_0); 
        AD1 = AD_GetValue(ADC_Channel_1); 
        AD2 = AD_GetValue(ADC_Channel_2); 
        AD3 = AD_GetValue(ADC_Channel_3); 
     // 在OLED上显示
        OLED_ShowNum(1, 5, AD0, 4);
        OLED_ShowNum(2, 5, AD1, 4);
        OLED_ShowNum(3, 5, AD2, 4);
        OLED_ShowNum(4, 5, AD3, 4);
     // 延时100毫秒
        Delay_ms(100); 
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO引脚为模拟输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间等参数
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                  // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;    // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                    // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                         // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                               // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  													// 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); 	// 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  													// 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  			// 等待校准完成
&#125;
//
uint16_t AD_GetValue(uint8_t ADC_Channel)
&#123;
    ADC_RegularChannelConfig(ADC1, ADC_Channel, 1, ADC_SampleTime_55Cycles5);	// 配置ADC
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);  									// 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); 					// 等待转换完成
    return ADC_GetConversionValue(ADC1);  										// 获取ADC转换结果
&#125;
</code> </pre> </details>


<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><p>•　DMA（Direct Memory Access）直接存储器存取</p>
<p>•　DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源（可直接访问32内部存储器，包括内存SRAM，Flash）</p>
<p>•　12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）</p>
<p>•　每个通道都支持软件触发和特定的硬件触发</p>
<p>•　STM32F103C8T6 DMA资源：DMA1（7个通道）</p>
<h2 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212035982.png" class="" title="image-20230913212035982">

<h2 id="DMA框图"><a href="#DMA框图" class="headerlink" title="DMA框图"></a>DMA框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212111665.png" class="" title="image-20230913212111665">

<h2 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212244338.png" class="" title="image-20230913212244338">

<p>DMA无法进行SRAM到Flash，Flash到Flash操作。M2M用于选择硬件触发或软件触发，EN位为DMA的开关控制。</p>
<h2 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913212521710.png" class="" title="image-20230913212521710">

<p>使用硬件触发需选择专门的通道，选择软件触发则可任意选择。</p>
<h2 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213052577.png" class="" title="image-20230913213052577">

<p>源端宽度&#x3D;目标宽度，数据正常传输。</p>
<p>源端宽度＜目标宽度，目标前面空位补零。</p>
<p>源端宽度＞目标宽度，舍弃源端高位。</p>
<h2 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213356192.png" class="" title="image-20230913213356192">

<p>将DataA转运到DataB，外设地址给DataA数组地址，存储器地址给DataB的首地址，宽度都为8位传输，且两地址都自增，传输计数器赋值为7，无需自动重装，使用软件触发，调用DMA_cmd();</p>
<h2 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230913213909958.png" class="" title="image-20230913213909958">

<h2 id="示例程序-7"><a href="#示例程序-7" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="DMA数据转运"><a href="#DMA数据转运" class="headerlink" title="DMA数据转运"></a>DMA数据转运</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"     // 包含STM32标准库的头文件
#include "Delay.h"         // 包含自定义延时函数的头文件
#include "OLED.h"          // 包含OLED显示屏的头文件
#include "MyDMA.h"         // 包含自定义DMA初始化和传输函数的头文件
// 定义两个数组，DataA和DataB，分别用于存储数据
uint8_t DataA[] = &#123;0x01, 0x02, 0x03, 0x04&#125;;
uint8_t DataB[] = &#123;0, 0, 0, 0&#125;;
int main(void)
&#123;
// 初始化OLED显示屏
    OLED_Init();
// 使用自定义的DMA初始化函数初始化DMA，并配置数据源和目标地址
    MyDMA_Init((uint32_t)DataA, (uint32_t)DataB, 4);
// 在OLED上显示文本和数据的初始状态
    OLED_ShowString(1, 1, "DataA");
    OLED_ShowString(3, 1, "DataB");
    OLED_ShowHexNum(1, 8, (uint32_t)DataA, 8);
    OLED_ShowHexNum(3, 8, (uint32_t)DataB, 8);
    while (1)
    &#123;
// 修改DataA数组的值
        DataA[0]++;
        DataA[1]++;
        DataA[2]++;
        DataA[3]++;
// 在OLED上显示DataA和DataB的各个元素的值
        OLED_ShowHexNum(2, 1, DataA[0], 2);
        OLED_ShowHexNum(2, 4, DataA[1], 2);
        OLED_ShowHexNum(2, 7, DataA[2], 2);
        OLED_ShowHexNum(2, 10, DataA[3], 2);
        OLED_ShowHexNum(4, 1, DataB[0], 2);
        OLED_ShowHexNum(4, 4, DataB[1], 2);
        OLED_ShowHexNum(4, 7, DataB[2], 2);
        OLED_ShowHexNum(4, 10, DataB[3], 2);    
// 使用自定义的延时函数延时1秒
        Delay_ms(1000);   
// 使用DMA传输数据
        MyDMA_Transfer();
// 再次在OLED上显示DataA和DataB的各个元素的值
        OLED_ShowHexNum(2, 1, DataA[0], 2);
        OLED_ShowHexNum(2, 4, DataA[1], 2);
        OLED_ShowHexNum(2, 7, DataA[2], 2);
        OLED_ShowHexNum(2, 10, DataA[3], 2);
        OLED_ShowHexNum(4, 1, DataB[0], 2);
        OLED_ShowHexNum(4, 4, DataB[1], 2);
        OLED_ShowHexNum(4, 7, DataB[2], 2);
        OLED_ShowHexNum(4, 10, DataB[3], 2);
// 使用自定义的延时函数延时1秒
        Delay_ms(1000);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MyDMA.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
// 定义一个全局变量，用于存储DMA传输的数据大小
uint16_t MyDMA_Size; 
// DMA初始化函数，用于配置DMA通道
void MyDMA_Init(uint32_t AddrA, uint32_t AddrB, uint16_t Size)
&#123;
    MyDMA_Size = Size;                                      // 将传入的数据大小保存到全局变量中
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);     // 启用DMA1时钟
//结构体配置DMA
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;                          // 配置外设基地址
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;    // 配置外设数据大小为字节
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;            // 允许外设地址递增
    DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;                              // 配置内存基地址
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;            // 配置内存数据大小为字节
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                    // 允许内存地址递增
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                         // 数据传输方向：从外设到内存
    DMA_InitStructure.DMA_BufferSize = Size;                                   // 配置DMA传输的数据大小
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                              // DMA工作模式为普通模式
    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;                                // 启用内存到内存传输
    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;                      // 配置DMA优先级为中等
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);                               // 使用通道1初始化DMA
// 禁用DMA通道1，等待启动传输
    DMA_Cmd(DMA1_Channel1, DISABLE); 
&#125;
// DMA传输函数，用于启动DMA传输
void MyDMA_Transfer(void)
&#123;
    DMA_Cmd(DMA1_Channel1, DISABLE);                         // 禁用DMA通道1，准备重新配置
    DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);       // 配置当前数据传输计数器的值
    DMA_Cmd(DMA1_Channel1, ENABLE);                          // 启用DMA通道1，开始传输
    while (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);       // 等待传输完成，检查传输完成标志
    DMA_ClearFlag(DMA1_FLAG_TC1);                            // 清除传输完成标志
&#125;
</code> </pre> </details>



<h3 id="DMA-AD多通道"><a href="#DMA-AD多通道" class="headerlink" title="DMA+AD多通道"></a>DMA+AD多通道</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "AD.h"        
#include "OLED.h"      
#include "Delay.h"     
int main(void)
&#123;
// 初始化	
    OLED_Init();     
    AD_Init();       
    OLED_ShowString(1, 1, "AD0:");
    OLED_ShowString(2, 1, "AD1:");
    OLED_ShowString(3, 1, "AD2:");
    OLED_ShowString(4, 1, "AD3:");
    while (1)
    &#123;
// 读取ADC模块的四个通道（AD0、AD1、AD2、AD3）的值，并显示在OLED屏上
        OLED_ShowNum(1, 5, AD_Value[0], 4);
        OLED_ShowNum(2, 5, AD_Value[1], 4);
        OLED_ShowNum(3, 5, AD_Value[2], 4);
        OLED_ShowNum(4, 5, AD_Value[3], 4);
// 延时100毫秒
        Delay_ms(100); 
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 用于存储ADC模块的转换结果
uint16_t AD_Value[4]; 
void AD_Init(void)
&#123;
// 启用ADC1、GPIOA和DMA1的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置ADC通道对应的GPIO引脚为模拟输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC通道和采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);
// 配置ADC工作模式和DMA模式
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
    ADC_InitStructure.ADC_ScanConvMode = ENABLE;
    ADC_InitStructure.ADC_NbrOfChannel = 4;
    ADC_Init(ADC1, &ADC_InitStructure);
// 配置DMA通道，用于传输ADC数据
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)AD_Value;
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_BufferSize = 4;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);
// 启用DMA通道
    DMA_Cmd(DMA1_Channel1, ENABLE);
// 启用ADC的DMA传输
    ADC_DMACmd(ADC1, ENABLE);
// 启用ADC
    ADC_Cmd(ADC1, ENABLE);
// 复位ADC校准
    ADC_ResetCalibration(ADC1);
    while (ADC_GetResetCalibrationStatus(ADC1) == SET);
// 开始ADC校准
    ADC_StartCalibration(ADC1);
    while (ADC_GetCalibrationStatus(ADC1) == SET);
// 启动ADC转换
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
&#125;
</code> </pre> </details>


<h1 id="USART串口"><a href="#USART串口" class="headerlink" title="USART串口"></a>USART串口</h1><h2 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h2><p>•　通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p>
<p>•　通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230923092407230.png" class="" title="image-20230923092407230">

<p><strong>引脚：</strong><br>TX：数据发送引脚</p>
<p>RX：数据接收引脚</p>
<p>SCL：时钟线</p>
<p>SDA：数据线</p>
<p>SCLK：时钟</p>
<p>MOSI：主机输出数据脚</p>
<p>MISO：主机输入数据脚</p>
<p>CS：片选，用于指定通信对象</p>
<p>CAN和USB：表中的双引脚用于表示差分信号。</p>
<p><strong>双工：</strong></p>
<p>全双工：双方可同时互相发送和接受信息。</p>
<p>半双工：任意一方发送的时候，另一方只能接收。</p>
<p>单工：只能一方发送，另一方接收，单向传输。</p>
<p><strong>时钟：</strong></p>
<p>同步：双方通信配有时钟线</p>
<p>异步：自定义时钟</p>
<p>单端：引脚的高低电平为GND的电压差，所以双方需要共地。</p>
<h2 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h2><p>•　简单双向串口通信有两根通信线（发送端TX和接收端RX）</p>
<p>•　TX与RX要交叉连接</p>
<p>•　当只需单向的数据传输时，可以只接一根通信线</p>
<p>•　当电平标准不一致时，需要加电平转换芯片</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926133507630.png" class="" title="image-20230926133507630">

<h2 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h2><p>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p>
<p>•　TTL电平：+3.3V或+5V表示1，0V表示0</p>
<p>•　RS232电平：-3 ~ -15V表示1，+3 ~ +15V表示0</p>
<p>•　RS485电平：两线压差+2 ~ +6V表示1，-2 ~ -6V表示0（差分信号）</p>
<h2 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h2><p>•　波特率：串口通信的速率</p>
<p>•　起始位：标志一个数据帧的开始，固定为低电平</p>
<p>•　数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行</p>
<p>•　校验位：用于数据验证，根据数据位计算得来</p>
<p>•　停止位：用于数据帧间隔，固定为高电平</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134153532.png" class="" title="image-20230926134153532">

<p>右图RB8&#x2F;TB8为奇偶校验位。</p>
<h3 id="串口时序"><a href="#串口时序" class="headerlink" title="串口时序"></a>串口时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926134322264.png" class="" title="image-20230926134322264">

<p>各种情况下，串口发送数据的时序。</p>
<h2 id="USART外设简介"><a href="#USART外设简介" class="headerlink" title="USART外设简介"></a>USART外设简介</h2><p>•　USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器</p>
<p>•　USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p>
<p>•　自带波特率发生器，最高达4.5Mbits&#x2F;s（可理解为分频器）</p>
<p>•　可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2）</p>
<p>•　可选校验位（无校验&#x2F;奇校验&#x2F;偶校验）</p>
<p>•　支持同步模式（CLK时钟输出）、硬件流控制、DMA、智能卡、IrDA、LIN</p>
<p>•　STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p>
<h2 id="USART框图"><a href="#USART框图" class="headerlink" title="USART框图"></a>USART框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20231107103743628.png" class="" title="image-20231107103743628">

<h2 id="USART基本结构"><a href="#USART基本结构" class="headerlink" title="USART基本结构"></a>USART基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210537974.png" class="" title="image-20230926210537974">

<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210641784.png" class="" title="image-20230926210641784">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210653469.png" class="" title="image-20230926210653469">

<h3 id="起始位侦测"><a href="#起始位侦测" class="headerlink" title="起始位侦测"></a>起始位侦测</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210745962.png" class="" title="image-20230926210745962">

<h3 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210802474.png" class="" title="image-20230926210802474">

<h2 id="波特率发生器"><a href="#波特率发生器" class="headerlink" title="波特率发生器"></a>波特率发生器</h2><p>•　发送器和接收器的波特率由波特率寄存器BRR里的DIV确定</p>
<p>•　计算公式：波特率 &#x3D; fPCLK2&#x2F;1 &#x2F; (16 * DIV)</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210847282.png" class="" title="image-20230926210847282">

<h2 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h2><p>•　HEX模式&#x2F;十六进制模式&#x2F;二进制模式：以原始数据的形式显示</p>
<p>•　文本模式&#x2F;字符模式：以原始数据编码后的形式显示</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230926210952604.png" class="" title="image-20230926210952604"><img src="STM32%E5%BD%92%E6%A1%A3/image-20230926211002416.png" alt="image-20230926211002416" style="zoom: 67%;" />

<h2 id="示例程序-8"><a href="#示例程序-8" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="串口发送-x2F-接收数据"><a href="#串口发送-x2F-接收数据" class="headerlink" title="串口发送&#x2F;接收数据"></a>串口发送&#x2F;接收数据</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
//定义接收数据
uint8_t RxData;
int main(void)
&#123;
//初始化数据
    OLED_Init();
    OLED_ShowString(1, 1, "RxData:");
    Serial_Init();
    while (1)
    &#123;
//实现功能为数据互传，当上位机发送数据，从机接收到数据时，将收到的数据回传发送。
        if (Serial_GetRxFlag() == 1)
        &#123;
            RxData = Serial_GetRxData();
            Serial_SendByte(RxData);
            OLED_ShowHexNum(1, 8, RxData, 2);
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include <stdio.h>
#include <stdarg.h>
//定义临时变量
uint8_t Serial_RxData;
uint8_t Serial_RxFlag;
//初始化函数
void Serial_Init(void)
&#123;
//开启GPIO和USART的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//初始化GPIO
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   //复用推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//用于接收
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  //上拉输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;    //配置波特率
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  //不使用硬件流控制
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;  //配置USART为发送和接收模式
    USART_InitStructure.USART_Parity = USART_Parity_No;   //配置校验位，无校验
    USART_InitStructure.USART_StopBits = USART_StopBits_1;   //停止位为1位
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;  //子长为8字节
    USART_Init(USART1, &USART_InitStructure);
//开启USART中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
//用NVIC进行分组
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
//配置中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
//使能USART
    USART_Cmd(USART1, ENABLE);
&#125;
//发送一个字节，调用标准库函数发送字节，并判断标志位等待发送。
void Serial_SendByte(uint8_t Byte)  
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
//发送一个数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
//发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
//求平方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
//发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
//printf调用fputc打印，此函数使fputc为发送到串口。
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
//printf重定向，用于在程序中，调用printf，可打印数据至串口
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
//自定义函数，获取读标志位
uint8_t Serial_GetRxFlag(void)
&#123;
    if (Serial_RxFlag == 1)
    &#123;
        Serial_RxFlag = 0;
        return 1;
    &#125;
    return 0;
&#125;
//自定义函数，获取读标志位
uint8_t Serial_GetRxData(void)
&#123;
    return Serial_RxData;
&#125;
//USART中断，读取接收数据
void USART1_IRQHandler(void)
&#123;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        Serial_RxData = USART_ReceiveData(USART1);
        Serial_RxFlag = 1;
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<p>具体函数功能已有注释，值得一提的是发送数字的功能，除了示例程序中，求数字次方再提取数字（此方法在博客C语言循环结构中的题目《计数问题》有更好的处理）。也可以利用发送字符串的功能。利用C语言函数，可将数字转换为字符串再发送。当然，别忘了引入C语言头文件&lt;stdio.h&gt;。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> VoltageStr[<span class="number">10</span>];  <span class="comment">// 定义一个足够大的字符数组来存储转换后的字符串    </span></span><br><span class="line">Num = <span class="number">1245</span>;    </span><br><span class="line"><span class="built_in">sprintf</span>(VoltageStr, <span class="string">&quot;%d&quot;</span>, Num);  <span class="comment">// 使用sprintf将整数转换为字符串     </span></span><br><span class="line">SendString(VoltageStr);  <span class="comment">// 发送字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p><strong>HEX数据包</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112711694.png" class="" title="image-20230928112711694">

<p><strong>文本数据包</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928112818035.png" class="" title="image-20230928112818035">

<p><strong>HEX数据包接收</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113322761.png" class="" title="image-20230928113322761">

<p><strong>文本数据包接收</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230928113344291.png" class="" title="image-20230928113344291">

<p>在程序设计中，需设计一个能记住不同状态的机制，称为状态机。</p>
<p><strong>示例程序</strong></p>
<p><strong>串口收发HEX数据包</strong></p>


<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "Key.h"
// 用于存储按键的状态
uint8_t KeyNum;  
int main(void)
&#123;
//初始化
    OLED_Init();   
    Key_Init();    
    Serial_Init(); 
    OLED_ShowString(1, 1, "TxPacket"); 
    OLED_ShowString(3, 1, "RxPacket");
// 预设串口发送数据的内容
    Serial_TxPacket[0] = 0x01; 
    Serial_TxPacket[1] = 0x02;
    Serial_TxPacket[2] = 0x03;
    Serial_TxPacket[3] = 0x04;
    while (1)
    &#123;
//获取按键状态
        KeyNum = Key_GetNum(); 
// 如果按键被按下，将递增串口发送数据的内容
        if (KeyNum == 1) 
        &#123;
            Serial_TxPacket[0]++;
            Serial_TxPacket[1]++;
            Serial_TxPacket[2]++;
            Serial_TxPacket[3]++;
// 发送串口数据
            Serial_SendPacket(); 
// 在OLED上显示发送数据的十六进制值
            OLED_ShowHexNum(2, 1, Serial_TxPacket[0], 2);
            OLED_ShowHexNum(2, 4, Serial_TxPacket[1], 2);
            OLED_ShowHexNum(2, 7, Serial_TxPacket[2], 2);
            OLED_ShowHexNum(2, 10, Serial_TxPacket[3], 2);
        &#125;
// 如果收到串口接收标志位
        if (Serial_GetRxFlag() == 1) 
        &#123;
// 在OLED上显示接收到的数据的十六进制值
            OLED_ShowHexNum(4, 1, Serial_RxPacket[0], 2);
            OLED_ShowHexNum(4, 4, Serial_RxPacket[1], 2);
            OLED_ShowHexNum(4, 7, Serial_RxPacket[2], 2);
            OLED_ShowHexNum(4, 10, Serial_RxPacket[3], 2);
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  // 包含STM32的设备头文件
#include <stdio.h>
#include <stdarg.h>
//定义数据
uint8_t Serial_TxPacket[4];  // 用于存储串口发送的数据
uint8_t Serial_RxPacket[4];  // 用于存储串口接收的数据
uint8_t Serial_RxFlag;       // 串口接收标志位
// 初始化串口
void Serial_Init(void)
&#123;
// 使能USART1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//配置GPIO发送端口
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;         // USART1的TX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置GPIO接收端口
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;        // USART1的RX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;         // 波特率设置为9600
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_Init(USART1, &USART_InitStructure);
// 使能USART1的接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);     
// 设置NVIC的优先级分组为组2
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);    
// 配置USART1的中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;  
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
// 使能USART1
    USART_Cmd(USART1, ENABLE);                         
&#125;
// 发送单个字节
void Serial_SendByte(uint8_t Byte)
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
// 发送字节数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
// 发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
// 计算X的Y次方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
// 发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
// 重定向printf函数
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
// 带格式的字符串发送
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
// 发送串口数据包
void Serial_SendPacket(void)
&#123;
    Serial_SendByte(0xFF);                 //数据包包头
    Serial_SendArray(Serial_TxPacket, 4);  //数据包数据
    Serial_SendByte(0xFE);                 //数据包包尾
&#125;
// 获取串口接收标志位
uint8_t Serial_GetRxFlag(void)
&#123;
    if (Serial_RxFlag == 1)
    &#123;
        Serial_RxFlag = 0;
        return 1;
    &#125;
    return 0;
&#125;
// USART1的中断处理函数，内有状态机，处理数据包各种情况
void USART1_IRQHandler(void)
&#123;
    static uint8_t RxState = 0;
    static uint8_t pRxPacket = 0;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        uint8_t RxData = USART_ReceiveData(USART1);
        if (RxState == 0)
        &#123;
            if (RxData == 0xFF)
            &#123;
                RxState = 1;
                pRxPacket = 0;
            &#125;
        &#125;
        else if (RxState == 1)
        &#123;
            Serial_RxPacket[pRxPacket] = RxData;
            pRxPacket ++;
            if (pRxPacket >= 4)
            &#123;
                RxState = 2;
            &#125;
        &#125;
        else if (RxState == 2)
        &#123;
            if (RxData == 0xFE)
            &#123;
                RxState = 0;
                Serial_RxFlag = 1;
            &#125;
        &#125;
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.h</font></summary>  <pre><code class="language-c">
#ifndef __SERIAL_H
#define __SERIAL_H
//
#include <stdio.h>
//定义变量时用extern，可被主函数调用。
extern uint8_t Serial_TxPacket[];
extern uint8_t Serial_RxPacket[];
//
void Serial_Init(void);                                          //初始化
void Serial_SendByte(uint8_t Byte);                              //发送字节
void Serial_SendArray(uint8_t *Array, uint16_t Length);          //发送数组
void Serial_SendString(char *String);                            //发送字符串
void Serial_SendNumber(uint32_t Number, uint8_t Length);         //发送数字
void Serial_Printf(char *format, ...);                           //打印至串口
void Serial_SendPacket(void);                                    //发送数据包
uint8_t Serial_GetRxFlag(void);                                  //获取接收标志位
//
#endif
</code> </pre> </details>

<p>这里引入.h文件是因为定义到Sericl.c的变量，需要在main.c调用。</p>
<p>各函数功能和串口收发数据区别不大，但在中断函数中引入的状态机，先等待包头，收到包头后开启接受数据的函数，并保存至数组。接受完毕后等待包尾，完成一个数据包的传输。</p>
<p>主函数的功能是按下按钮时，将发送以“FF 02 03 04 05 FE”为格式的数据包，按键每按下一次，数据包内的数据将自增1。也可以用同样的格式发送数据包，发送和接受的数据包的数据（不含包头包尾）将在OLED显示。</p>
<p><strong>串口收发文本数据包</strong></p>


<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "LED.h"
#include "string.h"
int main(void)
&#123;
//初始化
    OLED_Init();        
    LED_Init();         
    Serial_Init();      
    OLED_ShowString(1, 1, "TxPacket");
    OLED_ShowString(3, 1, "RxPacket");
    while (1)
    &#123;
        if (Serial_RxFlag == 1)  // 如果收到串口接收标志位
        &#123;
            OLED_ShowString(4, 1, "                ");  // 清除OLED上的数据
            OLED_ShowString(4, 1, Serial_RxPacket);     // 在OLED上显示收到的数据
            if (strcmp(Serial_RxPacket, "LED_ON") == 0)  // 如果收到 "LED_ON" 命令
            &#123;
                LED1_ON();  // 打开LED1
                Serial_SendString("LED_ON_OK\r\n");         // 发送成功消息给串口
                OLED_ShowString(2, 1, "                ");  // 清除OLED上的数据
                OLED_ShowString(2, 1, "LED_ON_OK");         // 在OLED上显示 "LED_ON_OK"
            &#125;
            else if (strcmp(Serial_RxPacket, "LED_OFF") == 0)  // 如果收到 "LED_OFF" 命令
            &#123;
                LED1_OFF();  // 关闭LED1
                Serial_SendString("LED_OFF_OK\r\n");         // 发送成功消息给串口
                OLED_ShowString(2, 1, "                ");   // 清除OLED上的数据
                OLED_ShowString(2, 1, "LED_OFF_OK");         // 在OLED上显示 "LED_OFF_OK"
            &#125;
            else
            &#123;
                Serial_SendString("ERROR_COMMAND\r\n");      // 发送错误消息给串口
                OLED_ShowString(2, 1, "                ");   // 清除OLED上的数据
                OLED_ShowString(2, 1, "ERROR_COMMAND");      // 在OLED上显示 "ERROR_COMMAND"
            &#125;
            Serial_RxFlag = 0;  // 重置串口接收标志位
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include <stdio.h>
#include <stdarg.h>
//
char Serial_RxPacket[100]; // 存储串口接收的数据，最大长度为100
uint8_t Serial_RxFlag;     // 串口接收标志位
// 初始化串口
void Serial_Init(void)
&#123;
// 使能USART1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
//配置GPIO发送端
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;      // USART1的TX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置GPIO接收端
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;     // USART1的RX引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
//配置USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;      // 波特率设置为9600
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_Init(USART1, &USART_InitStructure);
// 使能USART1的接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);  
// 设置NVIC的优先级分组为组2
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 
// 配置USART1的中断
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; 
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
// 使能USART1
    USART_Cmd(USART1, ENABLE);                      
&#125;
// 发送单个字节
void Serial_SendByte(uint8_t Byte)
&#123;
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
&#125;
// 发送字节数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
&#123;
    uint16_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Array[i]);
    &#125;
&#125;
// 发送字符串
void Serial_SendString(char *String)
&#123;
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    &#123;
        Serial_SendByte(String[i]);
    &#125;
&#125;
// 计算X的Y次方
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
&#123;
    uint32_t Result = 1;
    while (Y --)
    &#123;
        Result *= X;
    &#125;
    return Result;
&#125;
// 发送数字
void Serial_SendNumber(uint32_t Number, uint8_t Length)
&#123;
    uint8_t i;
    for (i = 0; i < Length; i ++)
    &#123;
        Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
    &#125;
&#125;
// 重定向printf函数
int fputc(int ch, FILE *f)
&#123;
    Serial_SendByte(ch);
    return ch;
&#125;
// 带格式的字符串发送
void Serial_Printf(char *format, ...)
&#123;
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
&#125;
// USART1的中断处理函数，内有状态机，处理数据包各种情况
void USART1_IRQHandler(void)
&#123;
    static uint8_t RxState = 0;
    static uint8_t pRxPacket = 0;
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    &#123;
        uint8_t RxData = USART_ReceiveData(USART1);
        if (RxState == 0)
        &#123;
            if (RxData == '@' && Serial_RxFlag == 0) // 如果接收到'@'字符且标志位为0
            &#123;
                RxState = 1;
                pRxPacket = 0;
            &#125;
        &#125;
        else if (RxState == 1)
        &#123;
            if (RxData == '\r') // 如果接收到'\r'字符
            &#123;
                RxState = 2;
            &#125;
            else
            &#123;
                Serial_RxPacket[pRxPacket] = RxData; // 存储接收到的字符
                pRxPacket ++;
            &#125;
        &#125;
        else if (RxState == 2)
        &#123;
            if (RxData == '\n') // 如果接收到'\n'字符
            &#123;
                RxState = 0;
                Serial_RxPacket[pRxPacket] = '\0'; // 在末尾添加字符串结束符
                Serial_RxFlag = 1; // 设置串口接收标志位为1，表示接收完成
            &#125;
        &#125;
//清除标志位
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Serial.h</font></summary>  <pre><code class="language-c">
#ifndef __SERIAL_H
#define __SERIAL_H
#include <stdio.h>
// 定义串口接收缓冲区和接收标志位，这些变量可在main中引用
extern char Serial_RxPacket[];
extern uint8_t Serial_RxFlag;
//
void Serial_Init(void);                                  // 串口初始化函数
void Serial_SendByte(uint8_t Byte);                      // 发送单个字节到串口
void Serial_SendArray(uint8_t *Array, uint16_t Length);  // 发送字节数组到串口
void Serial_SendString(char *String);                    // 发送字符串到串口
void Serial_SendNumber(uint32_t Number, uint8_t Length); // 发送一个数字到串口，Length 表示数字的位数
void Serial_Printf(char *format, ...);                   // 带格式的字符串发送，类似于 printf
//
#endif
</code> </pre> </details>

<p>和HEX数据包类似，只是将数据形式换成了字符型。就不做过多说明。</p>
<p>main函数实现的功能为，在上位机输入‘@’为包头，输入‘LED_ON’为数据，换行为包尾，发送后将点亮LED，并回传“LED_ON_OK”，输入‘LED_OFF’为数据，发送后将熄灭LED，并回传“LED_OFF_OK”。输入其它指令将无法控制LED，并收到回传“ERROE_COMMAND”。</p>
<h1 id="FlyMcu程序烧录"><a href="#FlyMcu程序烧录" class="headerlink" title="FlyMcu程序烧录"></a>FlyMcu程序烧录</h1><h2 id="串口下载原理"><a href="#串口下载原理" class="headerlink" title="串口下载原理"></a>串口下载原理</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20231017093609745.png" class="" title="image-20231017093609745">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20231017093920557.png" class="" title="image-20231017093920557">

<p>写入的代码通过软件生成.hex文件后，配置BOOT引脚，使STM32执行BootLoader程序，设置BOOT0 &#x3D; 1并按下复位键，等程序下载完，此时仍在执行下载程序，所以需置BOOT0 &#x3D; 0，再次按下复位键。</p>
<p>如果stm32没有设置读保护，则写入的程序可被软件读出来，当然，一般只能是hex一类，反编译源码还是不现实。</p>
]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32归档（下）</title>
    <url>/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>个人学习笔记，因为STM32归档越来越长（怕目录太长出问题），所以有了下。<span id="more"></span></p>
<h1 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h1><h2 id="I2C软件模拟通信"><a href="#I2C软件模拟通信" class="headerlink" title="I2C软件模拟通信"></a>I2C软件模拟通信</h2><h3 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h3><p>•　I2C（Inter IC Bus）是由Philips公司开发的一种通用数据总线</p>
<p>•　两根通信线：SCL（Serial Clock）、SDA（Serial Data）</p>
<p>•　同步，半双工</p>
<p>•　带数据应答</p>
<p>•　支持总线挂载多设备（一主多从、多主多从）</p>
<h3 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h3><p>•　所有I2C设备的SCL连在一起，SDA连在一起</p>
<p>•　设备的SCL和SDA均要配置成开漏输出模式</p>
<p>•　SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017100133237.png" class="" title="image-20231017100133237">

<p>开漏输出模式有个线与的现象，只要有一个设备输出低电平，总线就处于低电平。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017100448237.png" class="" title="image-20231017100448237">

<p>SCLKN1OUT输出低电平时，mos管导通。输出高电平时，MOS管断开，处于浮空输入。</p>
<h3 id="I2C时序基本单元"><a href="#I2C时序基本单元" class="headerlink" title="I2C时序基本单元"></a>I2C时序基本单元</h3><p><strong>起始条件：</strong></p>
<p>SCL高电平期间，SDA从高电平切换到低电平</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017101034445.png" class="" title="image-20231017101034445">

<p><strong>终止条件：</strong></p>
<p>SCL高电平期间，SDA从低电平切换到高电平</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017101135745.png" class="" title="image-20231017101135745">





<p>只能由主机产生起始或终止条件，从机不允许，且SCL和SDA置高电平都由上拉电阻实现。</p>
<p><strong>发送一个字节：</strong></p>
<p>SCL低电平期间，主机将数据位依次放到SDA线上（<strong>高位先行</strong>），然后释放SCL，<strong>从机将在SCL高电平期间读取数据位</strong>，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017101630300.png" class="" title="image-20231017101630300">



<p>一般情况下，当SCL产生上升沿时，从机就从SDA读取数据完毕，所以主机需要提前放置数据置SDA。</p>
<p><strong>接收一个字节：</strong></p>
<p>SCL低电平期间，从机将数据位依次放到SDA线上（<strong>高位先行</strong>），然后释放SCL，<strong>主机将在SCL高电平期间读取数据位</strong>，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017101927913.png" class="" title="image-20231017101927913">



<p><strong>发送应答：</strong></p>
<p>主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017103533941.png" class="" title="image-20231017103533941">



<p><strong>接收应答：</strong></p>
<p>主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017103543583.png" class="" title="image-20231017103543583">



<p>应答功能可用于判断数据是否传输成功，也可以用于判断是否需要继续传输。</p>
<h3 id="数据帧示例"><a href="#数据帧示例" class="headerlink" title="数据帧示例"></a>数据帧示例</h3><p><strong>指定地址写</strong>：</p>
<p>对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017103904501.png" class="" title="image-20231017103904501">

<p><strong>当前地址读：</strong></p>
<p>对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017104007377.png" class="" title="image-20231017104007377">

<p><strong>指定地址读：</strong></p>
<p>对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231017104053149.png" class="" title="image-20231017104053149">



<h2 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h2><p><strong>MPU6050简介：</strong></p>
<p>•　MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角（欧拉角），常应用于平衡车、飞行器等需要检测自身姿态的场景</p>
<p>•　3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度</p>
<p>•　3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018084608575.png" class="" title="image-20231018084608575">

<p>芯片上会有个小图标标示x与y轴。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018084638732.png" class="" title="image-20231018084638732">

<p>加速度计可以理解为一个弹簧测力计，当物体有加速度时，将使弹簧受力，改变电位器。</p>
<p>另外，该加速度计只具有静态稳定性，不具备动态稳定性。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018084759528.png" class="" title="image-20231018084759528">

<p>而陀螺仪传感器只具有动态稳定性，不具备静态稳定性。</p>
<p><strong>MPU6050参数：</strong></p>
<p>•　16位ADC采集传感器的模拟信号，量化范围：-32768~32767</p>
<p>•　加速度计满量程选择：±2、±4、±8、±16（g）</p>
<p>•　陀螺仪满量程选择： ±250、±500、±1000、±2000（°&#x2F;sec）</p>
<p>•　可配置的数字低通滤波器</p>
<p>•　可配置的时钟源</p>
<p>•　可配置的采样分频</p>
<p>•　I2C从机地址：1101000（AD0&#x3D;0） 1101001（AD0&#x3D;1）</p>
<p>值得注意的是，I2C的数据格式为8位一个包，地址位为7位，此后有一位为读写位。所以写入MPU6050的地址为0x68再或上读写位，也可以直接写入0xD0，读写位和地址位合为一个8位数据。</p>
<p><strong>硬件电路：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018090147960.png" class="" title="image-20231018090147960">

<p>整体硬件电路由左上角的稳压器，左下引出排针和右侧芯片组成，有排针引脚可知该硬件支持拓展。</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018090159079.png" class="" title="image-20231018090159079">



<p>另外，在配置硬件的自由落体检测，运动检测等，可触发INT输出中段信号。</p>
<p><strong>MPU6050框图：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018090613475.png" class="" title="image-20231018090613475">



<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018090849895.png" class="" title="image-20231018090849895">



<p><strong>MPU6050的I2C通信格式：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018091413370.png" class="" title="image-20231018091413370">



<p><strong>寄存器地址：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018091543354.png" class="" title="image-20231018091543354">

<p>Addr(Hex)：16进制地址</p>
<p>Addr(Dec)：10进制地址</p>
<p>Register Name：寄存器名称</p>
<p>SerialI&#x2F;F：读写权限</p>
<p>在文档“RM-MPU-6000A”中有该硬件的寄存器表，通过此表，可得知相应的寄存器地址。如果需要读取特定的寄存器数据（比如加速度计的数据）可由此表查询地址。当然，也可以写入命名到寄存器，用于设置硬件模式等等。</p>
<p>所有寄存器上电默认为0x00，除了107号寄存器上电默认为0x40(睡眠)，117号寄存器为0x68。</p>
<h3 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "MPU6050.h"
uint8_t ID;                 //设备ID号
int16_t AX,AY,AZ,GX,GY,GZ;  //xyz加速度和角速度
int main(void)
&#123;
    //初始化
    OLED_Init();
    MPU6050_Init();
    ID = MPU6050_GetID();        //获取设备ID号
    OLED_ShowString(1,1,"ID:");
    OLED_ShowHexNum(1,4,ID,2);
    while (1)
    &#123;
MPU6050_GetData(&AX,&AY,&AZ,&GX,&GY,&GZ);   //获取加速度和角速度的参数
        OLED_ShowSignedNum(2,1,AX,5);
        OLED_ShowSignedNum(3,1,AY,5);
        OLED_ShowSignedNum(4,1,AZ,5);
        OLED_ShowSignedNum(2,8,GX,5);
        OLED_ShowSignedNum(3,8,GY,5);
        OLED_ShowSignedNum(4,8,GZ,5);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MyI2c.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
#include "Delay.h"
void MyI2C_W_SCL(uint8_t BitValue)  //封装写SCL（时钟线）函数，并加上小延时确保相应。
&#123;
    GPIO_WriteBit(GPIOB,GPIO_Pin_10,(BitAction)BitValue);
    Delay_us(10);
&#125;
void MyI2C_W_SDA(uint8_t BitValue)  //封装写SDA（数据线）函数，
&#123;
    GPIO_WriteBit(GPIOB,GPIO_Pin_11,(BitAction)BitValue);
    Delay_us(10);
&#125;
uint8_t MyI2C_R_SDA(void)    //读SDA
&#123;
    uint8_t BitValue;
    BitValue = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11);
    Delay_us(10);
    return BitValue;
&#125;
void MyI2C_Init(void)   //初始化
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_10 | GPIO_Pin_11);  //初始化I2C双线为高电平
&#125;
void MyI2C_Start(void)  //启动
&#123;
    MyI2C_W_SDA(1);
    MyI2C_W_SCL(1);
    MyI2C_W_SDA(0);
    MyI2C_W_SCL(0);
&#125;
void MyI2C_STOP(void)  //停止
&#123;
    MyI2C_W_SDA(0);
    MyI2C_W_SCL(1);
    MyI2C_W_SDA(1);
&#125;
void MyI2C_SendByte(uint8_t Byte)  //发送一位字节
&#123;
    uint8_t i;
    for(i=0;i<8;i++)
    &#123;
        MyI2C_W_SDA(Byte & (0x80 >> i));
        MyI2C_W_SCL(1);
        MyI2C_W_SCL(0);
    &#125;
&#125;
uint8_t MyI2C_ReceiveByte(void)  //接收一位字节
&#123;
    uint8_t i,Byte = 0x00;
    for(i=0;i<8;i++)
    &#123;
        MyI2C_W_SDA(1);
        MyI2C_W_SCL(1);
        if(MyI2C_R_SDA() == 1) Byte |= (0x80>>i);
        MyI2C_W_SCL(0);	
    &#125;
    return Byte;
&#125;
void MyI2C_SendAck(uint8_t AckBit)  //发送应答
&#123;
    MyI2C_W_SDA(AckBit);
    MyI2C_W_SCL(1);
    MyI2C_W_SCL(0);
&#125;
uint8_t MyI2C_ReceiveAck(void)      //接收应答
&#123;
    uint8_t AckBit;
    MyI2C_W_SDA(1);
    MyI2C_W_SCL(1);
    AckBit = MyI2C_R_SDA();
    MyI2C_W_SCL(0);	
    return AckBit;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MPU6050.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "MyI2C.h"
#include "MPU6050_Reg.h"
#define MPU6050_ADDRESS 0xD0      //宏定义MPU6050地址，应该为0x68,0xD0为7位地址或上读写位的整合。
void MPU6050_WriteReg(uint8_t RegAddress,uint8_t Data)   //指定地址写数据
&#123;
    MyI2C_Start();
    MyI2C_SendByte(MPU6050_ADDRESS);
    MyI2C_ReceiveAck();
    MyI2C_SendByte(RegAddress);
    MyI2C_ReceiveAck();
    MyI2C_SendByte(Data);      //如果需要连续写多个字节，可用for循环执行注释的这两句。
    MyI2C_ReceiveAck();        //当写入多字节时，每写入一个字节，地址自动+1。
    MyI2C_STOP();
&#125;
uint8_t MPU6050_ReadReg(uint8_t RegAddress)       //指定地址读数据
&#123;
    uint8_t Data;
    //第一个起始条件发送地址
    MyI2C_Start();
    MyI2C_SendByte(MPU6050_ADDRESS);
    MyI2C_ReceiveAck();
    MyI2C_SendByte(RegAddress);
    MyI2C_ReceiveAck();
    //第二个起始条件读地址，读写地址位重新指定，通信协议读写位只能在起始条件后的一个字节设定。
    MyI2C_Start();
    MyI2C_SendByte(MPU6050_ADDRESS | 0x01);        //指定地址或上“读数据”位
    MyI2C_ReceiveAck();
    Data = MyI2C_ReceiveByte();
    MyI2C_SendAck(1);
    MyI2C_STOP();
    return Data;
&#125;
void MPU6050_Init(void)
&#123;
    MyI2C_Init();
    MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x01);        //解除睡眠，时钟源为陀螺仪时钟
    MPU6050_WriteReg(MPU6050_PWR_MGMT_2, 0x00);        //6轴一直启用，均不待机
    MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x09);        //采样分频为10
    MPU6050_WriteReg(MPU6050_CONFIG, 0x06);            //滤波参数为最大
    MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);       //陀螺仪为最大量程
    MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x18);      //加速度为最大量程
&#125;
uint8_t MPU6050_GetID(void)		//获取设备ID号
&#123;
    return MPU6050_ReadReg(MPU6050_WHO_AM_I);
&#125;
void MPU6050_GetData(int16_t *AccX, int16_t *AccY, int16_t *AccZ,
                     int16_t *GyroX, int16_t *GyroY, int16_t *GyroZ)  //获取搜集的参数
&#123;
    uint8_t DataH, DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);
    *AccX = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);
    *AccY = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);
    *AccZ = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);
    *GyroX = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);
    *GyroY = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);
    *GyroZ = (DataH << 8)| DataL;        
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MPU6050_Reg.h</font></summary>  <pre><code class="language-c">
#ifndef    __MPU6050_Reg__H
#define    __MPU6050_Reg__H
//控制寄存器
#define	MPU6050_SMPLRT_DIV		0x19
#define	MPU6050_CONFIG			0x1A
#define	MPU6050_GYRO_CONFIG		0x1B
#define	MPU6050_ACCEL_CONFIG	0x1C
//收集的数据存放的寄存器
#define	MPU6050_ACCEL_XOUT_H	0x3B
#define	MPU6050_ACCEL_XOUT_L	0x3C
#define	MPU6050_ACCEL_YOUT_H	0x3D
#define	MPU6050_ACCEL_YOUT_L	0x3E
#define	MPU6050_ACCEL_ZOUT_H	0x3F
#define	MPU6050_ACCEL_ZOUT_L	0x40
#define	MPU6050_TEMP_OUT_H		0x41
#define	MPU6050_TEMP_OUT_L		0x42
#define	MPU6050_GYRO_XOUT_H		0x43
#define	MPU6050_GYRO_XOUT_L		0x44
#define	MPU6050_GYRO_YOUT_H		0x45
#define	MPU6050_GYRO_YOUT_L		0x46
#define	MPU6050_GYRO_ZOUT_H		0x47
#define	MPU6050_GYRO_ZOUT_L		0x48
//电源管理寄存器和设备ID寄存器
#define	MPU6050_PWR_MGMT_1		0x6B
#define	MPU6050_PWR_MGMT_2		0x6C
#define	MPU6050_WHO_AM_I		0x75   
 #endif
</code> </pre> </details>

<p>先写好I2C通讯时序，再通过时序组成数据帧。然后在MPU6050中对数据帧进行封装，此后可在主函数直接调用对硬件的读写函数。因为直接写0x3c一类写入寄存器不易于理解和后续维护，所以引入“MPU6050—Reg”，将寄存器地址进行宏定义。</p>
<h2 id="STM32硬件I2C通信"><a href="#STM32硬件I2C通信" class="headerlink" title="STM32硬件I2C通信"></a>STM32硬件I2C通信</h2><h3 id="I2C外设简介"><a href="#I2C外设简介" class="headerlink" title="I2C外设简介"></a>I2C外设简介</h3><p>•　STM32内部集成了硬件I2C收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，减轻CPU的负担</p>
<p>•　支持多主机模型</p>
<p>•　支持7位&#x2F;10位地址模式</p>
<p>•　支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)</p>
<p>•　支持DMA</p>
<p>•　兼容SMBus协议（系统管理总线）</p>
<p>•　STM32F103C8T6 硬件I2C资源：I2C1、I2C2</p>
<h3 id="I2C框图"><a href="#I2C框图" class="headerlink" title="I2C框图"></a>I2C框图</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100349831.png" class="" title="image-20231018100349831">

<h3 id="I2C基本结构"><a href="#I2C基本结构" class="headerlink" title="I2C基本结构"></a>I2C基本结构</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100439583.png" class="" title="image-20231018100439583">

<p>移位寄存器左移，高位先行。</p>
<h3 id="主机发送"><a href="#主机发送" class="headerlink" title="主机发送"></a>主机发送</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100533249.png" class="" title="image-20231018100533249">

<p>7位和10位主要差别为寻址位是7位或是10位。当一个时序完成后，STM32会置EVx位(可理解为大标志位)。通过对此位的查询，可得知事件状态。</p>
<h3 id="主机接收"><a href="#主机接收" class="headerlink" title="主机接收"></a>主机接收</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100801037.png" class="" title="image-20231018100801037">

<p>EV5事件表示起始条件已发送</p>
<p>EV6事件表示寻址已完成</p>
<h3 id="软件-x2F-硬件波形对比"><a href="#软件-x2F-硬件波形对比" class="headerlink" title="软件&#x2F;硬件波形对比"></a>软件&#x2F;硬件波形对比</h3><p><strong>软件波形：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100928963.png" class="" title="image-20231018100928963">

<p><strong>硬件波形：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231018100939975.png" class="" title="image-20231018100939975">

<p>通过对比可知：<br>硬件I2C的波形会更加规整，每个时钟的周期和占空比都非常一致，而软件I2C由于操作引脚后加入了延时，导致每个时钟的周期和占空比不规整。由于I2C是同步时序，所以影响不大。</p>
<p>SCL低电平写，高电平读。保证尽早的原则，直接在SCL下降沿写，上升沿读。</p>
<h3 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "MPU6050.h"
uint8_t ID;
int16_t AX,AY,AZ,GX,GY,GZ;
int main(void)
&#123;
    OLED_Init();
    MPU6050_Init();
    ID = MPU6050_GetID();
    OLED_ShowString(1,1,"ID:");
    OLED_ShowHexNum(1,4,ID,2);
    while (1)
    &#123;
        MPU6050_GetData(&AX,&AY,&AZ,&GX,&GY,&GZ);
        OLED_ShowSignedNum(2,1,AX,5);
        OLED_ShowSignedNum(3,1,AY,5);
        OLED_ShowSignedNum(4,1,AZ,5);
        OLED_ShowSignedNum(2,8,GX,5);
        OLED_ShowSignedNum(3,8,GY,5);
        OLED_ShowSignedNum(4,8,GZ,5);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MPU6050.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "MPU6050_Reg.h"
#define MPU6050_ADDRESS 0xD0      //宏定义MPU6050地址
void MPU6050_WaitEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)  //等待EV事件，防止用while卡死，改用定时退出
&#123;
    uint32_t TimeOut;
    TimeOut = 10000;
    while(I2C_CheckEvent(I2Cx,I2C_EVENT) != SUCCESS)
    &#123;
        TimeOut--;
        if(TimeOut == 0) break;
    &#125;
&#125;
void MPU6050_WriteReg(uint8_t RegAddress,uint8_t Data)   //写字节
&#123;
    I2C_GenerateSTART(I2C2,ENABLE);
    while(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);
    I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);
    while(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) != SUCCESS);
    I2C_SendData(I2C2,RegAddress);
    while(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) != SUCCESS);
    I2C_SendData(I2C2,Data);
    while(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) != SUCCESS);
    I2C_GenerateSTOP(I2C2,ENABLE);
&#125;
uint8_t MPU6050_ReadReg(uint8_t RegAddress)    //读字节
&#123;
    uint8_t Data;
    I2C_GenerateSTART(I2C2,ENABLE);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);
    I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);
    I2C_SendData(I2C2,RegAddress);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED);
    I2C_GenerateSTART(I2C2,ENABLE);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT);
    I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Receiver);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);
    I2C_AcknowledgeConfig(I2C2,DISABLE);
    I2C_GenerateSTOP(I2C2,ENABLE);
    MPU6050_WaitEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED);
    Data = I2C_ReceiveData(I2C2);
    I2C_AcknowledgeConfig(I2C2,ENABLE);
    return Data;
&#125;
void MPU6050_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB,&GPIO_InitStructure);
    I2C_InitTypeDef I2C_InitStructure;
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStructure.I2C_ClockSpeed = 50000;
    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    I2C_InitStructure.I2C_OwnAddress1 = 0x00;
    I2C_Init(I2C2,&I2C_InitStructure);
    I2C_Cmd(I2C2,ENABLE);
    MPU6050_WriteReg(MPU6050_PWR_MGMT_1, 0x01);        //解除睡眠，时钟源为陀螺仪时钟
    MPU6050_WriteReg(MPU6050_PWR_MGMT_2, 0x00);        //6轴一直启用，均不待机
    MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x09);        //采样分频为10
    MPU6050_WriteReg(MPU6050_CONFIG, 0x06);            //滤波参数为最大
    MPU6050_WriteReg(MPU6050_GYRO_CONFIG, 0x18);       //陀螺仪为最大量程
    MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, 0x18);      //加速度为最大量程
&#125;
uint8_t MPU6050_GetID(void)      //获取设备ID号
&#123;
    return MPU6050_ReadReg(MPU6050_WHO_AM_I);
&#125;
void MPU6050_GetData(int16_t *AccX, int16_t *AccY, int16_t *AccZ,
                     int16_t *GyroX, int16_t *GyroY, int16_t *GyroZ)  //获取数据
&#123;
    uint8_t DataH, DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);
    *AccX = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);
    *AccY = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);
    *AccZ = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);
    *GyroX = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);
    *GyroY = (DataH << 8)| DataL;
    DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);
    DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);
    *GyroZ = (DataH << 8)| DataL;        
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MPU6050_Reg.h</font></summary>  <pre><code class="language-c">
#ifndef    __MPU6050_Reg__H
#define    __MPU6050_Reg__H
#define	MPU6050_SMPLRT_DIV		0x19
#define	MPU6050_CONFIG			0x1A
#define	MPU6050_GYRO_CONFIG		0x1B
#define	MPU6050_ACCEL_CONFIG	0x1C
#define	MPU6050_ACCEL_XOUT_H	0x3B
#define	MPU6050_ACCEL_XOUT_L	0x3C
#define	MPU6050_ACCEL_YOUT_H	0x3D
#define	MPU6050_ACCEL_YOUT_L	0x3E
#define	MPU6050_ACCEL_ZOUT_H	0x3F
#define	MPU6050_ACCEL_ZOUT_L	0x40
#define	MPU6050_TEMP_OUT_H		0x41
#define	MPU6050_TEMP_OUT_L		0x42
#define	MPU6050_GYRO_XOUT_H		0x43
#define	MPU6050_GYRO_XOUT_L		0x44
#define	MPU6050_GYRO_YOUT_H		0x45
#define	MPU6050_GYRO_YOUT_L		0x46
#define	MPU6050_GYRO_ZOUT_H		0x47
#define	MPU6050_GYRO_ZOUT_L		0x48
#define	MPU6050_PWR_MGMT_1		0x6B
#define	MPU6050_PWR_MGMT_2		0x6C
#define	MPU6050_WHO_AM_I		0x75   
 #endif
</code> </pre> </details>
程序执行逻辑和软件I2C示例差不多，仅是将软件时序替换为STM32标准库函数，并且STM32对通信的状态有事件标志位和定义，通过读取标志位就明白时序是否完成。



<h2 id="I2C缺点"><a href="#I2C缺点" class="headerlink" title="I2C缺点"></a>I2C缺点</h2><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021144801473.png" class="" title="image-20231021144801473">

<p>I2C的电路结构是开漏外加上拉电阻，使通信线高电平的驱动能力比较弱，导致通信线由低电平到高电平时上升沿耗时长，这限制了I2C的最大通信速度。而SPI设计简单粗暴，传输速度也比I2C快很多。</p>
<h1 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h1><h2 id="SPI软件模拟通信"><a href="#SPI软件模拟通信" class="headerlink" title="SPI软件模拟通信"></a>SPI软件模拟通信</h2><h3 id="SPI简介"><a href="#SPI简介" class="headerlink" title="SPI简介"></a>SPI简介</h3><p>•　SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线</p>
<p>•　四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）</p>
<p>•　同步，全双工</p>
<p>•　支持总线挂载多设备（一主多从，不支持多主多从）</p>
<p>SCK提供时钟信号，数据位的输出输入都是在SCK的上升沿或下降沿进行的，此时数据位的收发时刻就可以明确确定。</p>
<h3 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h3><p>•　所有SPI设备的SCK、MOSI、MISO分别连在一起</p>
<p>•　主机另外引出多条SS控制线，分别接到各从机的SS引脚</p>
<p>•　输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入（SS为低电平片选时，从机才允许变为推挽输出）</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021145137608.png" class="" title="image-20231021145137608">

<h3 id="移位示意图"><a href="#移位示意图" class="headerlink" title="移位示意图"></a>移位示意图</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160333584.png" class="" title="image-20231021160333584">

<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160419734.png" class="" title="image-20231021160419734">

<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160504117.png" class="" title="image-20231021160504117">

<p>该示例为高位先行。</p>
<p>由波特率发生器产生的时钟驱动主机的移位寄存器进行移位。时钟的上升沿，所有移位寄存器向左移一位，移位的数据放在MOSI和MISO上，发生器的下降沿，将采样MOSI和MISO到移位寄存器最低位存储。</p>
<h3 id="SPI时序基本单元"><a href="#SPI时序基本单元" class="headerlink" title="SPI时序基本单元"></a>SPI时序基本单元</h3><p><strong>起始条件：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160533341.png" class="" title="image-20231021160533341">

<p>SS从高电平切换到低电平</p>
<p><strong>终止条件：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160616896.png" class="" title="image-20231021160616896">

<p>SS从低电平切换到高电平</p>
<p><strong>交换一个字节（模式0）</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021160653541.png" class="" title="image-20231021160653541">

<p>CPOL（时钟极性） &#x3D; 0：空闲状态时，SCK为低电平</p>
<p>CPHA（时钟相位） &#x3D; 0：SCK第一个边沿<strong>移入数据</strong>，第二个边沿<strong>移出数据</strong></p>
<p>因为SCK第一个边沿要移入数据至寄存器，所以需提前写入数据到数据线上，相较于模式1提前了数据线的相位。 </p>
<p><strong>交换一个字节（模式1）</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021161150625.png" class="" title="image-20231021161150625">

<p>CPOL &#x3D; 0：空闲状态时，SCK为低电平</p>
<p>CPHA &#x3D; 1：SCK第一个边沿<strong>移出数据</strong>，第二个边沿<strong>移入数据</strong></p>
<p>即：SCK第一个上升沿（第一个边沿），双方移位寄存器同时移出寄存器数据置MOSI和MISO上，SCK下降沿（第二个边沿）的时候，双方移位寄存器同时移入MOSI和MISO的数据置寄存器，达成数据交换。</p>
<p><strong>交换一个字节（模式2）</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021162610968.png" class="" title="image-20231021162610968">

<p>CPOL&#x3D;1：空闲状态时，SCK为高电平</p>
<p>CPHA&#x3D;0：SCK第一个边沿移入数据，第二个边沿移出数据</p>
<p><strong>交换一个字节（模式3）</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021162638853.png" class="" title="image-20231021162638853">

<p>CPOL&#x3D;1：空闲状态时，SCK为高电平</p>
<p>CPHA&#x3D;1：SCK第一个边沿移出数据，第二个边沿移入数据</p>
<p>模式2和模式3，相较与模式0和模式1，仅是SCK时钟极性变化而已。</p>
<h3 id="SPI时序"><a href="#SPI时序" class="headerlink" title="SPI时序"></a>SPI时序</h3><p>示例时序均为模式0</p>
<p><strong>发送指令</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021162831064.png" class="" title="image-20231021162831064">

<p>向SS指定的设备，发送指令（0x06）写使能。</p>
<p><strong>指定地址写</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021162932666.png" class="" title="image-20231021162932666">

<p>向SS指定的设备，发送写指令（0x02），</p>
<p>   随后在指定地址（Address[23:0]）下，写入指定数据（Data）。</p>
<p><strong>指定地址读</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021163047497.png" class="" title="image-20231021163047497">

<p>向SS指定的设备，发送读指令（0x03），</p>
<p>   随后在指定地址（Address[23:0]）下，读取从机数据（Data）</p>
<h2 id="W25Q64"><a href="#W25Q64" class="headerlink" title="W25Q64"></a>W25Q64</h2><p><strong>W25Q64简介：</strong></p>
<p>•　W25Qxx系列是一种低成本、小型化、使用简单的非易失性存储器，常应用于数据存储、字库存储、固件程序存储等场景</p>
<p>•　存储介质：Nor Flash（闪存）</p>
<p>•　时钟频率：80MHz &#x2F; 160MHz (Dual SPI) &#x2F; 320MHz (Quad SPI)</p>
<p>•　存储容量（24位地址）： （最大寻址能达到16M）</p>
<p> W25Q40：  4Mbit &#x2F; 512KByte</p>
<p> W25Q80：  8Mbit &#x2F; 1MByte</p>
<p> W25Q16：  16Mbit &#x2F; 2MByte</p>
<p> W25Q32：  32Mbit &#x2F; 4MByte</p>
<p> W25Q64：  64Mbit &#x2F; 8MByte</p>
<p> W25Q128： 128Mbit &#x2F; 16MByte</p>
<p> W25Q256： 256Mbit &#x2F; 32MByte</p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021163200365-16978771242631.png" class="" title="image-20231021163200365">



<p><strong>硬件电路：</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021163235865.png" class="" title="image-20231021163235865">

<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021163239383.png" class="" title="image-20231021163239383">

<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021163249323.png" class="" title="image-20231021163249323">



<p>CS在图中引脚标识为“&#x2F;CS”，表示低电平有效其余同理。有需要时，可启用IO2和IO3，相当于多线并行传输，提高传输效率。</p>
<p><strong>W25Q64框图</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021172150480.png" class="" title="image-20231021172150480">

<p>W25Q64有相应的写保护和地址锁存。需要注意的是地址分配方式。以8M芯片为例（最后一位地址到7F），64KB划为一页，每页又可以以4KB为单位分成扇区。</p>
<p><strong>Flash操作注意事项：</strong></p>
<p>写入操作时：</p>
<p>•　写入操作前，必须先进行写使能</p>
<p>•　每个数据位只能由1改写为0，不能由0改写为1</p>
<p>•　<strong>写入数据前必须先擦除，擦除后，所有数据位变为1</strong></p>
<p>•　擦除必须按最小擦除单元进行（例如示例芯片的最小单位为4KB扇区）</p>
<p>•　连续写入多字节时，最多写入一页的数据，超过页尾位置的数据，会回到页首覆盖写入</p>
<p>•　写入操作结束后，芯片进入忙状态，不响应新的读写操作</p>
<p>读取操作时：</p>
<p>•　直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取</p>
<h3 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "W25Q64.h"
//
uint8_t MID;
uint16_t DID;
uint8_t ArrayWrite[] = &#123;0x55, 0x66, 0x77, 0x88&#125;;
uint8_t ArrayRead[4];
int main(void)
&#123;
//初始化
    OLED_Init();
    W25Q64_Init();
    OLED_ShowString(1, 1, "MID:   DID:");
    OLED_ShowString(2, 1, "W:");
    OLED_ShowString(3, 1, "R:");
    W25Q64_ReadID(&MID,&DID);       //读取设备ID号
    OLED_ShowHexNum(1,5,MID,2);     //显示设备ID号
    OLED_ShowHexNum(1,12,DID,4);
//
    W25Q64_SectorErase(0X000000);   //擦除扇区，为写入数据做准备
    W25Q64_PageProgram(0X000000,ArrayWrite,4); //向指定地址写入数据，写入四个数据
    W25Q64_ReadData(0X000000,ArrayRead,4);     //向指定地址读数据
//显示写入数据	
    OLED_ShowHexNum(2,3,ArrayWrite[0],2);
    OLED_ShowHexNum(2,6,ArrayWrite[1],2);
    OLED_ShowHexNum(2,9,ArrayWrite[2],2);
    OLED_ShowHexNum(2,12,ArrayWrite[3],2);
//显示读取数据	
    OLED_ShowHexNum(3,3, ArrayRead[0],2);
    OLED_ShowHexNum(3,6, ArrayRead[1],2);
    OLED_ShowHexNum(3,9, ArrayRead[2],2);
    OLED_ShowHexNum(3,12,ArrayRead[3],2);
    while (1)
    &#123;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MySPI.C</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
// 对引脚操控进行基础的封装
void MySPI_W_SS(uint8_t BitValue)
&#123;
    GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);    // 设置片选信号 (SS/CS) 的状态
&#125;
void MySPI_W_SCK(uint8_t BitValue)
&#123;
    GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);    // 设置时钟信号 (SCK) 的状态
&#125;
void MySPI_W_MOSI(uint8_t BitValue)
&#123;
    GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue);    // 设置主机输出从机输入 (MOSI) 的状态
&#125;
uint8_t MySPI_R_MISO(void)
&#123;
    return GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6);         // 读取从机输出主机输入 (MISO) 的状态
&#125;
// 初始化SPI相关的GPIO引脚
void MySPI_Init(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    // 配置引脚为推挽输出
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    // 配置引脚为上拉输入
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    // 初始化SPI外设，设置初始状态
    MySPI_W_SS(1);    // 片选信号高电平
    MySPI_W_SCK(0);  // 时钟信号低电平
&#125;
//起始时序
void MySPI_Start(void)  
&#123;
    MySPI_W_SS(0); 
&#125;
//终止时序
void MySPI_STOP(void)
&#123;
    MySPI_W_SS(1); 
&#125;
//交换数据
uint8_t MySPI_SwapByte(uint8_t ByteSend)
&#123;
    uint8_t i, ByteReceive = 0x00;
    for(i = 0; i < 8; i++)
    &#123;
        MySPI_W_MOSI(ByteSend & (0x80 >> i)); // 设置主机输出数据
        MySPI_W_SCK(1);                      // 拉高时钟信号
        if(MySPI_R_MISO() == 1) 
            ByteReceive |= (0x80 >> i);     // 读取从机输出的数据
        MySPI_W_SCK(0);                    // 拉低时钟信号
    &#125;
    return ByteReceive;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">W25Q64.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
#include "MySPI.h"
#include "W25Q64_Ins.h"
// 初始化SPI接口
void W25Q64_Init(void)
&#123;
    MySPI_Init(); 
&#125;
//读设备ID
void W25Q64_ReadID(uint8_t *MID, uint16_t *DID)
&#123;
    MySPI_Start();                              // 起始条件时序
    MySPI_SwapByte(W25Q64_JEDEC_ID);            // 发送指令
    *MID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);   // 读取制造商ID
    *DID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);   // 读取设备ID的低8位
    *DID <<= 8;
    *DID |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);  // 读取设备ID的高8位
    MySPI_STOP();                               // 终止条件时序
&#125;
//写使能
void W25Q64_WriteEnable(void)
&#123;
    MySPI_Start();
    MySPI_SwapByte(W25Q64_WRITE_ENABLE); // 发送写使能指令
    MySPI_STOP(); 
&#125;
//等待设备忙，并规定时间限制
void W25Q64_WaitBusy(void)
&#123;
    uint32_t Timeout = 100000;
    MySPI_Start();                     
    MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1); // 发送读状态寄存器指令
    while ((MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1) & 0x01) == 0x01)
    &#123;
        Timeout--;
        if (Timeout == 0)
        &#123;
            break;
        &#125;
    &#125;
    MySPI_STOP(); 
&#125;
//指定地址写入数据，
void W25Q64_PageProgram(uint32_t Address, uint8_t *DataArray, uint16_t Count)
&#123;
    W25Q64_WriteEnable();                  // 写使能
    uint16_t i;
    MySPI_Start();                          
    MySPI_SwapByte(W25Q64_PAGE_PROGRAM);    // 发送页编程指令
    MySPI_SwapByte(Address >> 16);          // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);           // 发送地址的中间8位
    MySPI_SwapByte(Address);                // 发送地址的低8位
    for (i = 0; i < Count; i++)
    &#123;
        MySPI_SwapByte(DataArray[i]);    // 发送要写入的数据
    &#125;
    MySPI_STOP(); 
    W25Q64_WaitBusy();                  // 等待操作完成
&#125;
//擦除指定地址的扇区
void W25Q64_SectorErase(uint32_t Address)
&#123;
    W25Q64_WriteEnable();    // 启用写操作
    MySPI_Start();            
    MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB); // 发送扇区擦除指令
    MySPI_SwapByte(Address >> 16);          // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);          // 发送地址的中间8位
    MySPI_SwapByte(Address);              // 发送地址的低8位
    MySPI_STOP(); 
    W25Q64_WaitBusy(); // 等待操作完成
&#125;
//指定地址读
void W25Q64_ReadData(uint32_t Address, uint8_t *DataArray, uint32_t Count)
&#123;
    uint32_t i;
    MySPI_Start(); 
    MySPI_SwapByte(W25Q64_READ_DATA);      // 发送读数据指令
    MySPI_SwapByte(Address >> 16);        // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);        // 发送地址的中间8位
    MySPI_SwapByte(Address);            // 发送地址的低8位
    for (i = 0; i < Count; i++)
    &#123;
        DataArray[i] = MySPI_SwapByte(W25Q64_DUMMY_BYTE);  // 读取数据
    &#125;
    MySPI_STOP(); 
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">W25Q64_Ins.h</font></summary>  <pre><code class="language-c">
#ifndef    __W25Q64_Ins__H
#define    __W25Q64_Ins__H
// W25Q64指令
#define W25Q64_WRITE_ENABLE							0x06
#define W25Q64_WRITE_DISABLE						0x04
#define W25Q64_READ_STATUS_REGISTER_1				0x05
#define W25Q64_READ_STATUS_REGISTER_2				0x35
#define W25Q64_WRITE_STATUS_REGISTER				0x01
#define W25Q64_PAGE_PROGRAM							0x02
#define W25Q64_QUAD_PAGE_PROGRAM					0x32
#define W25Q64_BLOCK_ERASE_64KB						0xD8
#define W25Q64_BLOCK_ERASE_32KB						0x52
#define W25Q64_SECTOR_ERASE_4KB						0x20
#define W25Q64_CHIP_ERASE							0xC7
#define W25Q64_ERASE_SUSPEND						0x75
#define W25Q64_ERASE_RESUME							0x7A
#define W25Q64_POWER_DOWN							0xB9
#define W25Q64_HIGH_PERFORMANCE_MODE				0xA3
#define W25Q64_CONTINUOUS_READ_MODE_RESET			0xFF
#define W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID		0xAB
#define W25Q64_MANUFACTURER_DEVICE_ID				0x90
#define W25Q64_READ_UNIQUE_ID						0x4B
#define W25Q64_JEDEC_ID								0x9F
#define W25Q64_READ_DATA							0x03
#define W25Q64_FAST_READ							0x0B
#define W25Q64_FAST_READ_DUAL_OUTPUT				0x3B
#define W25Q64_FAST_READ_DUAL_IO					0xBB
#define W25Q64_FAST_READ_QUAD_OUTPUT				0x6B
#define W25Q64_FAST_READ_QUAD_IO					0xEB
#define W25Q64_OCTAL_WORD_READ_QUAD_IO				0xE3
#define W25Q64_DUMMY_BYTE							0xFF
 #endif
</code> </pre> </details>

<p>程序设计思路和I2C差不多，都是先用软件模拟SPI时序基本单元，再将基本单元组成传输时序。然后再根据硬件对其再封装。写指令的常量将用宏定义代替，便于理解。</p>
<h2 id="STM32硬件SPI通信"><a href="#STM32硬件SPI通信" class="headerlink" title="STM32硬件SPI通信"></a>STM32硬件SPI通信</h2><h3 id="SPI外设简介"><a href="#SPI外设简介" class="headerlink" title="SPI外设简介"></a>SPI外设简介</h3><p>•　STM32内部集成了硬件SPI收发电路，可以由硬件自动执行时钟生成、数据收发等功能，减轻CPU的负担</p>
<p>•　可配置8位&#x2F;16位数据帧、高位先行&#x2F;低位先行</p>
<p>•　时钟频率： fPCLK &#x2F; (2, 4, 8, 16, 32, 64, 128, 256)</p>
<p>•　支持多主机模型、主或从操作</p>
<p>•　可精简为半双工&#x2F;单工通信</p>
<p>•　支持DMA</p>
<p>•　兼容I2S协议</p>
<p>•　STM32F103C8T6 硬件SPI资源：SPI1、SPI2</p>
<p>SPI1挂载在APB2最大允许频率为72MHz，SPI2挂载在APB1最大允许频率为36MHz。使用不同的SPI时，应注意挂载的总线时钟。</p>
<h3 id="主模式全双工连续传输"><a href="#主模式全双工连续传输" class="headerlink" title="主模式全双工连续传输"></a>主模式全双工连续传输</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231021230447228.png" class="" title="image-20231021230447228">

<p>连续传输将传输效率最大化。先写入数据0xF1到发送缓冲器，再开始传输。每次数据传输，都是如图，第二个数据0xF2发送时，0xF1才被接收。并不是0xF1发送 → 0xF1接收，再0xF2发送 → 0xF2接收。而是0xF1先写入发送缓冲器，时序开始时发送 0xF1，并将 0xF2写入发送缓冲器，再0xF1接收 → （同时）0xF2发送。0xF2接收 → （同时）0xF3发送以此类推。。。发送总比接收早，数据传输是紧跟的。</p>
<h3 id="非连续传输"><a href="#非连续传输" class="headerlink" title="非连续传输"></a>非连续传输</h3><img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231022000603924.png" class="" title="image-20231022000603924">

<p>非连续传输相较于连续传输简单，效率不如连续传输。因为连续传输的数据是紧挨着传输，而非连续传输，0xF1发送 → 0xF1接收。将等待接收完毕后再发送，而不是先将0xF1写入缓冲器，时序开始时0xF1挂载到数据线，在交换数据，接收0xF1的同时发送0xF2.</p>
<p><strong>当然，SPI通信的核心是主从两机寄存器数据交换，描述只是便于表达，切记数据是双向同时传输</strong></p>
<h3 id="软件-x2F-硬件波形对比-1"><a href="#软件-x2F-硬件波形对比-1" class="headerlink" title="软件&#x2F;硬件波形对比"></a>软件&#x2F;硬件波形对比</h3><p><strong>软件模拟SPI</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231022001711028.png" class="" title="image-20231022001711028">

<p><strong>硬件SPI</strong></p>
<img src="/2023/10/16/STM32%E5%BD%92%E6%A1%A3%EF%BC%88%E4%B8%8B%EF%BC%89/image-20231022001734433.png" class="" title="image-20231022001734433">

<p>区别无非是软件有延迟，并且波形没有硬件平滑等等，和I2C波形软硬件对比差不多。</p>
<h3 id="程序示例-3"><a href="#程序示例-3" class="headerlink" title="程序示例"></a>程序示例</h3><details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "W25Q64.h"
//
uint8_t MID;
uint16_t DID;
uint8_t ArrayWrite[] = &#123;0x55, 0x66, 0x77, 0x88&#125;;
uint8_t ArrayRead[4];
int main(void)
&#123;
//初始化
    OLED_Init();
    W25Q64_Init();
    OLED_ShowString(1, 1, "MID:   DID:");
    OLED_ShowString(2, 1, "W:");
    OLED_ShowString(3, 1, "R:");
    W25Q64_ReadID(&MID,&DID);       //读取设备ID号
    OLED_ShowHexNum(1,5,MID,2);     //显示设备ID号
    OLED_ShowHexNum(1,12,DID,4);
//
    W25Q64_SectorErase(0X000000);   //擦除扇区，为写入数据做准备
    W25Q64_PageProgram(0X000000,ArrayWrite,4); //向指定地址写入数据，写入四个数据
    W25Q64_ReadData(0X000000,ArrayRead,4);     //向指定地址读数据
//显示写入数据	
    OLED_ShowHexNum(2,3,ArrayWrite[0],2);
    OLED_ShowHexNum(2,6,ArrayWrite[1],2);
    OLED_ShowHexNum(2,9,ArrayWrite[2],2);
    OLED_ShowHexNum(2,12,ArrayWrite[3],2);
//显示读取数据	
    OLED_ShowHexNum(3,3, ArrayRead[0],2);
    OLED_ShowHexNum(3,6, ArrayRead[1],2);
    OLED_ShowHexNum(3,9, ArrayRead[2],2);
    OLED_ShowHexNum(3,12,ArrayRead[3],2);
    while (1)
    &#123;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">MySPI.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
//对引脚操控进行基础的封装
void MySPI_W_SS(uint8_t BitValue)    //片选信号，SS也称CS引脚
&#123;
    GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitValue);
&#125;
void MySPI_Init(void)
&#123;
//GPIO引脚根据API硬件外设配置
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA,&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA,&GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA,&GPIO_InitStructure);
//配置硬件SPI
    SPI_InitTypeDef SPI_InitStructure;
    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;  //分频系数为128.
    SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;    //第一个边沿采样
    SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;     //空闲状态时，SCK为低电平
    SPI_InitStructure.SPI_CRCPolynomial = 7;      //CRC校验的多项式
    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;   //8位数据帧   
    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //选择为双线全双工
    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;  //高位先行
    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;       //指定设备为主机或从机
    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;           //配置为软件NSS
    SPI_Init(SPI1,&SPI_InitStructure);
//SPI使能
    SPI_Cmd(SPI1,ENABLE);
//初始化
    MySPI_W_SS(1);  //默认不选中从机
&#125;
//起始时序
void MySPI_Start(void)
&#123;
    MySPI_W_SS(0);
&#125;
//终止时序
void MySPI_STOP(void)
&#123;
    MySPI_W_SS(1);
&#125;
//交换数据
uint8_t MySPI_SwapByte(uint8_t ByteSend)
&#123;
    while (SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET);
    SPI_I2S_SendData(SPI1,ByteSend);
    while (SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) == RESET);
    return SPI_I2S_ReceiveData(SPI1);
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">W25Q64.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
#include "MySPI.h"
#include "W25Q64_Ins.h"
// 初始化SPI接口
void W25Q64_Init(void)
&#123;
    MySPI_Init(); 
&#125;
//读设备ID
void W25Q64_ReadID(uint8_t *MID, uint16_t *DID)
&#123;
    MySPI_Start();                              // 起始条件时序
    MySPI_SwapByte(W25Q64_JEDEC_ID);            // 发送指令
    *MID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);   // 读取制造商ID
    *DID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);   // 读取设备ID的低8位
    *DID <<= 8;
    *DID |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);  // 读取设备ID的高8位
    MySPI_STOP();                               // 终止条件时序
&#125;
//写使能
void W25Q64_WriteEnable(void)
&#123;
    MySPI_Start();
    MySPI_SwapByte(W25Q64_WRITE_ENABLE); // 发送写使能指令
    MySPI_STOP(); 
&#125;
//等待设备忙，并规定时间限制
void W25Q64_WaitBusy(void)
&#123;
    uint32_t Timeout = 100000;
    MySPI_Start();                     
    MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1); // 发送读状态寄存器指令
    while ((MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1) & 0x01) == 0x01)
    &#123;
        Timeout--;
        if (Timeout == 0)
        &#123;
            break;
        &#125;
    &#125;
    MySPI_STOP(); 
&#125;
//指定地址写入数据，
void W25Q64_PageProgram(uint32_t Address, uint8_t *DataArray, uint16_t Count)
&#123;
    W25Q64_WriteEnable();                  // 写使能
    uint16_t i;
    MySPI_Start();                          
    MySPI_SwapByte(W25Q64_PAGE_PROGRAM);    // 发送页编程指令
    MySPI_SwapByte(Address >> 16);          // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);           // 发送地址的中间8位
    MySPI_SwapByte(Address);                // 发送地址的低8位
    for (i = 0; i < Count; i++)
    &#123;
        MySPI_SwapByte(DataArray[i]);    // 发送要写入的数据
    &#125;
    MySPI_STOP(); 
    W25Q64_WaitBusy();                  // 等待操作完成
&#125;
//擦除指定地址的扇区
void W25Q64_SectorErase(uint32_t Address)
&#123;
    W25Q64_WriteEnable();    // 启用写操作
    MySPI_Start();            
    MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB); // 发送扇区擦除指令
    MySPI_SwapByte(Address >> 16);          // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);          // 发送地址的中间8位
    MySPI_SwapByte(Address);              // 发送地址的低8位
    MySPI_STOP(); 
    W25Q64_WaitBusy(); // 等待操作完成
&#125;
//指定地址读
void W25Q64_ReadData(uint32_t Address, uint8_t *DataArray, uint32_t Count)
&#123;
    uint32_t i;
    MySPI_Start(); 
    MySPI_SwapByte(W25Q64_READ_DATA);      // 发送读数据指令
    MySPI_SwapByte(Address >> 16);        // 发送地址的高8位
    MySPI_SwapByte(Address >> 8);        // 发送地址的中间8位
    MySPI_SwapByte(Address);            // 发送地址的低8位
    for (i = 0; i < Count; i++)
    &#123;
        DataArray[i] = MySPI_SwapByte(W25Q64_DUMMY_BYTE);  // 读取数据
    &#125;
    MySPI_STOP(); 
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">W25Q64_Ins.h</font></summary>  <pre><code class="language-c">
#ifndef    __W25Q64_Ins__H
#define    __W25Q64_Ins__H
// W25Q64指令
#define W25Q64_WRITE_ENABLE							0x06
#define W25Q64_WRITE_DISABLE						0x04
#define W25Q64_READ_STATUS_REGISTER_1				0x05
#define W25Q64_READ_STATUS_REGISTER_2				0x35
#define W25Q64_WRITE_STATUS_REGISTER				0x01
#define W25Q64_PAGE_PROGRAM							0x02
#define W25Q64_QUAD_PAGE_PROGRAM					0x32
#define W25Q64_BLOCK_ERASE_64KB						0xD8
#define W25Q64_BLOCK_ERASE_32KB						0x52
#define W25Q64_SECTOR_ERASE_4KB						0x20
#define W25Q64_CHIP_ERASE							0xC7
#define W25Q64_ERASE_SUSPEND						0x75
#define W25Q64_ERASE_RESUME							0x7A
#define W25Q64_POWER_DOWN							0xB9
#define W25Q64_HIGH_PERFORMANCE_MODE				0xA3
#define W25Q64_CONTINUOUS_READ_MODE_RESET			0xFF
#define W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID		0xAB
#define W25Q64_MANUFACTURER_DEVICE_ID				0x90
#define W25Q64_READ_UNIQUE_ID						0x4B
#define W25Q64_JEDEC_ID								0x9F
#define W25Q64_READ_DATA							0x03
#define W25Q64_FAST_READ							0x0B
#define W25Q64_FAST_READ_DUAL_OUTPUT				0x3B
#define W25Q64_FAST_READ_DUAL_IO					0xBB
#define W25Q64_FAST_READ_QUAD_OUTPUT				0x6B
#define W25Q64_FAST_READ_QUAD_IO					0xEB
#define W25Q64_OCTAL_WORD_READ_QUAD_IO				0xE3
#define W25Q64_DUMMY_BYTE							0xFF
 #endif
</code> </pre> </details>

<p>软硬件SPI的主函数没什么差别，只是将MySPI.c中的软件模拟部分替换成STM32标准库中的SPI函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//NRF24L01寄存器操作命令</span><br><span class="line">#define NRF_READ_REG    0x00  //读配置寄存器,低5位为寄存器地址</span><br><span class="line">#define NRF_WRITE_REG   0x20  //写配置寄存器,低5位为寄存器地址</span><br><span class="line">#define RD_RX_PLOAD     0x61  //读RX有效数据,1~32字节</span><br><span class="line">#define WR_TX_PLOAD     0xA0  //写TX有效数据,1~32字节</span><br><span class="line">#define FLUSH_TX        0xE1  //清除TX FIFO寄存器.发射模式下用</span><br><span class="line">#define FLUSH_RX        0xE2  //清除RX FIFO寄存器.接收模式下用</span><br><span class="line">#define REUSE_TX_PL     0xE3  //重新使用上一包数据,CE为高,数据包被不断发送.</span><br><span class="line">#define NOP             0xFF  //空操作,可以用来读状态寄存器</span><br><span class="line">	 </span><br><span class="line">//SPI(NRF24L01)寄存器地址</span><br><span class="line">#define CONFIG          0x00  //配置寄存器地址;bit0:1接收模式,0发射模式;bit1:电选 </span><br><span class="line">                              //择;bit2:CRC模式;bit3:CRC使能;</span><br><span class="line">                              //bit4:中断MAX_RT(达到最大重发次数中断)使能;bit5:中断TX_DS使 </span><br><span class="line">                              //能;bit6:中断RX_DR使能</span><br><span class="line">#define EN_AA           0x01  //使能自动应答功能  bit0~5,对应通道0~5</span><br><span class="line">#define EN_RXADDR       0x02  //接收地址允许,bit0~5,对应通道0~5</span><br><span class="line">#define SETUP_AW        0x03  //设置地址宽度(所有数据通道):bit1,0:00,3字节;01,4字节;02,5字 </span><br><span class="line">                              //节;</span><br><span class="line">#define SETUP_RETR      0x04  //建立自动重发;bit3:0,自动重发计数器;bit7:4,自动重发延时 </span><br><span class="line">                              //250*x+86us</span><br><span class="line">#define RF_CH           0x05  //RF通道,bit6:0,工作通道频率;</span><br><span class="line">#define RF_SETUP        0x06  //RF寄存器;bit3:传输速率(0:1Mbps,1:2Mbps);bit2:1,发射功 </span><br><span class="line">                              //率;bit0:低噪声放大器增益</span><br><span class="line">#define STATUS          0x07  //状态寄存器;bit0:TX FIFO满标志;bit3:1,接收数据通道号(最 </span><br><span class="line">                              //大:6);bit4,达到最多次重发</span><br><span class="line">                              //bit5:数据发送完成中断;bit6:接收数据中断;</span><br><span class="line">#define MAX_TX  		0x10  //达到最大发送次数中断</span><br><span class="line">#define TX_OK   		0x20  //TX发送完成中断</span><br><span class="line">#define RX_OK   		0x40  //接收到数据中断</span><br><span class="line"> </span><br><span class="line">#define OBSERVE_TX      0x08  //发送检测寄存器,bit7:4,数据包丢失计数器;bit3:0,重发计数器</span><br><span class="line">#define CD              0x09  //载波检测寄存器,bit0,载波检测;</span><br><span class="line">#define RX_ADDR_P0      0x0A  //数据通道0接收地址,最大长度5个字节,低字节在前</span><br><span class="line">#define RX_ADDR_P1      0x0B  //数据通道1接收地址,最大长度5个字节,低字节在前</span><br><span class="line"> </span><br><span class="line">#define RX_ADDR_P2      0x0C  //数据通道2接收地址,最低字节可设置</span><br><span class="line">                              //高字节,必须同 RX_ADDR_P1[39:8]相等;</span><br><span class="line"> </span><br><span class="line">#define RX_ADDR_P3      0x0D  //数据通道3接收地址,最低字节可设置</span><br><span class="line">                              //高字节,必须同 RX_ADDR_P1[39:8]相等;</span><br><span class="line"> </span><br><span class="line">#define RX_ADDR_P4      0x0E  //数据通道4接收地址,最低字节可设置</span><br><span class="line">                              //高字节,必须同RX_ADDR_P1[39:8]相等;</span><br><span class="line"> </span><br><span class="line">#define RX_ADDR_P5      0x0F  //数据通道5接收地址,最低字节可设置,</span><br><span class="line">                              //高字节,必须同RX_ADDR_P1[39:8]相等;</span><br><span class="line"> </span><br><span class="line">#define TX_ADDR         0x10  //发送地址(低字节在前),ShockBurstTM模式下,RX_ADDR_P0与此地址 </span><br><span class="line">                                相等</span><br><span class="line">#define RX_PW_P0        0x11  //接收数据通道0有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define RX_PW_P1        0x12  //接收数据通道1有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define RX_PW_P2        0x13  //接收数据通道2有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define RX_PW_P3        0x14  //接收数据通道3有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define RX_PW_P4        0x15  //接收数据通道4有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define RX_PW_P5        0x16  //接收数据通道5有效数据宽度(1~32字节),设置为0则非法</span><br><span class="line">#define NRF_FIFO_STATUS 0x17  //FIFO状态寄存器;bit0,RX FIFO寄存器空标志;</span><br><span class="line">                              //bit1,RX FIFO满标志;bit2,3,保留</span><br><span class="line">                              //bit4,TX FIFO空标志;bit5,TX FIFO满标志;bit6,1,循环发送上一 </span><br><span class="line">                              //数据包.0,不循环;</span><br><span class="line">/</span><br><span class="line">//24L01操作线</span><br><span class="line">#define NRF24L01_CE   PAout(4) //24L01片选信号</span><br><span class="line">#define NRF24L01_CSN  PCout(4) //SPI片选信号	   </span><br><span class="line">#define NRF24L01_IRQ  PAin(1)  //IRQ主机数据输入</span><br><span class="line">//24L01发送接收数据宽度定义</span><br><span class="line">#define TX_ADR_WIDTH    5   	//5字节的地址宽度</span><br><span class="line">#define RX_ADR_WIDTH    5   	//5字节的地址宽度</span><br><span class="line">#define TX_PLOAD_WIDTH  32  	//32字节的用户数据宽度</span><br><span class="line">#define RX_PLOAD_WIDTH  32  	//32字节的用户数据宽度</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32标准库</title>
    <url>/2023/08/02/STM32%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p>整理笔记时发现自己如果列举代码，会更加有效。但插入代码块到其中会比较繁琐，而且各个知识的代码的耦合性较强，反复列举较为麻烦，所以开一个新的文章，专门记录整理标准库代码。仅记录个人常用，建议参考手册，或直接跳转函数定义，浏览官方说明。<span id="more"></span></p>
<h3 id="时钟控制"><a href="#时钟控制" class="headerlink" title="时钟控制"></a>时钟控制</h3><p>时钟就像人的心跳，人的运动先需要跳动心脏。STM32的片上外设也是一样，如果要使用外设，例如：GPIO，NVIC，ADC等等，需要先开启外设挂载的总线时钟。</p>
<p>以下是标准库中对时钟控制函数的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AHB总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//APB2总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//APB1总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数为外设，例如APB2的外设：RCC_APB2Periph_GPIOA，RCC_APB2Periph_GPIOB，RCC_APB2Periph_TIM1等，</p>
<p>第二个参数为使能或者失能。（ENABLE&#x2F;DISABLE）</p>
<p>比如开启APB2的GPIOA为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br></pre></td></tr></table></figure>

<p>外设的使用必须先开启时钟。</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定GPIO初始化为默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//功能复用，重新映射事件控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//用结构体参数初始化GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//将结构体的变量，赋为初始值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//读取指定输入GPIO口的值，返回0/1</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//读取指定输入GPIO组的数据端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//读取指定输出GPIO口的值，返回0/1</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//读取指定输出GPIO组的数据端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//指定端口输出为高电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//指定端口输出为低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//指定GPIO组的某个GPIO并赋值（高低电平）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br><span class="line"><span class="comment">//指定GPIO组，并写入端口输出数据寄存器（ODR寄存器）的值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">//锁定GPIO管脚配置寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//选择用作事件输出的GPIO引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;</span><br><span class="line"><span class="comment">//使能输出事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//改变指定管脚的映射，为了更大利用IO口，部分IO口可以进行复用或者映射。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//选择 GPIO 管脚用作外部中断源</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;</span><br><span class="line"><span class="comment">//选择以太网媒体接口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ETH_MediaInterfaceConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_ETH_MediaInterface)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">//选择GPIO口</span></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">//选择运行速度</span></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">//配置G</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p><strong>GPIO模式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,               <span class="comment">//模拟输入</span></span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,      <span class="comment">//浮空输入</span></span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,              <span class="comment">//下拉输入</span></span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,              <span class="comment">//上拉输入</span></span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,           <span class="comment">//开漏输出</span></span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,           <span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,            <span class="comment">//复用开漏</span></span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span>             <span class="comment">//复用推挽</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>



<h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;                  <span class="comment">//设置中断优先级分组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span>;                           <span class="comment">//用结构体参数配置NVIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SetVectorTable</span><span class="params">(<span class="type">uint32_t</span> NVIC_VectTab, <span class="type">uint32_t</span> Offset)</span>;            <span class="comment">//设置中断向量表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SystemLPConfig</span><span class="params">(<span class="type">uint8_t</span> LowPowerMode, FunctionalState NewState)</span>;    <span class="comment">//系统低功耗配置</span></span><br></pre></td></tr></table></figure>



<h3 id="EXIT"><a href="#EXIT" class="headerlink" title="EXIT"></a>EXIT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI_DeInit</span><span class="params">(<span class="type">void</span>)</span>;              	                   <span class="comment">//清除EXTI配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;         <span class="comment">//用结构体参数配置EXTI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;   <span class="comment">//给结构体赋予默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;         <span class="comment">//软件触发外部中断</span></span><br><span class="line">FlagStatus <span class="title function_">EXTI_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;         <span class="comment">//获取指定的的中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;                   <span class="comment">//清除中断标志位</span></span><br><span class="line">ITStatus <span class="title function_">EXTI_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;             <span class="comment">//在中断函数里获取标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;           <span class="comment">//在中断函数里清除标志位</span></span><br></pre></td></tr></table></figure>

<p><strong>结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> EXTI_Line;               <span class="comment">//指定配置的中断线</span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;       <span class="comment">//指定中断模式</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; <span class="comment">//指定配置的中断线</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;     <span class="comment">//指定触发中断的模式</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h3 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h3><p>过长，具体参考STM32固件函数库手册。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TIM_DeInit</td>
<td>将外设 TIMx 寄存器重设为缺省值</td>
</tr>
<tr>
<td>TIM_TimeBaseInit</td>
<td>根据 TIM_TimeBaseInitStruct 中指定的参数初始化   间基数单位</td>
</tr>
<tr>
<td>TIM_OCInit</td>
<td>根据 TIM_OCInitStruct 中指定的参数初始化外设</td>
</tr>
<tr>
<td>TIM_ICInit</td>
<td>根据 TIM_ICInitStruct 中指定的参数初始化外设 T</td>
</tr>
<tr>
<td>TIM_TimeBaseStructInit</td>
<td>把 TIM_TimeBaseInitStruct 中的每一个参数按缺省</td>
</tr>
<tr>
<td>TIM_OCStructInit</td>
<td>把 TIM_OCInitStruct 中的每一个参数按缺省值填</td>
</tr>
<tr>
<td>TIM_ICStructInit</td>
<td>把 TIM_ICInitStruct 中的每一个参数按缺省值填入</td>
</tr>
<tr>
<td>TIM_Cmd</td>
<td>使能或者失能 TIMx 外设</td>
</tr>
<tr>
<td>TIM _ITConfig</td>
<td>使能或者失能指定的 TIM 中断</td>
</tr>
<tr>
<td>TIM_DMAConfig</td>
<td>设置 TIMx 的 DMA 接口</td>
</tr>
<tr>
<td>TIM_DMACmd</td>
<td>使能或者失能指定的 TIMx 的 DMA 请求</td>
</tr>
<tr>
<td>TIM_InternalClockConfig</td>
<td>设置 TIMx 内部时钟</td>
</tr>
<tr>
<td>TIM_ITRxExternalClockConfig</td>
<td>设置 TIMx 内部触发为外部时钟模式</td>
</tr>
<tr>
<td>TIM_TIxExternalClockConfig</td>
<td>设置 TIMx 触发为外部时钟</td>
</tr>
<tr>
<td>TIM_ETRClockMode1Config</td>
<td>配置 TIMx 外部时钟模式  1</td>
</tr>
<tr>
<td>TIM_ETRClockMode2Config</td>
<td>配置 TIMx 外部时钟模式  2</td>
</tr>
<tr>
<td>TIM_ETRConfig</td>
<td>配置 TIMx 外部触发</td>
</tr>
<tr>
<td>TIM_SelectInputTrigger</td>
<td>选择 TIMx 输入触发源</td>
</tr>
<tr>
<td>TIM_PrescalerConfig</td>
<td>设置 TIMx 预分频</td>
</tr>
<tr>
<td>TIM_CounterModeConfig</td>
<td>设置 TIMx 计数器模式</td>
</tr>
<tr>
<td>TIM_ForcedOC1Config</td>
<td>置 TIMx 输出 1 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC2Config</td>
<td>置 TIMx 输出 2 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC3Config</td>
<td>置 TIMx 输出 3 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC4Config</td>
<td>置 TIMx 输出 4 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ARRPreloadConfig</td>
<td>使能或者失能 TIMx 在 ARR 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_SelectCCDMA</td>
<td>选择 TIMx 外设的捕获比较  DMA 源</td>
</tr>
<tr>
<td>TIM_OC1PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR1 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC2PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR2 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC3PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR3 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC4PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR4 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC1FastConfig</td>
<td>设置 TIMx 捕获比较  1 快速特征</td>
</tr>
<tr>
<td>TIM_OC2FastConfig</td>
<td>设置 TIMx 捕获比较 2  快速特征</td>
</tr>
<tr>
<td>TIM_OC3FastConfig</td>
<td>设置 TIMx 捕获比较 3  快速特征</td>
</tr>
<tr>
<td>TIM_OC4FastConfig</td>
<td>设置 TIMx 捕获比较 4  快速特征</td>
</tr>
<tr>
<td>TIM_ClearOC1Ref</td>
<td>在一个外部事件时清除或者保持 OCREF1 信号</td>
</tr>
<tr>
<td>TIM_ClearOC2Ref</td>
<td>在一个外部事件时清除或者保持 OCREF2 信号</td>
</tr>
<tr>
<td>TIM_ClearOC3Ref</td>
<td>在一个外部事件时清除或者保持 OCREF3 信号</td>
</tr>
<tr>
<td>TIM_ClearOC4Ref</td>
<td>在一个外部事件时清除或者保持 OCREF4 信号</td>
</tr>
<tr>
<td>TIM_UpdateDisableConfig</td>
<td>使能或者失能 TIMx 更新事件</td>
</tr>
<tr>
<td>TIM_EncoderInterfaceConfig</td>
<td>设置 TIMx 编码界面</td>
</tr>
<tr>
<td>TIM_GenerateEvent</td>
<td>设置 TIMx 事件由软件产生</td>
</tr>
<tr>
<td>TIM_OC1PolarityConfig</td>
<td>设置 TIMx 通道 1 极性</td>
</tr>
<tr>
<td>TIM_OC2PolarityConfig</td>
<td>设置 TIMx 通道 2 极性</td>
</tr>
<tr>
<td>TIM_OC3PolarityConfig</td>
<td>设置 TIMx 通道 3 极性</td>
</tr>
<tr>
<td>TIM_OC4PolarityConfig</td>
<td>设置 TIMx 通道 4 极性</td>
</tr>
<tr>
<td>TIM_UpdateRequestConfig</td>
<td>设置 TIMx 更新请求源</td>
</tr>
<tr>
<td>TIM_SelectHallSensor</td>
<td>使能或者失能 TIMx 霍尔传感器接口</td>
</tr>
<tr>
<td>TIM_SelectOnePulseMode</td>
<td>设置 TIMx 单脉冲模式</td>
</tr>
<tr>
<td>TIM_SelectOutputTrigger</td>
<td>选择 TIMx 触发输出模式</td>
</tr>
<tr>
<td>TIM_SelectSlaveMode</td>
<td>选择 TIMx 从模式</td>
</tr>
<tr>
<td>TIM_SelectMasterSlaveMode</td>
<td>设置或者重置 TIMx 主&#x2F;从模式</td>
</tr>
<tr>
<td>TIM_SetCounter</td>
<td>设置 TIMx 计数器寄存器值</td>
</tr>
<tr>
<td>TIM_SetAutoreload</td>
<td>设置 TIMx 自动重装载寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare1</td>
<td>设置 TIMx 捕获比较 1  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare2</td>
<td>设置 TIMx 捕获比较 2  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare3</td>
<td>设置 TIMx 捕获比较 3  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare4</td>
<td>设置 TIMx 捕获比较 4  寄存器值</td>
</tr>
<tr>
<td>TIM_SetIC1Prescaler</td>
<td>设置 TIMx 输入捕获 1  预分频</td>
</tr>
<tr>
<td>TIM_SetIC2Prescaler</td>
<td>设置 TIMx 输入捕获 2  预分频</td>
</tr>
<tr>
<td>TIM_SetIC3Prescaler</td>
<td>设置 TIMx 输入捕获 3  预分频</td>
</tr>
<tr>
<td>TIM_SetIC4Prescaler</td>
<td>设置 TIMx 输入捕获 4  预分频</td>
</tr>
<tr>
<td>TIM_SetClockDivision</td>
<td>设置 TIMx 的时钟分割值</td>
</tr>
<tr>
<td>TIM_GetCapture1</td>
<td>获得 TIMx 输入捕获 1  的值</td>
</tr>
<tr>
<td>TIM_GetCapture2</td>
<td>获得 TIMx 输入捕获 2  的值</td>
</tr>
<tr>
<td>TIM_GetCapture3</td>
<td>获得 TIMx 输入捕获 3  的值</td>
</tr>
<tr>
<td>TIM_GetCapture4</td>
<td>获得 TIMx 输入捕获 4  的值</td>
</tr>
<tr>
<td>TIM_GetCounter</td>
<td>获得 TIMx 计数器的值</td>
</tr>
<tr>
<td>TIM_GetPrescaler</td>
<td>获得 TIMx 预分频值</td>
</tr>
<tr>
<td>TIM_GetFlagStatus</td>
<td>检查指定的 TIM 标志位设置与否</td>
</tr>
<tr>
<td>TIM_ClearFlag</td>
<td>清除 TIMx 的待处理标志位</td>
</tr>
<tr>
<td>TIM_GetITStatus</td>
<td>检查指定的 TIM 中断发生与否</td>
</tr>
<tr>
<td>TIM_ClearITPendingBit</td>
<td>清除 TIMx 的中断待处理位</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32综述</title>
    <url>/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>　　大概有一段时间没看stm32，通过之前学51的经历，大概是明白自己一段时间不看就会忘，虽然随便翻翻又能快速上手，但是东找西翻比较麻烦。所以打算复习的时候，顺便做个笔记记录一下。自己所用的型号为<strong>STM32F103C8T6</strong>。<span id="more"></span></p>
<h6 id="STM简述"><a href="#STM简述" class="headerlink" title="STM简述"></a>STM简述</h6><p>　　STM32是ST公司基于ARM- Cortex-M内核开发的32位微控制器（MCU）。自己所用的是STM32F1系列，属于Mainstream，内核Cortex-M3。ARM公司设计ARM内核，半导体厂商完善内核周边电路并产生芯片。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104303863.png" class="" title="image-20230724104303863">

<p>图中的ARM由ARM公司设计，芯片内的存储和外设（比如GPIO,定时器）由ST公司设计。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104427576.png" class="" title="image-20230724104427576">

<p>这是一枚STM32F103C8T6的芯片，由芯片可以看出型号和封装。封装为LQFP48，芯片表面左下角有个圆点，圆点下的引脚为1顺着原点逆时针开始数。如果芯片有两个圆点，则从最小的圆点开始数。</p>
<h6 id="片上资源-x2F-外设"><a href="#片上资源-x2F-外设" class="headerlink" title="片上资源&#x2F;外设"></a><strong>片上资源&#x2F;外设</strong></h6><img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104939703.png" class="" title="image-20230724104939703">

<p>绿色背景加黑的是位于内核的外设。另外C8T6并没有表中的DAC,SDIO,FSMC和USB OTG外设。</p>
<p>NVIC:内核里面用于管理中断的设备，例如配置中断优先级。</p>
<p>SysTick:用来给操作系统提供定时服务。应为STM32可以加入Freektos，ucos等操作系统，利用SysTick提供定时进行任务切换的功能。</p>
<p>RCC：复位和时钟控制，可以对系统的时钟进行配置，还能使能各模块的时钟。在STM32中，外设上电后是默认没有时钟。没有时钟，外设无法工作。</p>
<p>GPIO：通用的IO口，可以用于操控模块，比如灯，马达等。</p>
<p>AFIO：完成复用功能端口的重定义，还有中断端口的置配。</p>
<p>EXTI：配置好外部中断后，当引脚有电平变化时，就可以触发中断，让CPU来处理任务。</p>
<p>TIM定时器：分为基本定时器，通用定时器，高级定时器。不仅可以完成定时中断的任务，还可以用于测频率，生成PWM波形，配置为专用的编码器接口。</p>
<p>ADC：模数转换器，STM32内置了12位的AD转换器，可以直接读取IO口的模拟电压，无需外置。</p>
<p>DMA：直接内存访问，可以帮助CPU搬运大量数据等这种繁杂任务。</p>
<p>I2C&#x2F;SPI：两种常见的通信协议。</p>
<p>RTC：实时时钟，在STM32内部完成时，分，秒的计时功能，还可以外接电源，即使掉电也能</p>
<p>正常运行（此时会启用芯片备用电池）。</p>
<p>CRC：一种数据校验方式，用于判断接受的数据是否正确。</p>
<p>IWDG&#x2F;WWDG:当单片机因为电磁干扰死机或者程序设计不合理导致的死循环时，看门狗可以及时复位，保证系统稳定。</p>
<p>DAC：数模转换器，可以在IO口直接输出模拟电压。</p>
<p>OTG：使STM32作为USB主机去读取其它USB设备。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111613998.png" class="" title="image-20230724111613998">

<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111625157.png" class="" title="image-20230724111625157">



<h6 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a><strong>系统结构</strong></h6><img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111735194.png" class="" title="image-20230724111735194">

<p>ICode（指令总线）和Dcode（数据总线）用来连接Flash闪存，Flash存放的是我们编写的程序，ICode用于加载程序指令，Dcode用于加载数据，如常数和调试数据。</p>
<p>系统总线就连接到如SRAM（用于存储程序运行时的变量数据）</p>
<p>AHB系统总线：用于挂载主要的外设，AHB指先进高性能总线，挂载最基本的或者性能比较高的外设，如复位和时钟控制  SDIO。</p>
<p>APB：先进外设总线，用于连接一般的外设。</p>
<p>DMA：大量的数据搬运，防止覆盖。</p>
<h6 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h6><p>红色是电源相关的引脚</p>
<p>蓝色是最小系统相关的引脚</p>
<p>绿色是IO口&#x2F;功能口相关的引脚</p>
<p>S代表电源，I&#x2F;O代表输入输出，I&#x2F;O电平代表所能容忍的电压。FT代表能容忍5V，默认复用是IO口上同时连接的外设功能引脚。重定义：如果有2个功能同时复用在了1个IO口上，可以把其中一个复用功能重映射到其他端口上。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230726084013246.png" class="" title="image-20230726084013246">



<p>1.　　　VBAT：备用电池供电引脚，当系统电源断电时，备用电池可以给内部的RTC时钟和备份寄存器提供电源。</p>
<p>2.　　　IO口&#x2F;侵入检测&#x2F;RTC：IO口可以根据程序输出读取高低电平</p>
<p>3.4　IO口&#x2F;接32.768kHZ的RTC晶振</p>
<p>5,6　接系统的主晶振，芯片内有锁相环电路，对8MHZ进行倍频形成72MHZ。</p>
<p>7　　系统复位引脚，N代表低电平复位</p>
<p>8,9　内部模拟部分的电源，如ADC,RC振荡器  VSS(-) VDD(+)</p>
<p>10-19　都是IO口，10号引脚还兼具了WKUP用于唤醒对于待机模式的STM32</p>
<p>20　IO口&#x2F;BOOT1引脚，BOOT用来配置启动模式    44.　BOOT0</p>
<p>21.22.25-33.41-43.45.46 都是IO口</p>
<p>23,24是系统的主电源口， 35.36.47.48    STM32采用分区供电模式</p>
<p>34,37-40　IO口&#x2F;调试端口      STM32支持SWD和JTAG两种调试方法</p>
<p>启动配置（BOOT0和BOOT1）</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230801140258741.png" class="" title="image-20230801140258741">

<p>作用：指定程序开始运行的位置，一般情况下，程序是在Flash程序存储器开始执行</p>
<p>接1指3.3V电源正的意思</p>
<p>系统存储器就是STM32中的一段BootLoader(接受串口数据，然后刷新到主闪存中)</p>
<p>核心板原理图</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230801140602387.png" class="" title="image-20230801140602387">

]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>？？？？？（未解密）</title>
    <url>/2023/09/26/Shelter%E7%9A%84%E5%9C%B0%E4%B8%8B%E5%9F%8E/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="啥？你不知道？不知道还输。你到底在期待什么？？_____:(´□`」 ∠):_____蒙暗号是没用的，或许你贿赂城主（博主）能满足你的小小好奇心¯\_(ツ)_/¯" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="151666ee28324a54c044c220ad6c31003d874ae5170ce84cac0e37bbf235abb6">76fc3ae391b3c4b89afc7f8f81acab4b15ef348badba32d631cb6a8bda9a353b3df6685bb0cb52671b4ae03ba31ac9c55692238271ae366f81a82cc7e6edb7f9e0c3258b3390e2ce586c563c679fa2ecf3ff0741f1e7564d9a8b0bd72377be614912ad34a5249f989f65e01fa7c82bc81d5a74f2661261b2551e2b7213b27aed5bb750c9645564cb1981a75f9c6763ffd0daa1631488ab2dc47c6b2db185c626cf33e07751a6d72d56ace985a3de8a2cc487fb34a37d7bd3aeed4fb7624e88c5a9ca9b04ccec285d7f062c8beadb8c4c9619ed0d9527c9a25033194d35edf027a7652ebf184a3d04266607b6b350be6af2c4ac8af7b10a03d401b8e6c4caa989c9aa6d526e770c1bc6355a70029b1995146d001924a602ed39eb08ec32e430544af8c0dfd51ed1693209d88c1583ece50a780181b1d0845eed51f61351630e01b9e98909a420960be6e29e2a737a476d7ed5e1da6cb81d0493b842a6b770464511c1ddd8a600e4fea8b0cb09dd6b5781aef0845778de619cee9d97029dc3035c8a82bcb8acd1ddc1f7a64244bdfd0526e212c4a5b1d4427f873036385dcbd14d77bf2b4d2cfb09d15aaa8841a0736e7d3833a01b7c6142d3179926b90bcbaed212d2b1e7ce2c39926a65d1079617931ccfb33ce52a5295141801a5140d87be9cfc2296b1965ac345c59c1c04e2aad0683181985e6eb365b4091017c4edca0a59616c2f74a0e1f2613a1c885de584efaf6fcfa0e29d09480b3f23d2a59bb089184908659de0addda47d996c8f2e049d9dcded7a8aa8a2f7fc4349f1e0a61ed458f1bf4311b7e19529d8e125442a7d00baa76fff1fa868ec6725ec0041aa1b7285be855a08b5e41dc5524022388cb12cfc7358ec07a72b03ef81bdbada1bb1e52bff03e52a76ceebb0152ea6b670c961c00e2e5755eed6bd1a219ab5a5830c7506cd85ecb3fddefa4c4f54673a6ce462a21f016bf3a140a544d6183a6fd334dcebf045a54c5e3fe6e31aa132ee8dd74b93f96be90843c29e790028bfa8607e0e7717eff495d11b75fa2e0374cf35b7b4f728324376649feb3e9a40220fa9eb6f02483073cfe9434013447d38a578409ed4ec8ebb74cff7fc026b52d47495d206b47ae1bfb916a2d85fd664990b6c88461b7dbb19474332b107ff0812dc741a2db8f4051f1ab971ea300db48a9ca0f750bbb7fca39755163cb9d02a3b1ce7756db8f0b7fbb6969b247b7e4c09eb2e93467d8d1327caa040f6bb0ba8ace3b29100b993a0e26147d30746cdbfcb5b2ddec676da0fcb2dcd1c5e271795c5c07d2fc572e6891c905f9bf8854478c6e3639931b66b792e1aa2254847fd32c8fc8a04851726bb45e9e21b03c09f33d597a8984cd53f8efb2db73fe75860710cd1a61e32672f292a84134b0bbe2d728ec4d7b3e352b7b303aa8a0afe7001a4a602eb8e3b3c926c2e8d13476e0ae1be4ebf9b51f7a4f59dc8a046109d37513334af401a67349be8bc06b27b5f11c7f42ee8df2935b003a8ec06b8ba2bd104a0ad2b33f63477c03528df05fd13319de8b027bbf3524856b006e8d6c8e4ebc5aaf0ad88b1126089730428a7778945b238991b269c4f62b32b1b9034fd4fa2b5a13b0981057501f157199e791a0fbc014f311953017113f5e9325baae3a457ea88a5458105a5c57888be58feef28204e02c594510c87be5138f60fe0e5d6af0fb655f0b6b8432770aa82061b80f331f3896d0105473f09fa92f994e3664ece32ebc317ddf4e7fb053758a12ede10af5cea1752afbf4554509228939a47d14ac6acef5c186cd3f574c3aef11cab1c52c817115898164463dda4acc943ab801bb42e0c7d884939cd12418924d06bdaa993b9ffa4d0a1486eb11d1e0961aa6f0a1dd5bcc97d96829a6eddbf4fbce5bfb581c57a5d01921d9ff508c0d6e3d4ab2e206b5e35057191a0dc619801c3cb18b2d5c2743f48b9f8175a565da0352fa8762be722801dbc1e4e0eb49c24eb91d78e2aa659cf735e196eec66b7ea569879706bee4f6091393c66c4539d60500fbc8c65422c7f83284a60e1a69f23b6081390e1bb694090480dac785f9512612f695b7efdd2e70ca45c6a75d5e25c35678ba4cf90c1614e8dbe233ca5df889fba4cdbb3be1f4d62b25a6e4fd26ff67fcf7da6d95994b7554532902a3593d1ea18e71e2997b641c7a96f95d21959697f7d647fb01a81b105d1b0991c82176ff465f1913fb2df3097da5fcd5ba80fd309dbe4b08df04983f28f07f314018d8f9630be900708d024a83eba262a5c8d6e50e0176670c7436db2c61c4ae779fde7997b6a59c727c668cb72c76eff9c847260587c00dc8edcf3a4075fde838544e3410e4c3d83ec8e954f1680ec0c7d471298b40736cfdb08813a57b9b611ca1fe2af84dd8eff9b8e1215bf4ec13c2b930e3ddfb99f0d8f9b35a7e2c709a076d5ec87da2c9409aa752524fcbaaa358c42b3adb1b40c154075cd87531b277498a7ce967bdd5ec99502a8cba56b769b001917597c2442b4e8c97e6fb4a32857059a0041a551c4d1e360592e008b224df43eb504511e60d9c4d471cf78c1470a876d4c65b329f30032d4887477f0ab809c09c891512ac5b5a50633813b28eb3ab593855cff42fd7b613d821123e99a43b8b68bf5a59b8ed3e40fb045216ff4eb2a7ebdae75463b6dffef29357ae950ea14950bdcbb3898cc86dd527fe518ea98580db4ddc0bde37100b6641db193545eed3f99de8efe05a14e3dd4e6b3c0031b7e818538e134d5ed800e7dae84dae084c3d54364c3db59e5f7d9a3ecedd18b43d3792e5ae74abf074cb6bfb4fbe85769501d2268d9bd0b300a700b82263caec6f18bca64d3031c1bed99b15229413c0c78a30b7e6eb6951e4f54099aff93f74cc2d236f169cf36705e12a326ceb4a8285312bb4a6bb726d945251e732e9074a128cd1678f009f87a77212030559122a36225567fc4bd35ad5d169bd64e4546df0bc2c85f3de9dd97f24d6c3769a83a28255c702b8bf80b628b92dfc5cf7e9410b2e366665081c61300396fccf944aa17b18ed015faa49185e99f23df6af5d351d81dc823ec5373947c392af8c18607ba1bcd0e2377462fd7ae5fbb53e4ba040415ec7b269c1c7e6fda3fe076b40e3782fff784f48b8b92ce80a694b7ab01f190617e46c74cad088d4484dd053ad241374e8d198a7e534bc17cc3f8fe49117b599917e1d9782944a9397a874cc9d2a803863b23a6cf9444c4158a0bcfb5792858229a79626bfe5eb414deab363e7ec6f509393482cd5d6e16daee20e25d9e4e3fcc079fa75248142a3a7266be20f215150a5525f6799a904ca3240583a3bc7b8ce4257c46bd3f03a8270c8b5b51145e73268125db3752993caf18f0777ea7f487d8b7c7dcba5c59fd5c9927272de2276a8ddaff18e0180e6bbc89f1614e4f7f702842e26191dae16b1fd49cec99fb06961d4fd11b5c715cd62e9862e3868a220199f5b03454377f9de8c6e2e3175e807cc52d283318d5050ab11247dbff6f1ccf8c4453a58374367d1a984a5dd7fe3dcbadbf4f7886b2dcbd6de6168efdf5d513673184bee3e47094607918f6c0c6d1cdce2dfe246da1b8e9e5c2cccadc00c55a99fa2696d1bdf21ebb928d7b1d7442d1641690a09f5a124fa8e1b8caf9d9a2662f68e71ff4cebc1d95d9f3ce3ef904b2f8cb46d79b7a9d4f1ce29c0f13f8b0c272e1d5c6363df25623bf5b07300f93c6ac26dc9b606b1f006445cd9b28fb23c6d96b0b488fa425149be8a4c8f02501e74bd634a937db09f647c5bf08190f0cb9097d920d38d4a2c6c9dde02d0b5e1c1c1558fe1165e0d94b19b7503a6bc4d8d0931a1be7eaf2e72bdfcd9b0b537cfa9e189c0f703990e1ca8e6f3569b95788f1ea0c1f6f39550d05653e12f3ce3c7b47585605ef3809e95845c7155b85a07e86a2fa669d9f2741669fd42b0a28b914f4ffb444c578f108cdb69ca02d8b2b47e7b60d09270f76cd1721509c8820f989eddcd7092d54baace0f330fc3268c3fad87c015d9e11b1b83be4dadfa5c570e577cfc97d8a12efc2ed9138ad7a09c086ce7767f181430e69e107a273211bd50e1020c6d704d8a2c57da03d5ea97c7da7afa572a70ec8c6153081df7c2131851f3fb6bdbdefaa7a5a997309370dd4efe2f229062985e89e60d5cad27f0a2982f3b50e2a28afe3984f60a8d5ac7e2b3e9ae91aa53de91a60969d4b6bdcd1e1add5978afa15e75cd33740be585e375ef2f1f901e0c864b23db5564ad4c52c817e886d704fcba736554e618c0f018b7bfe527c755cf9d2e3105a25ff21568fff58ba73477f95fa5ac2a8e2868b62cf191bc6bfd3891842658aa76c3f81ce028ae5a09b5e89d0551c46d836c96a436178ddadf2e9fd227a9476defd1c02daf683f8fa96cdb4a51cc6a80f595c7824fd37a176ae95cfcf077f9ad3d6fe150b21b5fb929335a688a80f38ed46d1972127e3f8c5e0cc446afd3958f80b1211e404f06a0ce50152ebf9dcba08659d83f8adfb5b5d78be398eb83d0d6d0025dd04c0f168b5e083ea4a62251faddd304e5d348cdb4aac058e883d5b674bdc7e0ae0714621b9909b8e8888a16ae4afde66ab13ad22bf0ede4927c8472fd4c3b3c02a5d0b01c7a983de48595e34a1ab70c14ad54d2818245a219419af192ee649d728554e1a0dab58e99db168f2a5e2da0967a44c61a5e5e90440f608a1841eb65daddce2c4b653d735af048e3cb4d1fe6db068efe6a404f4103c20234c8a868fdefa9a88e5c5c22cabf78edc4918ca84cd0d5be1473bb2ab4b3a0d31630fa08f9b3edbdff7d310d3f7beda8e047ad6117a7d4e2f66895cbdec20bcb7a264aa13a017f0968019cb0a56b7ac505e995eccbf87b7801c39438286ad445c0520996376c2f756bed1217f1f49c47948a1e0c06f2768b166ec05ebb957d41d6f55638cadfd3e689d1597843d207b2aada16a8c70e5dbd96018cb787b8ce9c4f4f43062893cc23270aaa4c85d1171923aa2e51bcbb14d607ba6fb89b56160dcff2ded9cfb065890ffc9f70cdf6dd58d54c109c819a9bf7a93fa2ed1315c2750b284bba82f5a4ca241ae6b52f2b32672b3130cdd19b034dbe67aac18884d731562210b3a873ad55abecb9cbe4c94f62c2f52c36e5e5b3d3abad7ee12665681beaa3bd22690b145719416bbb2d6808faa4f261fcacbf9247a51938071b66437b8b545e171ee4a6f28bb16f8a48da35b0f49dd9ba1b533075c2201b81e8efa1957cd76818c8bc8040587bf9c44aee91049f25013fa3318489e373fa85bff6aee27f2d31c9c3cbb2a19e85c159258e50a274931b278df8452c507c3a02f78fe965ac49c85d8cc12592b7b9548b2d001f755bd4bac332cbef2ff949fc75d12cf1d73aaeccf644d39af9ff48e221598e330f888808c913ace444258d6ad49642c7afe4bbfcaf17322c230dce8aa4aa0a747bbb38e62c0f87a0c0db2a7f0e2d8d905fe60bec784638f2c813fd256fe047c5a98ebdd5d4a9f33056346732420d7848a99605430787d6dc70660c9dfdb1c0ddbaf40b7a1af54c184f9e49d546c72a66cfb67a4e58a9f6d6707028b7ef591f5d4e36ac131ff3da612b120168e430838f93bacd54fae72da66c22370e3c3054a8a4ea80192d44680356ee08b531cbd69493ee6304910ff42367ba5ce1e9e87e831a8ff2a744cd420ded1fe418131dbb71b63adf972c5ec069bf7c82cd54ddcca0d89e84e4d67c6bdc7bd3a04ef071a59e798d1b8aaf5cc0d9b5505d5c0d023d16dc2bd29e0f24d9cf8b81aa569d3c507282ebfa57e6d4b960d7f1ecb55c40c1ff231b058c0e7454ac5558dfdfc78793108c173b7d16944da3983db566671eabcab1ecd859c7fa7b32c6407d5ed227509dafabcd5f72e4d1c6de7e8e817d6c2bd84a5eaf42502b23859324e9da27048ed1714df6d82956c0451b2c79a3e56c26263cb56d9631f63af2e0f458815be4d7f4002c522059ba7c82c3034bc91dd6a662bcfd1bb5649c465629bc9b893ebf1808d1dcc7feff178ab7242ce334d19813f625444620fd2af0a6e054c54b937bdf30b717fb6cf4e791b09d6aba9447cf31a540b54ca7d4e9e6fdf5d6584de8b91abbc328b8eb32d4f5fc46e51068f7fd911549256899a14aaca73abdfe40445725810b1e22d00a6b4d755470780c16d863d616e53fa8d09872bdb3a63d933d8902fec9e00e7ed9970b7b3a6d891353439deb9ec71fe793bb5db1777fb58039aeb55ad3510596e54965c2afa1f80ca4b65d53c90f2e16ae2173ccd6810bb04c73d74ddb371b0bfcba6dec02ebe0d92d154bbfd67a38ad75b2db93441fdd1a9e4258228b00ad996aa21dcfffe2983da07ea4d451f2ffcf64fbf9434998928032cf123fa3707ee2c1c2f242fde24bc10852fdf5e40828305e6acb9aaf5f5f843f1ed68e71405e26dc7795ba691b7f05a501e3006b923624c42186957760485c2ab5e4d0d5847eb624603475f1aa2448ca36ba6db8121fc53f69118090386cc1b0c002f2002b58715439ca363f1155cbdb7b22150bf932a892c648e73fe9eb4a48ad0b6ceadb1927a6fdb219fe83ba3d8fb76afcc37f595eb83dc8c7b0d5b66934c6d35d5602fec9c7bc30e959eea7371239b8cf9a0fb1769a543f780a691d17b8e264d901ebf8ca8edcdbb1c1d378576a48ea300e481a9670709f1c4f94ce1cdeeecf8821c9da6e7af1b4803b6e0a307f89de61fd4c64c3a78eae7d94eaeedc194744d4d02567f1d3a978fcfa8057226cbc828cfe68542d70ef8094e4caa5764824a0dcbc9c12b11602dc744269c5acab5d658a6cd7fc8504b546abc8ae534ed9e11d31ff948ef18952f22d25e162b9daccd64416223bc7a9711f745cf0091e8acd35afbeb5aafebe0276965f9409dcb983efeff9916176c51853d2b5cc543286716e39fdc1e1463fb40114b39a4bb09c57a7b01bbd233dcdecfb378b1ded09b68769a45ae4289128a87317cb28d0465104307a838c55600f66b4dcdfa2ac367a9dd9d4430cf3e24e2efb83f293d69baac849b11aaf5fecc2aba7c23e958e82413b0598135ab1c286c5f3382f4d9307255f957b894ece30cf9c568d354bdc141a181dc183217510184e2acb79a526c45a92a372f08e55397bb1604197959f4dc5a63d9cec80aa947d4d581fd33d1be4b40facb836c5d4e75d07657139448827f7012b7501e537c63c7f58d9d88e5e2d7a6c41696292e209c888c353ec3d4d39874891d552cd12afc4b26c4ccb5ea4107938f9c2f3b03e02bb82b59d3c2cba615947ef2a0fb70ea56390f3ef3b56abace31600b9b61b6f7d14c19557873c7c33983e8c3f4ea3cedecba529180d4f24a6e586f18c8d06b278ce759bfcb17c6e8a55185acf7daad573175bf54131dd9f08fa0854522e05fd4561d5b041db0ed6b60daab15337d3fda478eec2dcf62f24ca43c8734175e48c001a01b937a4d3e2e120e4ede229ce3d0350aa46d12089b97135683fb7574c7ec1133fa7d64c43d960771bfc116eb8990e3b958c23f4cf9c1420bd87b3c7463af32372140c93f17ba65853ca4f9e95dd07edcdc7f9d0cfa0101dbb067d9b8ff22daa4884b8fc604413d936a538b1ea2112c539ba4b18036a3f5757238faac3517f7ee3842311495cdcb7f0b8817db7e7f8186fc655010dba5f71a2fbbec861dc30fcbee1f44ab40fcd26ddce9744fcd3f8312b504fda35963edf4bdd53284781a927d3d04333c0a8da866eb93f70750bc72366df1192a2e8337401ff01f4ca3b62cc69a228048657c80377ba6e177a59a07cf0ab1339e0a1612c8dca60919b1e156e863fb5ef7c0129ba84494adc3273541c6c629da003cc50d29684939d41022ca8cf5f3f6759615aef886cbe6682cf4245d49b5b22527ba836f8881b344b3a9ac1f05866c9d4c5052df17d755d05928faff702d0677dd8a3195518f894edbfc59945b67d0adf65c2fc3fc1f7879cd32162a4781b6c760c2ce3b5fbbe3defafc567023b9ac5a8991fdadf3dd3a3236e5061f13ab0b4849fe827978c97160f3ce8431b261ade29b18a81915e26533c8cde4a276e70b7b722fabcb5c19d2d28fd0ccd6ae2021f874fe99df8ceaafcede5834b923bb1bb7b55ce1b409c6a789358847e087c8b79e582bf76d555bada70b29c78c794bd43f866ebfde093fd4adcd893c3f69aa131adc758dd87e32bfeb732bed1cc8c5b736edb061e703b3362eebc6f4c8b599151e733a711a24d54c99a44d8d990e2a61074a43270e2929b512c0e2cb0dd81df9923bb97b31ae2f068811eea14f6952d64dd948e539916e61ccde84b580c4e69c0ec098a6c903f41a957ee7dccb5b585d953a0758348392afa412abd4d9b26d6caf0084e24c416240c72222f0f4b086d4b227f4f84a1e023b20e886046c8694871b940a81e049d7cf1b13b73ef94455dd4882c6637349b433df246d7ed39ed32a8f83666f39a9cde254a078304cfc62d6ef463f85ca9ec2fcf8dc8c31c64dbefa6ae8f029667fd0e1f1e5252407c313376d0fc8501d1ca5cfa781c4747bfe8c472234e39d444e29f39a84b3bced00b79ef2943ab8240665937df110a7991968f43cc59ec3e33bcca192aed0ab67fbed089deccd2c3eccb810023d272fc3e8b126819c59754a9fcb2e50737348f2a699cd49c253489e797aa2cef5e6b5cc3ceabfe882780f7cc1c18e5183713bcb18a579956e215e637364b8264e6b6fd8c3da8ee1c0bbaf9fbb023bdd0b466f012e79026c411855b5820877a29d60016d8451ad59757cc7c73ec7c9b4831bb995d863426ecbce24629ba4a93b4e6451947b3013856f0c90dd80ad33ad72d2f8891f0c7d53a444dd9517d1545202d2b547edca91261578f4c370ca65e7f6ab0485c67973a7204c21b729f329b74ed5ec04968bd652a1260d6d474352aa3d7e3ce53e3818c75763ddda7aec322fe0c7ad719c87c8afdcbc438d8e3822d9e5fcc43c9adcfdf4583faa5ffd308d6a66c915d2b59628d98b264ae88ca262d0c0ec9fa9c71fcf82d12c82a9fbdb5d12cadea9b0dc627b8f0f1bd207752acf7c717ee45458bba54f94a78c273bce334fcbe38fca60882619be3ce10bb8e674abe91c84bd71b7ef2c1386316f8b65111b290bdbc9e1f2d3e1394108d8ff2d093bbc197d6b746d8b4dc2435bde1e74e974fa61ce8799fa655d11a8fb7a0da5e92760ccf2168edb4f3a1d4e560fde34ef7938dd187b47d120f4a731f7b05c77a81cf37ce4733df0c4cf0e7d3fb2ca919c390514db1fccb95fddf4eb1c908210b89a092a19f83bda8c4a4f178a37e019d9a8b44500cf88ed2588ff4bc457774d69335333f67148cf595a0437cf9287f7a24f4e6b099c32ac63cf13de42a78a052c2e22f47e7bcabacacd38b51b28497bac0165e4dbcb1e15119076c16162313af379d52b1f971145bca439b647458b08b576eb0ee6554a865535a551398a84f8f1c8dc850449be1f289a9ad2187ea7cad617ed67871024dd22269a2da74d18497318d28beea1ca4ecd4691911a8549c01aa0fccd95edce34c5f2aabc70e8784039218f5e3c5764b62d51af478756ade6a2ff177f5173ceac02d1399fc5f09d90990b2894f778f37b26ee8fb58fdf073907022c01ec494afb5d2f5ad21ebd584cd8462d9f8f386d26f79d3b340562945702ce39b1cb0c7fa9084646bd8ea503573e2ca659c6d658bfb6452e6d8723642fcce8d2028f6c1dc20c374af3b8c4cc7e7642ac9a7b46d96a8c06c4ccb83b494bb3f55c827f5c66e165fedcae76548dddc563583303c8cad6f48a1b96cff8997edb06635d387c90bf7074856fa83b034118e0be167b67052549c310a27e485c6d7721aec8d483da1ca510a980320cd7d4e3b7b99ce2147aef03afefd05daf5be52c93eac523aadda9ad96e0acdf8fd0f6d811267d9812667d91e28a1b92ac81ee07145fdc55d97ccdfa8820bc2369275bb0db6979015d3baee83559b1355321abe3b6231823f94826a9fe0961e46acae2759004625ef7f5906a7073daa6a3327d423b96170cf93acb86f51fc8351f91f792bed30952621fef39eafe445301259e619cbff71b4611da370d036537e900a0958d3ca57f17e8a90dc333be5cb52db60f8e75ff09ce1ce5dfbd1b041b8d4cd58116c5d7b431cac26d7bbebff269cc0e4cc88315cb0dc8ffcc8573c32aab90f41b031c595ee28174244bdadb7d36b3417a6c8439f619559f62b9dba67f86c17fdd5de74cb01649644130b534ef23dbf2047105406803b6560c3533af6c1214d01c92a882586a7b33fb9ce0c6409c412732703342b67a40a66d45582ebaa3c9f2f03c7eecd26a1115dd35007ea735db583ce459dc63b54dcc8a5b06f9290300a0650d447c0f776d4952161ffaf523540e87c2a00582288498236b3505fb9b7cb2a2f7b107c4ac6ab3e749baf5dc9a3477ac034b15de81857df5f30d14ee4031d5b1588f97f94df3a2b45a803e4c4124da18e58375f4167e21563733ababd0ea17557b34f6e45f43ecc6b62bd0a53b39880152caccbb1bdb7fd18f10a8bc3bfec7db6cdbcc4697d920d9ad957bb15f1113802e30c6ef53ec5702482211b8aef59d8c1bb731dc218cc1cc99988f42b98df344c079afdd93994964accbc74f92ecc44f0ed76d311ee9f53e693cb437bb75e356050627ce72914ad821c437d5141837ce5f3bc8b6e3f7123d5c626ee6b9cadd15061362f0bac9eba142fab6dc21a9cd3c10d9242cd5c84e16917413a576e4d79437562442f42265fb1bcc20c2916175a504c3d2c5d51e626476564fce8f3b2c2b477ea1d1daeae034069be179ba51dcac28159874f5a70378625ea948139ed3938e3accc9a26de8df11dbadb7308b27c00ab1a08349c75a1f77b65b27bbefe5d3e254bb414b90605c93ee2fe9270d5509dcce617a3bb07dc400f8fb1acbc21f36d3795c7da676604a40e2b1bd4df07eb8c7292fc009b754eb5e28cad4f86b4067b94ca159485a124a263067c16b23644920c0d99e8229ae84cc78c5a23f8d32699df16f0f953797b9adb0da690d160cef12fdd7dd959862edebc4e76cfb8c911922419cd9e67953c5e387f998c33251036e797c086ecfcafbcb1ae69d32d6bbe6e5b49885fc4d36ee08eb8d54a50636e05f7f537cde27119be331804f011733e594e6b99719b769a0298c7ab1be31843daf5de16ca93623c8d3c6ce887700957502e1f0d9625fb447c83fedfc3b0e164ce6eb6cded26e3e1153923b41536bb5538fed5fd1e012372301a7d0cc946ff5732ed2284f9ed8cc2bbf6c6989bc4a870c528fce4bc3eda58f04fec1c331b04b3d00fefea596f3fdf543e2f6574ec59e8a77a272596ce5746fa070a879899a7564eccb6e1664a16cc2dda2b187f417b7bea5aa5be758b72156fbbdf23ebd89f0b7f3d74fad9d62632246a941be05f1a3cc47a247f51819e5a2db9ade780d3aad71b30dd2814d2ab9f49796af03993901eb6b0565e9d0a41f3d30becefe2b1c3c5f7403dba1af1fe146dec7b737ac7d607f38ebffa9675afc2c4ef8c4b529d1c54a48760b005524ad394a0759a0f2ef68f04399badf5524a4273cb67b59bc07e4dfabd0b30a132dc54dad883782a8161bdb1ff2dd22f18fb9c9e021548bd1c0b3e702a58053ea4cc3d2eb63b7fc3201b2ae847d89bb0efe5d5ce8916a31c384f46f78a772c853bc96fd53904c2a0adadc4ff7016497463617a5c3496c64b2886c49ae9d6babf11f98475176038414544e3338411489328612a3eeed45cf027f3bfc10122c4bc11a7b0b4ced332ecf40d6d3698e8eb19727a5aa8902d8170be1a583bc5b7afa3386d781520d9265a9159944c66d8f8f96fd30569ee65120ea9405ba2ca9029e286da2e5e8c279b9182941548f319fd56111b2df1f264ae01100be35565368dc9511efa304f98050c4642a108801247c2890793cf3ed248d167ab93a9581fccb0bfbaf790ffed3440287f530658eaa841b9262d1c1a57c5d60cc7fd113612083aad075c222bfcd0e0e2d95aff5a31ba1f193cc4f8ff1eed70f09e5b15650927bdc5c59bbbbcd1e8c7298892f583202723abd3f6144fe20b6fa841895759787747dd5121fff1170372db895ce18a1335f996f51d0d6900d2cadd1d60071625c723d8987da8ffc910175e77facf264e0a7d67971c012d407a9b9cea0d5427963d9f7901b1bd3aac48a877493228b41198dc3076a45cb5051cec90d3c9e8c4166e1eb7393d3dc648be7d801d92da8dc0f2af4bee42ac6bb0cdc0ea38ab372754da872dddd9ce52e0c94325d8bc03d4d007b0c5f2a0d1a9ab2cf8b706193dae40f8abab3653c895680fc74a1a7103ab4d3885e1f06dd62f2aec26e30ae7afcced2cb3037cd376fc141557062e4457c724f3a4d1e40b471b015bf64566581e246b3c1df6b9d452f0dfd4ce81df3ecaf08fd32f33decc1e2d605529ad3938635b5498fd79ad3b71b7edf56450daebd6f60f25f248765fd5e0815b0188e340493f8ba88325007292cbc17e37d4c38097ce3f8b40693f1b57e375a15d1f0e8128828659e572f5bae8ae0e441e1dc91aed15b2f5d5404695d03dd82b75ba3dfb93f49f178d9311cdc3aabbb9350571c99c66b527605d4a413902ccc5eff3cde5f6d568a22aee2540153ff0d347827134a40ee55555bb3c26e3503ab69a4b198831604d789afc82f017c339a8b5c89b093c88248ed158bb9b6b817b775f59f166a2bfd2cbaef2cd8bd7a06be4c163ddaf585d6d6ae6aef4e7bca85a63fbc733d1efdc6c53303adafca01bea589721e0855d3ca06b3ecbd8880156de7e098ddee06957c2a2125374336d0bf087f0fd3f1aa146fc07c0f36f8a28c0ada2362854bdbdf378199b5cc93eba7b28053f662f9cce150012e3886dec598e43f3c6ac34677619ab1bc7bbd4b6650773e4c55b91ce5272f462fd1919182f04131d52080991087672c9bac78045f25d8b379ff7455f33ef6352907b1681d390ace4ddf493483ca5cbd177a3727b9749f513df42c3361aec51b38f850e52fbc970979ebbe28c88f498b73d4e6bcfe1e3a4b822a66939d73660a09beb6250abdd5fb261b20c4abab51b0eb480261b136267d93444781f26d2ea4fc01184b60029b46f25eb6a26ae2860d769f60be027cbf479287466af9ae05db491d3ecde2169fa9183a98b34169383f41e815d094c4d412e2546001eff872c2407032ec30edc3e13c00e75929d0d5d34ddbdbcc4c1f99e1f436b904fd5a3959d09efa3c2cb6d08671b8172abdad153f7f8603baf4f55bb9b99c0c87253f0f128a47730a67e0f179751a42fa6ca1b089b7ea835dd708ce2c1bb3a9dbdb17be836226a367c0ea2c36572ee00b345072644cedaa3c5460a91a4988edd4581e90ee83a2f75407efb95e1562e66066487f356cf350e08f6ae0e3d6d0fb574e589a44a86ec7a92ecc6f5851e0d88e053931c6674426f2167f52b0984463b11b9c2080eaebdca8a95667e2ba5541a66bacd1847ef0396c9d207254b5626ad2efa5bb69c3a7313e6ce061b709e2aa632a7155eab5b93cbe08a292a4345695641bd8cfdb75eaaacbbbca652fe723b0b84e8c2150609e98ae023dc83804319c879cd6ee497e1ca3623b347527f22ccf930c246bf0c23aa1b2d4ed8da039d90a8537cc278325e9dea3eda9b6fecb2ff2f146737b460e5fcef42cec303368a10a971939e5cf19b54208673538d78e94ae9ce436c6f4613e31775f383672dbe249df848de536e202865fa457c5496c5fe38b878b3dd5c7d4de692c80b1b9da0a188f946540ffc54f392ec828ad685bcaad59078efb1fcb1fdb9d5b671a759b7af4247b997870c6b38b130a1ab8db3a042fd8ed8844a07b7678c795b1e2ac98884aa7dec2ab19f2d62b6e7e5905dd10eba0f17f6b7168e25e16c3e668ad1bed43bef5e2fcd5bf1a7fca559397d32f0eb636cfe95d85e10c2fcb9a3263fa23bbad0f5a95868d4cd98266e0e6c53fe7be7400b7d868b948f0bb11cb86b76a8718541c60d628a6fea1d0cec10578542b7192f831368bcc59989cec77b34029bc08a7d587849e5621b94d48105de1f4a9958075a4b66566a13eb8a3be7049bd6fb61c840e3b1bfd6ee3f40d16556274e3edabd8eb0b8036666a184964f444e1c74ea8b3dd2ee224edfb448fe07f756414998936552121071b647eb64e8c0641a6777c4aaba44e597b89fd0afc863afc69fc0ec5f9cbcf0e0eea403bba962204167df805faa7cc78993b26ab8445d2923d1e806d828cff0e3f0de14d82590c84ff1f67db8357efd2a64044a9af8d6990e94f3227453e27bba15be8a94c3cc12db72a61df96b771b4fd8f0a5104d7da23f3cb39b840bc609a0160ac121fbb414c4329b7bd73f6a4298b8c4c1374e958def54bae93d90515054376af74b33bcb9225b97d4a5d9bddfd3b6237b6fd37ea20f1d066b03f86ec946954f09fb5f561f053d40e02d6dd20c56a9d11be51b0119c53980c369570d73191056e196fc05a68948b5b35d32480f66aacc9dd0962ce5a02f3b88bb9b86a3629165a1c8f4774201825704d358db293cd7b8dcdc9582957a02a391ff107bac2497dfa54e1ca0b4098cabc72eedc17db780c534af92c9b7c37ad9ea26789b8e7ed1267ad9842b95dab76925b2ed414fd2140fb6bd86e0bc413f19c69454e57b68777c407d6a2506ee4509fbbba729797ba3e88195ee5d7f07ae99296e787fc04f035c4844eaf82293648a177c706cf18cff36d9a4c194799ca779add4caae505bb4fa24a484ef4a12805759f7bb4ada69e4c5239b2f0e4fe72205695bc644839ccbc66b27889f479d827248d3283b5934b9f2596552f82e7f68ce42077fcf9125f35b54d612a54893280a5557455e58004b5ba22b5d262c0f1380099dd0dda4d29dfe5fe16fc5ba186be2b620ff446f6f54e37ff27c2f0c0e019756c747787655879b455e0bab0a93bc56d89f6935fbf2cdcdc257839d75600e6c1dea56e251499c2a1397003da957d2a6bf995c4f8b10c7ecc0a7dc510aab1acbb2424cf81511b8093b6dd5a7a3a702ebcaba1644a6c7db928f7baa22774d5795081015b3bcdb0fb7802b037d28756c58a2a55a3d9d29caf0edf8b99bb494706f0b824f750336e193918b04efdb8c14f02ca50567fc6488ea864668664c3381cb3f957c02723447bf5b5fae0231b659c4b44c87a421559c2d06666f7eafc94373c719709ea4e9b1259c4ade3beea8e9f25b207fadf291d8e906d2d554cdf1073b7b77524c021ab00565ddb8ae6c47d8837f2b5aa596ed9f636f6d40f99bcc6ac4e868c19abef567dc4247ca118377701d531833aed1a0e7d1e02565090c30c8722ec684f516545940296c8b0e2b704f4b00dcd0dd8bfa62c13ade44bbc89064508d8b1be451422a1131d3af69a8d80f2e3e99596591ec2638239b17e7150f2ad03f9c26c94f884a171750cf3d3761dac2f1ffec218ec677fb38438e36fe2d863a77bac4d8db371d780d8ecc45b0821d39f75e18416fd7cc41898965e2038c6ed2cfc26055e454830ce3aa2433123424d449ffdb282761bba7520e3c979e8fcb7880684035110410c06c2d6413a7a09814a74a6d76c75825a510310bc5b61f2d64c94be0c4a5fe0c2ff3dcb9208f57766095d54c3fa737f57020f554bc98d01a0fa01d6fc82055524d16021b4cf4232aebf954514dbf50e4eafe69bca1fcf18714675bb915ce83cddc03b9b33180d83a9315c4f9138228d617680e47b4684013e1813a2f14fbb004bf8fdf53d09aed2296acea228f7f2a6a8fa49612178e32009f3554ceefb8f217f3ad2be54c58a12214a6b65a1a2311b3f31336f4781092ccb6478de530c0ec4fe55b58c40ca1bac909147d1d7bb6a48e22d803652b8b82a7e8f2e631dba855562b280f5a09cd010330d63fa0c2f45744b756a4c131a354ef0f0bd316ec6c99f412fa95bb56c2227417c2be6ac1367f930deec9dcf604e9284d30d898c706346400efce23449651a454871d4e77539d70746ace9ebc3fffe2b9fd0c677a842b9981ccfa7d4ed5de6ea313a731a21cbeb1a3a3569c2cb650b6514ea7049b9fc7bb9b0a3618c7e07b69fb7ae5b42bed2b99d9e10713e179d85065f5fb12c2b82fdc91f21adc709fc9304cbb3d72ef622e8f321126bdf0da4ab4405528e609c1e9c528e316e0e74ce454d4a47a1508a1edf874c25beb8691de6dc60f3adfab20839bedcb84714b5dd8f3f5903710fc59786b96e2149f43f01af627b1538099987189f0f3c60427405c045ac9362aba16ec3b0c001a68460f99ae4b2b0999ebdc41b8c59073f300b8e16e8af8af7e9b0eaea995ed87651fe52e2db3f931d8b77ab4e4800c57d6fc9fb3fba4934ac28738b41ab04f76a695110fe75e00338e2bdd184b33e7b7df1252da23b528a536bee3f8d9ee15fd5dfb1e9b98ad49959e1d8b3090b6e9310e26a4e3708d99aa450cc10e2b9c2d64ac590445e10741f13e3d38be30ca93af345e4597d66f925ed3ba1e1dd8fb47c6333826e4523f1a50cc4d4702643e1e4a9f9be9148ab36f8bb9f788db49e69fe6605b1223dd951bc27430df08fd1fcd5b52308b2f45e40e9c7892a21ebab1f990b047e6c406a3309619e100b326bb1d9d9d0aedb6b5a421b1283fe37ea786cef15c99811f093496b8748224935df075319404f2eaa1e43bdfe860c52721f1ffb7b627c240b8b203971b6e99598aace78fa71b101645d0aee338b444dec92a4602368e21df34a25b717c8873a1264ec0ace3a5290fb3eea7ac9c29c07b10a556e1e65a118cad119d19f562d70bc3df2f0a6b1833f979e3a3095c210a5d55266cee172c1b97b13db3dabf1cc1cdfbd61e8907c91e15f6da96fa3b12f051ce2cdfe551e067f1f4fec9ee6d716fa929ff904e49a423a3236e0f72602d0ff1c1caac87114e17d426fa20538f7b94e511e031ab9c550bd41208a36cf379384c4ad989d9f8baac31800311a2ab940975725e93ea0e39c222a1f978e6faf3c808a69cb653f52cf41052d9cb7c188b6c1a7518f602e350551962a1a1c326db563e885d5b74bd490554ba4aab27997a280b9560eeaeea8dbd23aa4a8a4057d85bd611f718a24f99b62952ffcfad77bba6506bebacdb3ea92c45b59cdaa5a55060fe744111b334ae160d4d9b60b8e2912dec9944699d6aeb960b25feac3983ca0df56f3fb0082d2827f92a82d190508682198a6b1b84a328b9ae2f31652d3f669ca31a741a09b610b7b7b2199a8dc4f0394f98a2e18559979fab2f01ceecbebb97b796b02b5e845480b1154862bcc8f933e1c5af489184ac61cc1951479b94ab21cb8e8dfeff62073b6b18accb2e22e3e7dbe5041c004a3e0aec5f4b35f2d54b84f4dd0c6b042a1d898ae43b0de81a05ba79aa2d6bf176f9a557dd0eaa30b57773291f27d4b2dc552b2d244a5780dcbe37d4a8dd0db085912ab65598e21f363f220c41a1aa44b425f22d7bd99415afcaef28aec40c1177b386d10cd5eaf7cc974993aa9fe9fa03c763fd8160e00a2ddd05262c2f000818821d2117ff4f232a8971a62e1cf033e5bc5c042dfee735b123bd24c88c9d3a95b08d0270dadb5536e1dad3b47efd154ca71809e7766318057a806a4f5955f24e82ce43db8bffa1a37fec5711175155b78b4d40aeee2e967e0e9c11683e6a46be77fc3ed5cbe3600cd6364058c8a89685da81db44f9f08cc3e0ac0d61813b01b5189e45983d2fae58ad8241c33ecbe6fa3419d869b692bacd16af73503ed5c6ada47927adfb451f657dc882df3bde90d7d045f506c52176882d053775955e44fda642471a872da9b9a497ee0ca0f15efb49acae3cb342a0767df08112f1a8ba55fedd805cc37c6adde593ef1d184556869aa591190bca6b3c57b30a508778351376c148f676b37d896c0f610c64fbac953ddacaae9520e04e047b6a074ae0ac6c64fca1f98d36b9fb32f6836e2fa94a5bf9930580f5e38058874295ad9f6449a780c4cef3d163b7a3530de4c08d0a1d9a0957c4f021d2a8833028996615e186c7e86c900d370ed36b3f6fdb5035dc7294a8be26fa0a7248b942ce4165c441a8cb38ce9edb597e5f9c5e3b01a65b841c74eb6f533966d68dfa0f355381ced3b99f9ea8ba9ae27d0ac5182f96e6090a999c05892e18da3f9988b634a8e7a926762a068b4615b995c3afaf88742958b10c52b9e1c54d03c9976a998880fb5d66efb28aed04d74644f204012840ce1a6111604f380fc431a669b20446cd4c35a75d76eec30419651fff0501c3f0ab6895b43da26c9c76ab5dcdc63621a7afbddc123ebe6b3b2d08a9990559975f42464b441fc64e5e7b53a297f7e39bd8d4cfa5b9a481cd74a6139cf2afbb883167e35c57dbf08945bda6761c7965a581a60e3576f57e186280deb906ddcdff2c704484d0478361b5ef5e2f86ab453bef8c51d1fa20423cd6fc8d2b70300ae7686c26d8fdbd8c00a12e0201b6e0bf4ca9f1207f0e6661dd557e74ab9240af3cda008fc048e5eae8628f4f977324b098db04f6ae5accd1b79a627759890030f39a04fa1eb7f89b13d4836e8c16c64df46c7f196ad74ca04cc41e303dd8adbad4d817c9c9ef848db595155b28b389218dea6042a51db17be3ee4474fc194b2ddec058474d44b6d5aa332035150f8699d801a4bf00cb5d7278faccbf24fd6a0bf2fac476bbd45a7204d606b539ccabf1221e8e74055c941f578d1517017feccfdd0a9afa0f58d6d6466dc7342ab1151f5624b4f5c8708263d01aea76644a26046230ac584284de2760ab7d5d238ed792a056d83334d22919ddce01371649ff73d09f9b8c38b930b1478aaf574013d65d506aed50db91398d31cb194b8b5820b446f0f728a1d905a1da5c86b93ec8b432584e0b9b731ab0e803ccdc02a8486663b3dbb66701fbe6462ae55ee17d9e4b49bfcbd8c0c512dff3c3d392dec6eb6fe17be8601d19c99dc0dda591c36b8fc494b188710f2c5c7d12aaf3a2f62a100f442cd265390f98091b95d82331664220ebd80ac079ec8bf323bc8560bbf6729a2d531a5c468fe76fe268d918fd7fbe746f1934875d3c8d78840c96f6a0c69aa8c6746314c8233f4ba5d0d0456029c15cb2d1a9dea0aad0fa027ee3544e50dea200d2c1ea679269130a2ed85fc064a0848a9063f13c4fc40c46ee27e51a3b719c023a13c2998572982b35e6978228317d141b7c0307b8480b9b6dd9e7056412932bf3880c24f780de4197bc5f5d3aed045c0f65933d29f8363b90cd4a7798ae8727a9810522b1723bceec768ec02d82fc3156f7d6366fe7eeab3ce49c4f6df7d1bb14ead59cdf624a4df594741108e65844d304f135b5998915f953297332d37348d63b56850ce6106a148bdea71132b97721c0dc3a7b1ea83559634f90aa31316d117a25dd489f46f7d78ffa0f35063a90c4e0d54bc29599db11ee511d248efab94c8f06a978091e4b78c74debf0af056993494b89109d2b4448f93b4a017520c44602373e73bdbae308a4f919e5fedf9e7cb5d331cb76733cd9a12367955bab9f0c396df8ffba088edf433b32ff248cb90fbff677f349dde976739c7f73792627773809112f1e2924f7b6d52cdf1446d19fa98c2b2ea3361e45a6d7ed485abca26163667562ea308ce72afb6e3828bb42d907365dc65907517e7ef830a71b4debf6fcbb5febaf3bfd23f1a6c20d0bd0151fc88f4dc7b28e030fe3059b93fb8599f665f4ab1449395966c2159a23cf447d7894208d338df50df71ad148b026b222d72d2c7fa5edfa55fcbc0948763472c18f0bc43d97e5def686b13291975e1eb534ed5faa266244f0b4e41321ae45d3f5e2ea961c51ddb9a0a8a1cb9b0fef83c3bd94bdee0f9fadacedfe3465fc0469ed48c8c674adb10d9553542fc51f890d22bf44d2c28feffc0e01010fdeb385797d61e9ae8247b72116bc7b17f7b167b29370b1030261ddbd4b35c160d6ced3311619076742c9654afa1bcdf4153ab2c89406eb9dfe6dc93bb6fcef6491ece1f1181837dadf71dff895d47750c3b83c24832c870307711a44aba7e92cebc7f6dcd3e6425a141652cdbee0ab5223baf128b972896b519340febed6050bf9ad3fdf05a0c333271c07280ad808daa159303887868231906f74b23b37caa0c8d9d391a680b876f7d1590b216a11ba64c0ef8c3639370f575e4e5ccffce2947eb3b4fee2377b9bd79eb02456eb6e5e0535fad57d0c4eb7cf73fd6e339e1c5ebf1ce7b3db10fc8f9a17e00c995a846c6e1e11214e36c2aca844850cb495be2840df5a6130c8e8a42700732566be6d6c6588ecce546286352983635d8e04c91eb66953d6b12d01cfe78ddd6203ac95305004848a7ba5b28efea6e6ee202de2eee9e5689b3543345c51ab6c077480885c099e227336d10ace8bf42888c2fbeb9c697b945647bf0c8e95c8c3069f27639e42d602a7292e092252310ee8181d21b30b2b616dd440896a37581c2acfc26bbd4e0daa14e4cfe19ba4f297f6a5b26b55924ca584aba9b4c3a15fd2e7cd3de02e7fa5a281d88e9f17640a0238219fb9c89628e216d679c77c3e02187d335bfec570653ca622fd912bc8ea0c1245bb277b1649f76ed2c1737c1e264c6adf05742c3883ade8a7998e02a6a23155d58c9c14187bfdc85284aea505b422f6af0f0a58cc148f79987289b71debf9cb6f407e16d40d0f910bdf20ceb8418267c847e377757782d5625994feb6e1c0b25a572c6882f4db8649779a7b12bf0b5da30627a5a003aa7ba165e30918764d144aec60f0cbc266d84ca2ddc4e83eea1b6c8fd350beb6efa37b6ce7618da4f9e036bb042621149bd8a8e4dd7e12182a92e2e667a1b5b7b684def48f55566840ffa4bf17ace384317c34d52f5354de9af765d39591bcc2501ddfffb700c8b2bcf02fc8015ccf25cc6b69c93e0e09bbdd12e4674f6116c6628a48b212a5b5bcf5e3f574b4d44e69a8e23ad13b4856accf0ac1cd4044c5aba2d520155b9c884dc06e560cf54816949f878d103e63aabed8aab1d5171a3c8635a51e83c8a8577f8e1b4340dd8d9422faf5ca4ff5568b0e4cff91727e835c9de92e78021fcdc015d5dde0b734bbabfb37fcbc09c01f44404eda7234c53181574f1d2a7e89598bf79656a7cb6d6fbdd53910527e48e025ae31ace399a766f9d42695ae271c2f71468d2b8977df603151dd9f01d863f0d7d884ad926e2afb9ade193b40f111a5026c24d75a95601ba4405f0f57eb187293eb7b73ac72e071b75734d6e98d19484b640a4a060390fb93bfbedb316525608af480fb8b0d0a96ed76aaf7af5fda8b81358304f8a91560fad761b1980a7923d447debf2f48243e58f206d0b2061630fe2ad87161a57b6f0e2b7b6a5366a3fd528d3d496dbda47f48d457ad70ac39b05952b03786e1f1a0cf6c9d3c463144bb2299fd559baaaf9f6f84f222485e2cbdd3880db3501d670c5aec8baf90f1d13f5c7a0ae16ef265ecc31756b5b7892a2d9c20ed593370e6e9342c0c495c2e4d30750faabb557480834b9af5022f5739e6d17696eeb3c9a9c70a5753806a12ff6bcbb1fe490863765344bc307ae721d15f3da0968e82dd796596de77ab84415bb31409cf556a2ff327237d386be1f0fb745f5904e9d0fb5868b1496b351a8cba8a4d429ae0be33f5d05e6a4d42faf9f9480c77854407bcf3622d1bb3950d0032b03aa15a14583591fcdf0e3f7bbc6fce2dc5b87499c0ae25576455506ee3ac4d8a75f357bd7d5a0942a322a561402056f766ba8483861ded0890919a2571dda8bf49073a3cb9190ec880722e89a8af7c67264f1605c984e26856d378258d2d7dd117ff6c39a3fc60e1a41d8d84cc067874ff12ee4c5a9ae989091a9d0a2f13ffe43eede232c244794106ae6c82d79463c7609e9a281e0981d29b590cad245d5056657b5bc1d521a1ab40ed026de364c722603aa69239fdb759c24761a54fa2919260de7cc72f0f3c4ea0a940e47d48005cf78e499a14fedc384eee7ce36f236b9657b62027afc89164558e1cd594f398253979f64a3cb9bc7888d53bafde96b823f3b2e3af6fd360c922fb089f1b5d63e9aea05b302a0ad7c69e8646def8fdf9c577e7d2a7f93c391dc935092be2f52b30241408565a4d5b3548c63ed42b0f4b1d537c4ba89f94cdaed44021af853dd2eec9c88c41011875afe2407af5ee5b02546ad45038897415873167f57bca70102ba4d407b0c039396c8fd1825ce81321fac44bda40f9fc853b054b00fed2970b3510a9ed2c8f4ead7bae140d87679260eec4f491e2a2d3e34a9d59252ed4794ae8a76858f90c589e4dcefa6a83b8aa0211027f806f1dd216ded76b09f7901ee4f8b5b5fa6997a6493db4f46a2e0f4ee491b43de08b48c82276bb766271d44d20a78b5cb9f6b0cbf019abd1702240c2ce3af5bea4aca1225bac0219ea0fc22973a596730afe08f472f1b08a0c550c0fc03857beab794fc7df31465482e591b6601f94a1abb88653948d945acdfa75a6193ab1f7f7cd3171b4465239d908c564292847518d0408d4028286c5e128314a97107dd0e7ca3e79b3b2d1fe994fc2acac8493b5f8c7d7f79704f7a42fa63d64c505ba0c98f4ed666f9003983e6cbd73e118e737f4fc2c61646a32484fea2bce9d92efb2faefbca7fb77b2912c5b08c8d27ded37b866eb42b9b810e7e18e6333b875f5e5ec676aefa3e5a605e6279f6e30f3a5d9192b85a9e09ad8a77bf67df8e5bed19ad538ccf242361cf86088d996f220fd8c4d27d613b1004ce97fe8c329b8b63a086cf4cfd71e6ab1917102fa329e301265ec37d1b7a9297ee28a2ee54e11772dc377b92c250db074a910cb6d33b7b3836e496d1fff7280dfc141958e0b7564f07a1d9155608e052b1eb36d71277591a85836c53b4d0e6da701f7872fd71ca96d4a4f248db029796584d4fbf2f53693d000e3fc0f008dcd1ed5b8063fd6dab8619759edd5600239e480e9d65a93cb8a59d214ab57fa8f4a0145646b25e9bd51fe6b88d78344a3f65dfc2bb610f685ca63a19bf007d35cfad92f603a6edfe9b28852006a243dc065f91d207b68622833f340320c55eb740e21aa5dff05466480c521b0a209c2e37c5f005f90148902d0472743dec1b9ddfcfa0bc8e34faa1e26a411de5616611f94aabb05c889e0bc455dd7db911658bc02a80c9fb0acd9be4ab06cd3a7118f8633f73b836efb0e4752ca8e5c150e3a64f13437a0a51f80d393755e76ce9a542e38c7d0a0bf3883171394310dc0299cd7078fb7745dff7499673dbac89137e5b978055dc09bdf422558803987022d36632a9c255ea2f3e3ba64ff2de32aa98ea3516686623d1f550876a9ca606b272e5cc170141c311b5bc2c3c164f8887eab385eef44e69dbfcd25c3c625c80a54a42b45a0fca228c8f530c03687423ef45dd863fafc8be5116b314c8b915e7c819db18d9463767193f82fc721ff4dccbdcb7f61316e9cb2909c5e10d75bb74e98251eb380418fcdb42acb0dc8cc4ae07b6debdb8d57463ec1640b96a3118cc9eded9d8e0946771359a07bd8b0a9d7f0b97000d03dd341c77ad7068867eb30746882d5e5f05cdf08a4f953dba8278c78a4539b523af82b4683d14866642cd79b1a2afc97e5bdef3807a4b07d8c874dda0b96051d219a588ccc5abf690473871cf0304c9c55f52b3d80a31e20afcc2d8938726710c8d3f28e509de735c2bd9b9ae755e8f31ce6869866b2b8c9c7e86c67d0fd227395e7096304041001ec9ac0438f90c9399a0db6aef8e3ddaf0d1ce3e1a48f9ddb7ea7bce65bee9bcf6d3758df5e69934766668e7b63549cdc9ede6df113b1b2c63c6f33e22015b2c4cdea779fcb9fa3fc5f34ac052803f80b92595d8a38dc4bcdea12141bf6521a486f4c7217961db14b4d46896625ad47797a80436d24b5764c77bb09250f1c73caf24572dfa107f9e22afbe75210774dfd77477c8cf2ca38cb1d8bc491dc54d17d7b0152d74ea4bb67ba555c13d6f764b2de9c907bd573d1a934c6899c18713491bd967d6df7b770ebac8fbbc6865dfecaaac69588abd67d8b9602f1257ef65cb086f591176278e738f820b0bcbbe20eea0aeaa15711762ec1b7bb810a76b89937cf400f3aaebc7c2e2fc6cae3f3aa5951a054ec76442a805461e0a809862a16caa4a1c69cc7ea152792cf5ac9bc7440e3fc84a80c9157416762f1523160bf609dfb0cbea3ac1849a84aab0058ff381978736a8f99b9041ac231a011e932ae4718a1b976923731a882c7ce763d0788af76c4d6bc7aae71984df74db1ce84419809d851c35962d8d6b9813d3d0f2d08b94d6e3c78b3e8f5388aa897bd35449f2c0981f7a8852b4812ba6399a2a57ae349bdd2488c040acb09d0f2cc40d7897ec3c1df922f0bcbd05f0f7eef8949c1aa50d81832fc020349f029e7bd88069a1f066daeeedb384ffcf9cc5771a2283fd41ca0f768578c31060773ea8bb2166d2d1033575c02b6fe0d4ed87f41c2b8c46301a80c55822ca635c1dc2b24b966c6df5f34c81dccd14e51332b7a8ac8de2e242d0d691199f04cb242330328f312d2eb9d58903fa6a1af64a6da8ed647bf3b415af9465b89b568c991d81785fa6869a1a09fbb5274d358e747723265acb5f785c9ed1a46b82f817bc465e4147b6efe45231eb427230e6dc634b4fb4d9bb4013e9635f431ffbb98729d6acb1cfa544d884831e50ccdf61dbad6be08337fd06d0f6c028e8c9ecb275cbe238d3e2b3866cdcb42128a6ada61620fc4b53cd82438bc97f5f0ee434b9dc73791e09a3b3091fa4f7bf08c78ed19aa700cbb631fcfa17051408fd78a344dedb042e02c0a354b6eab49e2b102578790ac76c8d336c9545f4e7ed27cc20fdb3c3ccf2d5432d27f53206f1936c1e015fd1dcabcdb3fe36802298c2050fb278473f812f4c099999769494252576b00060b761a487ccc5e9a8cde712e799bed3204cf609e3d6c28344243742907f5f30b3e89e41f950ccf68e2a47ef7ba6ddedf1500d38b774472b4c247e323bbc0235aae8ecd17c04b01f6d093ec36f4b75c70d5be23c84264feda2fa981acf74572c163b7c81a86fec2a5225807c2debfdb30d61a3ceb84fa2f0b92994933dc4a597f3b40edfbd10c72355415011c10dfef05b5c2cca16352bdea7a15826f8e37909125f8d235040f30812100f60464ca14d535999f533afa48f928f201f307a7a87474f88230c488ac186fe48a73db75a7e2dc2895b95ba40d90ba00f9c010751b7e5a24fd33305513005e9525e581cb6290b6d24baa5284f390f7ea051e89b33420b49982b421a7145d502612741f60e76c390d468878543a2bb739a25ca6a3d273520ccc6b8a8fb76a1ce5f7341461c129d729de631f4308e5148ab9bd63bda66f981917f8afad750dcd9f7c257690fd2e4757f88abf71f41544ee7ec3ef1621a67e24a291ee50c6fbfbbf06e7978e317a4999c92fdaf0495c96fe576ab28ad66e91f94be4aeb1f3aec18c3a5ad7595dfe33bab4121962c280e385ae069001a0fafcc472cf5e73455d26524ba39e7af12144cf1c5e6dbc933b6d21ef4c34425b5c749fa8effa6456957410e5071488ac762038e84004feb40bd02db56aa28b6abb8c02fbff14b9575c32c8dd8721958d4b900ad04d66fa0fc608d1f871047d147b4713563a20e5eb8b82572121c6ae7bf9501efec9b8e9ecc2cb99903e4a5470621831962a15e02cdb21c7cd8ed56ad43427ad245ead5ea7a5cc79c73965a039dea05ff7569684e5527e3d35efd19e0f3b15131c8c9aa78aa33a5d2c589ab2b0be5c6088890f0cea44b3c9873e141eae9edc817202fdffd19f8704c788839292ee5d9c7596ec3919700f071462454fd1c6afaf045c5bc1d364201f249292404db33ff26307813ee0c5f14c155f22c6eba42fb1a87a1ef6d808f27997ca16b9c9a2994a16a6a0fddf4583fe58af2fc11a716a0196e4da9a29798abc07c6e7782ad4185796642a1f94317b0f49a43796bc1ae81a44042768213f65b92e6e75d3a5e36847d0254f16729b73d799a62a0ceadb7490d3013af1f029678bba30053c360de5a614ff359d238bc976b7ba6a1bd8be722049f307ec4ffd24e8c651398004ad56471667e182fbf03690706debbc85670bde8f0235af87678a238ed39b4ed993b25de4c8eb65197304b8339569ead542c6506c5588d32f74d64d799f9e747b66e143926e9bd1460734c78931ac4585568745bf1f5c4da224f63eee2dd7d086a0f3d89253f2d11f36dece13e736471b8dd83601acad56ed1f9018003884c6050fb309aca871e874d9d28d5f2ccb7d82b723d0b8773bc588282edb61a87475cde9b2f8548dba3cd687034252161f303f5c7a6fd89bd001f8719525da60fd67339a85e8c00be6fd137168939ec41b41ed5179a0870ebbcf1c8b9f38266003b318e83e6e5abcddc729c9dcbd50ddedf43af24c400da29ee0c20b49b67c3202df1b4ffe71cbf4faa0add9b1226939fdb4bae31e5fdc40c4eb4890ddf6c150b84bd0be85e0bb4ccce57240e036d54359b4fec2f0a10f1f790e60cd4bb941d5a9f94b116198c97439e65bf35f2a6b57f08cd33215e87fb729ae7e11b037fc6facc4ae1c30e983b8b22841dcfa85bfd94133281cc68e7c7410fff714dd9e119f1897ce9ab084fff71be13f6e525f1b6f16d11e9e19ee20e119e3526d7b3ed0364b4660f7260254fa9ee3779d459c9fe275cb21e5d96928684686e599a30c3076f09be18653a3e2e310b80f9d333ae730ce19ca9ee2a43177073374cd1b30771fe7d25db25f996d58cc8bbf6f5b0c0faae463639c8ee795f74ba5d75458a35dfab5f942cb5a28133072d4c4b8ae4f262ab9e773f75cc64275fe1e4f22c35043bba73efedf26f5a1b79734d31f2a9d9eaef96afee900bd50fb1ca42f84e46cae456f95e1eb1a183bab69cdb64b649382aa58d53e788a0a0927e2c76bccb7639b45feb8b73ed0f0fa64071dd6c170db342da44a0d2e69b824c5e14d9436987b51f304751b7250c80cf412c370b834d87056cc9d3a1276a18eeac30333cf6395770e3c5954aeac23e6a4322b7ee50398b94b2c645831659ce4bf5b8c3010cb2cae383b0018fdac8dd06ea61f0f4c5c598dbf88251875b7d9a472b7244fdd7eca0f3132f977d528a771aa946c4f0be7d7fbfd79974d043238aa8fa078582983a40574ac9ccdc5ee6b30b00edc251c929c4548e6a2b24409685cef138a37bc3b13811eeac8a193edcea358c5b8858d86ce15637580a06704e3663a665bd9248fc8d015c49d32108388b50b921c3b5deae9408fd1b30be230f2c3141b4e9ed09033fdec15173c9c3da3f15c71c5c6fbef50e63d68a5ba1729372a440b5d6ff9204cd2481db231accaaeac9289a7c4a5e8aebaf06d42a0cda3f03a9cc1b0bc02f2991ca99d29c371ec393c8922080a8afe966f958232926f2d52ef748f584aebd4049e2ad1b6079ae3ed46de5f1219cb5272509275cf2daa544e8d72532cc449b72a5c0579d8188ccafc90ac282d91fcb53e7941e62361d2347788c51d81bfe1a6bf98bc26c10375cff2e0f65694bd0eb6fc902adf82d0fb315a1dc79cd509a4931608e0b85a61bdf38f7262b7a6c9415e4d698b4940028078eb784fe61dc9e6c1aa954346c7956693f1460f0c649ea740233f7acf2533f56908e68ca046766f734af61ba7c0ba9d280bf6c84ccfef5c4fa606075dc5f1b43afacb42e04931201eda3f32af8d845dea74157bd62c862c76a63804700bdeb6d2b154df8799ecdf01eb56109446a28fbdb07192e65503a555c3f9f362fd20c3f0cc6e431a71533da4c62052f7e8ea554e7df43ef7a8780e0de72ced1fa3bd195101beff73189b40852bfe6dd8db30f02cc92327294ddb081eeb276c18d8a0e7a9bdd6913bf9cb3f1f934ce1ce35fbf0c332915871442f8d73e08f4729c535b2717453f2e2c23603a8c7a53d1b08883d1a81363a51ad3dedbc58bae50a3143aa8bbbfa49f550748b8a996f3431881f6b72460c3968c3ca2cc1a2815c567fa404c0ff7174075c5cf89d83dafc753c2e85211a29df21ee8270a03ef874f8796c6e1eef20275f42a1a70a04d6337a0a7579fbb2219cb2c6364ce160be1049acac873afb38a63b76f3290590b89abddec7b399444667967bd6171be118ae20c8aa2b3c3d07201650715b199f269dd41e812d5cb74935f1f2a58fac52ebc826b08ec341a9310e370afe570473dcbe26370a5ceba50a29c436cea9b6df3518a87b0f9a097988a06b8af4081dcf0e977d2e638383bb00ad3e00a639b8b958ddab2156c7baee5323f493a40560e55216b52c2d6ec07d6131eb6bca5a832f1eefcd6ac16f628ecea4175d51d8b5980cb875c7d29274bf7389d559d31e85837f9b2a1b0482bc28f176b502779a3f75a5bea29c25c87f70e9062cf7e8ee17a06179637e74af298ff53e5ae16d46fd105bedcd46d8c982f977e950c043bacdb86fd8297e8289fcc6be282b10edfb121470d05c3850b9c3174a4d882facb35340c8584eea9b2c29029f223add7c5cfed7d549662a64fd857f840e93a5319756db21f46c30570b488e0828ec3792c1090aca1bf10043e26a39beb3dbefa10c5948628bb66c421370235c0bbdb1cc8cb15f02d55f207bfd04f685c1f292a3aeac137016473fad58bfea33512b57f107fe52b6beffc980d3e4cbe6eca514c47cccc10c4e861a42ad248343b046e733638b63234809d4c841784707b02df641c5dc143970ff9dfbc3066cc3807c9a54a9b84f295a2391becbef6d86dd20074810cccab3131eeef25b63b8a4963eaec17ceff29a471d40fcebbb2987a94e40b0365985fe92246bc74fbaa908b65d57977ee9936b837391f9993ec660d1ba0ae567f8d6676d3c0f49cb10752af144833bdf2affc44527425d71a0a9d1544402654ab2363290d71df1dbe323710dee23748be9c29a93c7383974d8bf59cee2b9c141285bb4700b47b388a42c5e38d2aca11e2c3c7d5a2386524dee66eaa3b3ebefab944719c2d3aa74bb43585e60fdc40e1c9ba0cbc763606923736366babea3d062d180898c27e4bbab585875da5ac5e9bef94636d2a44b56580d5262a29e5f775b1639cc46c93556fa7de25ad90e39d77206bc22b0df695c9b30dfcdb98051de896cf27589fbe6869b19f61041189028c4a55962bca9f45710bce24dd604ba6ab19feb56f76fa207f1c32a4960dddf7b6ac6d2dcf7cee3f39dcf5598a6bb05b676cb5f8c3cc27784d42b6d47379eebb41ea692bf53ea64678547f6fe5b5dc839b7477529a623f5756f76dc62d4885267f364b878d9987c23d5802c7ca8d9820eb4972a54827f0d85ef7062e71e1d3587fbd62ad8e011d9b9838c53651beea599206e9f56d4d7a8dba247be5dde48936fc96ca339332ed2e4c0e6f67bc43c5d333b6bc699813f607326548e8cd09968ae461b93ef132457d1c85a9da4fa93955ff606e126a790f57868518495249e5c3463da9502eeaf20c66a74c5fcded32750f9de5b605d8f1fa5b11dddbe35974e1ed2a4c7458fda4bcbb3069d094b0fc8fc7e41348b71de0035798d9026f22e731a435745530bd4ace0dcb8de292be9c292452188f0eb9ce8e97a4501217c36bee33f4000d0e2cb389ac591b14e385f2a17ece2470c447d42a24bf3d64d341fc0dc27c0de139ec394c9cc6513d5480104fb739ac2adf9e7f213bfe6f1b33770744b035cc42103cfb5cde4c49abb2c43cc87ad37075f5900bcfbc70c3a8d0f0d7b62fa12e5f5eee70af741066177c9d9cc1d01ef512e602bc3ff025122f29d1b7ff397ff8066338934a1baf5b87116520cf31b08562e5e95877abdd404e18e76ca6beffba65b853c2a6ff2c579a155e574f736cc7467e26b6c2f839e4e9f2e418e456a4a9d1682bced468bbb50323003726741f547c299a0e78cd64dab74497481a1c17f104e6dbd1460bcd537edcac144a59ac48713ff158af46b401d9d1c7cedcbb51316a381fa180fa91f63695a6825de5508138aabe07dddcd893fa2edcc5d286ea19563d6333a2eea7fff880e1e21f085d6aaadd9d3f78e9061c6436fd38e7efa1dfbddf49d7a8a3d17f00274319b2f93afbb5580c814388113f375399b103d4021b8010d3e56dc9339f7242ac7d744f4906874bd15db9c9e65b2566e00594d71e8718c1c5955d58dbf78fbf91d13b767a5d8c327f339ac5e6e32dfebe4bbe451559ac2ca465897f8778741387050b0da2525ddb104bdbdcc82176156295c656f54edce578019176f55506706d74e3e5f196eb214c37b7860bda60ce9820b2767b585793833c130ea4e4f51ef83affd363c43c52348c6895b9bd3fe0935aa1435a071bf2308f267f63181d3b47acb9ae94b75ea57bc0b93000ed2ec64fef18285107d0e0e8074abfbe3c05d4f665f600eb38b73dc2861a66b25bf24d4707190ad5c860bf7d382070d1eaa1f7a71a02b5416e354de42c2e6d42c3e8aaccbb0c01d2632b489f80d77f23ded5a9441917768c1872982ecaf85a950ab583ea4b325eeeedd1db9aab7c1944c87269743eab99c78b9c200f6f101b8c70583593b9e8987c343f56eb1f816756d123c8f4f7f84de85bf54b91114336d62f5a06f6162bf6124ea144527c3466d69b45342bcb81aed1a1cfd9d32eb7609cddc42cf6ad126cc17979cb7da41d25bf9990b0d8ee758eb64e2b19364805aef0e5de0fb1ea781d7ecf9e537ad69ac96598efd90c733202b6c558fefeea45a6e5761c0e14b1b98b1e1d1099a656e959d993238dbbf63cbe10439e1dfaba80a6cad1b794348868f252bfb064fcfbb2e4862a4b0a1cfae22ec08500aa121d6c32127291a4ff07049850b49beca4f6def7481efb178ca188819ed9deeec716b6dfee14287f5d9f00e3d096cbd49cb886d6e3c2d28406e64010216b85fdc17c303fda7b81a9233d4931af1425a85d2b6d2555bcc33ded02b93ba7d27a04219a147f8688f776bce4783b3e754f4059610649c1b0cb5510bcb84d734ea27d53b7718612393a9e15b4a32d9b76fed421fda231b7bd03c821a39282d71118751743981fa88ade23963d483412399391e0de57e730c37a2f02b29f32a771661ae4d25d564480c9ffc73d95d1fa75199ae7ca84c6009c82e20607fa9323f8b26a9d7c771da455ecb2dbef316766593e12850ff8cf6c6542cbb7c49a6d605d420e0bbad0c5f001c918a0f75cdb279f19c2ffa670baa1503b83b6cca52b1847c796e52badec8c010ab6a155d4d9ffab50dd931f17728ec686f1883d2d4bec91ce5a9ec9cad02afd87580c0e5d9eb48f53fbec9e6fa3e1e7d2cd8253a835d103a8dff8691fdbbdd7780f2205b241b28b88c80ae5d23785cd03db17d37c15ee863c34c5a36bd34f475a8bb0027a98993cf60ac54bf2df3829c53376ef1a20a7c79659b1c578ddd96111cc946d9cfb156ebf23bb340690666f9b75c886805b2d8ae5811758a83c8d38b5d45af1c6802001356759e0be05d6b04da607653ef1208d8c8d697581d28fe7afeb4d67daa70ebc87d9304fe571880ddfa0084fa7052137a15b1f03adc1db2eb9d6f8ec4150819841621bd0349e04e581515eda2677da333401b19f34053fb0f150d1c9d2abc99265462f93b0fd567721da5c35a5558bc0deb4fe4f8e3e9dc7c9a1633e7b6f6eef42535d2863f006ce0c3432bf45c49bc3907252812bc87c3b665c52c145362a9799056d4dc4c36a2a7698750678d237546a450b7b7884896518b4489cf86a8e3dd13d5314e8877d098d0f68360ee8ffc025b4090d317968c051db1719d9d32bb9a730b4d873c5eca897b7db6b278aae14d0106e76e27f8f48797c46501da47c7a770af452ef3b66449b8d412bec72e18cd3bdad6225b5c81c6636903cbe89acc1c7e8dfbf10559ef00b9bd570032728f948934391df316d5b3eaa5d95c283211e92fbabe4f51358266d24f675fd62f1187a305fa76324b3e92fe770c80dc8548fc1951e2ddfc487129e9741e574d873a3f990d5baadf2918c7b392841d4feaf526399a4be817f659cfa059bfb6585b00de5d15bb1cbb64a14f2447712913aa4db7eaa4fd815099312ec4dde1f72ca3a4bf87165e7cf0be804eb54663b240e2c717404f016f8e34a9b7bbfc365986443ee2ac819cd1e36007ddc853b0f5855735a43b900bbbcee11af4d4a5adee230286ed65daf472b80c04a5277ba15d734d96fb1d9b1502b9dabfde8c7a00bd16c0de072933929f2211408d36fa6c6b01c17605ea7a4a006e19e2847cad6ab9a12882aa3fe6c657fe794bec43916a503f9766e57db208c64219b7fb44cc179281dde776aceb2c82e6638fcd20b4bf88825eb9a9b689106cc61e1d21d71eabae8ebd70bcd855fdd06644f34389625bd269fa39ef811d25f7ae6e970982b70fc945e3ce6e00630997eeadf7f416851edbb02b283c910f3ebeca1b1a4d539dc498e9840c12e9ac2d9399e97a675acf97d40744927230586cc4ce38b0c7c77e5876a5eb53449d4421618ce4c55fcc325a00e8271455d47ba349ee976166e9901e35880a9c84b743258dd2f10bd14465bea2b0cac746336422280bbc2fb9657c4519cc43eb9b0efbdac388da40eceb9fbfca3a0243a9d28c515f9603a7b05c9a7dadd192fb9d7bc80fcbcd7c94e6b52ab41db13b58a776866126b5ae7b6ff7c287d9d42fca406f52501b4c7c4b79ee613088deb837c7820f43a012da52303150d0842ba4c1baaa14e44589d357b97d4eae8972b093966bfc696f90ebe34ce81e1ac0d78ba272cd5674f01778fedf11e6a2c27f434cb1e45ad2b3917817b6fcbe23d0cf3aa2697e067477d04dc97df18a6396163a718d4a35904b3d2774725aa56692fc0ce90ec92ed4a9972e923c35f64aeffbfe40376bcd5d0e764d80fdc6a60bfc2883f767f70776ad21e52d64882a7e7653ada179841fb46f3027adbf70421ba51b416b98547e78207b3646f2826af58628d0f6d94ae0b6611048c3ebe1d04e33138fefed6c7577c1bb257bc6cf354fdffdb30e67ebf5f84c66acb4bba21d50dc18205c8cf963977aecb403d71acfdb039abb5c9f6c57b66e52d40c5d8bd81c97ed577c8cd936fe9becddcd824468ddbbc516783dd042870adef4f518606244a8b096f5a73ec9cf679b36b7bcef42fa8fe41679f91f7f063810c537c8ba9a1c99560af2d3a91ec8e04403b36de7bd43f36e6828afcce019593a8fc2d1d0ca33c02cadf26f31f87933896f71530452a5ba175ad38b70c71dd312b371892ec3a9943afbde65be17f83388249ceb6efd061aee234b0ce99902d11fb1b0939e08d3b251c9dce47a98c3b260b46d778b7e73c417f65499e472de775cbd1cb8ad2e01d6cb4ba9b5c15c5e92c30293712dbc6fc04b1d5063f3444f454e4b8035e82691e50f98617af6ac1040bba40c77215d914fd98c53acfe1f697fde035bd5126217458579c6bc9d65c08fd077222e3129e86bc214bd2b55a88da432fd4366cd551a44c8448da1951b82a133b098e36d4d0029810da013bdeb3fb16e0d29aac42352b7400c9962a8d7b2cee2720c939437bdda500926272bc626d2dd79c6949b9392339a9db3bec956350294e62d5c6f1bb32a9a92c0409bcb6dacea1b94869d9e11073dbd60dcbadece8bd6b5ce64f08af6c6dec0a6beab31146467fa33dcb75340bf3a38d7329010373a8cb56a852be23cdb82049ea74a2b388e88d1a724f1e586e474e497a74954e32e39428b91b1c4d15a8e425b887c856df56cb80ce205235cd4a84f8b4809a7e65eeb077c2fe4fa62110ff6831d55cec33b99320fab15340c8f214d87f583b8fc837c180d3100341a30bcffcd1cbc7b12cc6074687d54657a7982ea8da9ee8a0a67ca21e39371662fce7877977dc9291886f71b43f73e070bba47464ec1aefaa35d9082af38d491fd23bf91e498dbe37fb9253a83358d5ff1664f85ab7907dd38f2f111f89220a763205aa2acfd44c10d8d3c7028f656156bf830c7d6d329e00e25a463f82a14413e3df4757857823a4818cc6b949c2ac60b2d22731b8cb444ce8ad437e31bec15d689a089113fdde4ae8c5fa1dee104efc79d9344639080badbb3d52c14739eb7b947116ed2b617c935642bcbcb522c8a104b0429a9078676f244504581ddbdb6113452f1a3fd8fe1323f8cb7c02e52f2b5421c4aefd38f23ae5810d596486c607179dc3671bb14b503b8826206d66e8660de8754b97b20f1fe9e9c1b7ca972c1eadaa32ddbcea873f66ef302600fc9aed5bd6e4dd86b26e752066fea06aca05db1acca189b50e7edda090a4a95065b230948d617dc63c71ea90e691cec9ad7d943469bc2928a663fdcc7b5df9d7a70c37d9773a46800341ef123b094f0ca44223bb68bc77dcedcc808ea2eaff45fe2bce78ae6a574485be4db0145a4c95cf620572c515c58d3f6082d3f6a9f7e68420c4cd95a473090c71afbabea63812f4f6dfcf7ac6a0610c5f91c2c0a6f5fcc9e398a92d180a57baddaf1c4170db6ebd7335f11de422042c1fba9f74258b56713528244ccc00765d1362f102e4c86ba21f4435c274cc506958e87ecefe4dd81e874595c31a6bb26387a07927084c480a0acf5ac5234102d8ebeca4424e263fb537b0118fab57ee6a34922ca4ff5212365b7a9e8f8f3ed768a8b4660cf386c7b008be31600b9013fb92ed7b8adad7247a75013d766f6d6fd77ccf21668657211e7790ea6124a080e8d9567be5cc65578eb211df460e5a62e62c57a3287c5065c1e3f795753673187e3d8ff5c23aedc83e1a9d428ad5196aee6fb3ff3928b8be43450e9efe311aef0eb9d921ea00e710fbf68062ab461e0d075b79aaaf8bad484fe6032705036490c468b26a94e7193f8fa6feaff70b9b4e82780079d09c01435b69037255c44db7738d52eaa57c3c341750b910867b25b54686a8874bdafcd168c73e835f1a51a49e74e2aeca40c24ac47ade6f085657202c4c177573220dc992cbe40d6d650accc4f8b538b01a18b7012e6fd8e0e10d03ea29fd8552152f43101a62b5acd83e5410e3431187c6a365e72378f5acb4d57205e57c6c131aba1a7f2fee5b812c5740c784ecf2d5f1387e58530eecd5fbfcfad34c44309a648360a7b98b81b50f8c66e7896fe1d69ed57c6b1a8a2b583d520a41bb1040efb2f9e2a603405e93f1d63080fec6240c23b9d287038b54e45cfc41f2280860e97ca8672192d3a7e10ec09d3c2aa62018a166169bdd8d22d724caa7d1ff8956c3d418425e50c494adba44c29fbe13c7a08e329be5db377b9433ae3e4b24e6dc0ac3de091acbd4b06fd6a4d5296510c4d9b34ff884c35787f7d2d6e08d2851dd89684971a2950aaf268321b37668b92c5c1c3f95569536cb7dd6b36ed673b573c64fb26cecb2eade4405cdf0b47eae543ec948e98a89511cc7e9d06b5d2749666861aabafb580111a426605f715342a0f7f74ea4566a3707c6cdc98418fecf48665e82d14554aa1949ac10b0a619e3693e67e91560affac1c3157ccd7b2650971c2aaefda03cc52ddbaae6ad19cafe566bac5f24f0350afcd95e9ad9fe430548cb7e7d2887118977dce0b71d25d73d73680aa52d864d4facac5b55b262c16b8276b4f8fb477ddb61f3b165f21119307a1a6c64a277e1bb213085479c2694c2fb896b2bfad6f21161065a6e596d2de63d5bb6c8121ab5c388ba5f461f354ba0e8cee1b4734d0a74e44ac8791c69200006dbeebffde385fa69668b96354592f94f2f5ef18a985312e0eccc483c7324561594945b6854f41fb13bddeaacd0ba9a6ef6a60993a760328753972ac2c1183ad35178c9c0438145e6130ec185725b05d7101daf02debe257936320adcf986a9b7da172ec1c7a9f273b4d17d86f087abebd6a425858c396b9f6fb02e9b8dadbec441521b4fa09c6f1d2c27bded3ebd5495d70ad28b984637e7cf5da047edc49250f6a0de434c7e84acff9daafaa9f835e58a9d9454e5ad927855632792a43b08cd729b43b0a5e2cae6787c88fe109a05dfe27559e15165c441d1a2ef09e715a43ac9dda7de950fdbde62b3e19898fa6d834b76c242f1f347d1f5bfc752df4f0bdc96a4ddfa58cde4f898fad781c12b6f1988d407697200e061c5b3daafb0edca7b83c76658c9fa01e28ae3b786659825c9639129e6c135a528ad8e85a642fe824480b4bc4f58936d6a1a223bdb325cbc79520291ff918f2aa18badc65c65bdad79ff270ae4946835d1795f2b3f3a97b56239413be2e41da1f4a2b185f36d74590192004a714b89f4f53b553f054440e44fd5713df027a728991ee5bf7fd3a2dc435038329cc3036ee6b456a6d422449f15475373a00bf6085c1bb5b55a72de944cdd563ceb76a61951790b8a7e961a404644b48e8f85f5184a46d8f174bd0974ace08221d6bb0ca40bd6e8e3d6d132ebe75b82d785ba67e74651a3176f9b800c710905138b7bec85c9fbfad201c729ff7183fe1a0b39ea99548a8042a0dfda75ae3dfa59039e6aa9258a5722ef91bcd093a993345d8a6e59cf3ac4ddb1395e5b234a118f51827cfa632aa008506f4e0b63e9616907701f0084ce51e0458adea5c0c585a3d89159c0d3587834dad723d9f1604649036ea5f13c2dde0d44ac743d612facbbeabeef5baf38fd14ee7be327e9de249b66476dc2e4516b4801ac922ddb84d588ca01c4c58c01eb23a14737fe7042e57ee05ba7da5dc3c2039c8158a8c9cb8e14683fc04906ec7d8fb9a1e67247ea64b84960f0a1ce0ea264fe7a313fe90865a7ada670d7c0ea55642fcf169b8332e3f0163341ad898931c5fe8cf36b479559a0ffd1d090852e176b6df1abc6aed78e8f9983160d6683d74689ad1e9996bae2f30f76c14937b627dca822977713d7a01860f8adee282c3ddf3703311c03419791b24766afe58294d85bd64fbe2208245cc6b7e477e22cb492651aa7f74d3746dad20509065b0a369c09dee6cf1e849e741eb9dd98084ed74e7a9e10aa14bce88581586e870e0b99810db6641fb865f0a962fabc56423163e0bd8ee04bddf65603e8406ee5aa777059d8b59982688f0c44013793d61cd4bff46d7b6dcf37a97f07edb4af0dbc7c00612aee86961dd676933fa5e08c92c45b984861aab60791f4b07673905ddc1b54e804d292934a6f4cd0d850a5b8cfc072db13bf0932fef4a448f3d10a74570273c02cad26e4cfb5a984af874cf5a4d859312238a7bab2a71eb7a1019d6525138d831fe72a1a55e0e23a62f51480c92c466904e5c58b19af4b923bfd218058dbc6c5c26998beeeebf7926700473c2add97e9fa265f286b3fb788aa7dd59febd0c560ff3a2edf70efd810df54694e7b49062ddda0934d5f31dca8d962ab019b963e2ae4aa50c996f9759194908bd4c1eb3348cce6ae4dd540eb86fc31ce623b485ec3d21013ff2b9568aa9177ddf2456a70298761c471d1ce4487f00e6b77b0c3bd50266f0df92900b6faed715f17de35af793cdef648a8d300b44b96903cfb788cd317efe0ae2e7186e06b7341eda6e2936eae47c599c7de4dab3a45f2fbb2da32a95ca56177767792542e00ac121705f3fe7abcbe6021e5253db38aa24d76b042aa409424e5da32098fa60e1374d85b6fb4e9c4a80338ef76993e8c00f7735719405db1b2dbe26671f80c0ef10a652e39a2b2d4519dde9c454acc95881071b5dd56146cb2e6b094ebab4a1452dab9b0c419e5a604ba3c28f52051b0d3304d635f1d359ded74a3608f261ec08c36a8d6e10980ea4fa466bd44be546c0ecef9077a7ca598374ed7ab7531df0cb06c5b91c51edb8309de285e58bf1c670d220db183d9763bac82eeeb185c5f894401dc383aefefae62d101e783efa2bfc3997cd2cc29e0099b300ce4f1f4ef3f50aecf18293295253ebc02c25f35516a398dd55d5da7450a4a5da1bb796484bee1738d1688cbd8ed30d12effc40b7f33d049c4723974fef73b3c4cc238e11f77abab98061c490698b8a8581ac8161029101d8247777ae8d6ac079801462836c6bf6e19acac3e0de9f4deae54739f8adc270e69641b8dfa611b2e7a96f6b8b0c1c8c0637f4d81b67e48eb3e66dd96ca84989128d24d6c5ea7d880f8cbcdefc12a3b9b7b455efca77a91001dc39dd22e69936fe802976a5e41debd4e03c2bbb6b661a8ad17a9cf8d393a35d0303a9f8102d107a6c77e358168fa9bdc5fe14e6b7672f780a04e7da055d49e3c402782d8e7301f472dd14e5c57201844ed370636262698e7836004f99e23f43c7ebd7d483788b999b62bddd9531603d19c4289ecee1bc9e43706edd8f03a9440641a87c20fd12dcdfcc3d6cce2d30a6e92ce1bf6dc086e11cf46ad70a210da6a41d6e82f94aba26aa6ce355c1937297eb6aa13607daf45e08acac948f374fca421931f5c60935fbeda8b3b62d40b2d95a0c8d4aa2cecc5d8b520886396dc9bbc0bdf043d2ca8ed1f2c085d35b57e87c4c3783431a6ae21c43e2d0131e06cafeb60bf7344c157e48ef4ff998bb765d98e7c5927fdc8c46a57b240212931434519af3a6d0d1eeaebe9f9f9cbe394df672dcdad03af3abb1abb9e30630d69434f1a66957fc01f477ead2a5a184a38f7f80798c94b52547bd3a5d8aefe7ed8c8d950332bde02dfa31ec24b81e86c422409ec7c12326d7c370ab8bb96b7b36b8b45e24bcb5fe928b2617913a5590906df7412746d3892a6541d9d7980078ea9d3ccd3d141a0ff2e8e56add42863135f3d060e26a4ccc5eee3a9e8e8e6ee2d0c31a86620c40d92610ca9a2ee19f6b9bfd57070a82f314f21f5fc0829fad8dd95aa89ba9fc1c099990cf59b212d3cde9269ccb2e9df772aaf7fbbe00f8da98a95ffad5f8a1ee2b4c7605ac95cc79e5b94505a2dc5456d10aeb99dc30b3d0035819ffe562bd975de266ac9075c4fb56ded451849e2679fdd56cb88630c816b77c6eeb32b67df00696d606b9c8fed2ce56846af477403c88c203bfd8dda4ad4687e91ea59e147bbe504ef2059e32bc88cfb1dcdf0294d91aba1201476e8b695c53d68775d2a58fe465d7d3c9eb6e07b1d30086bcbc2bd344c2dee6755aaeef83b14c006e70d378b242de5d8df3d703296a6a43786c3cf71d77d8c5f69790cef42b0aab60c2f600bce73616c185a582a436a435a1d740b5bcea02772c44c6f600a4e916867cb77eb0f0ba2966d508e6578389292b6567b18329689eb08b93fdc95ab1d6b88d867c2889ffa719fda3a9c2420ba67821db487be14b77e44e83632fb5e67c0d450ea82042388c77cd6539904778523ab9b5bdfa532f62096e702ad46bb8e4b76b3fb8b7cc9687974df2151fc290ae0e8b565fd6ec57664c77a6bb6b2f0fb5f4f70dc7adb6d9aa672fb524881e073a3fa09e24512c1c4ea19a84bb7c1e2caede7e409e72010910005e1fb6f577903098f06a038e3a31e07b5f2aba711ac31cc9010f87230dae034bd6de896602ef2a926fbee413eff08bac488c318e011d24931d0ea47df4fc889b149cb172617e296195a7109d7d64e791bdcc4f1d948146b59b4903b7058074c79be9f6a4ceb8232b451d96e7a70591984199628e3bf616c9551bc9d5d9943e150babc6eebd94103da428aa873f5a69aed2010fa7e4350789b255a8143b7f981f86bf1d8e407654a6e916c70fd990964ee43aa335c224c126d1ae76a7d908ef1aff46b56c69f58bc85319842dad98e41a6fe9d5000b8b174f7b2b0f04d780e47ecbafd1e133bfd2c01d60bc1946573a3ca9f4e1a11731d3904f322a348ea982d531b0e6c81312112d8b6d459919e684421d071c3546a9d04ca2125dfe677b18fe479bd2415f718063c03c74897182dcd2f7aa45c8e75666411817dd1b724fd48d08899cbdb72fe74785b3a0fd11ee94edd5fba94c94e56e7fd1f2d65b2933af7d3e0684e44c98f88ac9b0a8969622a7dad5195a6d080ba636d1e5d8b0cde9de1c560fd881ec5d9b9701535913e77c8688a6d7e95db61ecd94ac02b6e36701bd8cf42895fa836ff0ecc6c6a4b5b9c688b734145e805ea5f2446a04597168866872ed9a17c10faffd604bac455031d149b7c9ab8a86fcd0bb42c4d9d9066330a93f7fc2a6f56a292edf5980fb8282aa34e1f5793451318436d19ae9e9e94b912a888261ab8c16493996c6d28da0a1b37c8feb924e2dcefae8513ffdb0fa7e0ac2e038b300341d5be10d34b93364a4eeb42f9f838acc37b241c7dd30461587c92e321a61b1347a6ad561781e0ec877cd269afe6ca5933b10e073062d3dccb481eacdba8881ca8b52d2cdb76d2c2faa315b670294a96b9ab70c1e92e955710cf3d1146bcd3b8680b859a0c306e547c507d152e7ed1eeb8d95a02bad8c784c20281e087b7c03f12aca0cce13201704b82d4981716e60fb45af0f4b8d9eaad1f379e87701aca53338587c8363e1b0a23d0216dabb07b327ee87e0b6eccad8fcc1731385f335373c35783b28b6c4b58d5c9441cc3cfee5ab96003e8f56243e84ac2b401c28c6d803c945ec52984db32876c5cf84b438f1f65da2189c6199a997d2d045a733953fcff581edd6bb9d1e30a4416043c9130e4f909ff81352989ad9ddbdfcb495beda6db04647745d33030bd0b2615c175d58392edf9946d2dd654ead2e4e24e11daecbc73d2cd4309ca6923f3ac95c868929fa41426e6e89a6e951c42c85dede2e34fccb8f22b34a1cca88ba2e8d853cd093a96594f0a8921d19a9c3faaf9cd6f1b7fd677fa483ed20f9218f45aa7dc22ecd499077d764bd3308ef0ebd4ede976c8bff7eb49bcd4e7d12bcc177e35bea45ff7554390762eaa7b8a0f5fedfd7866ea27ec63f9fd2a924141b71a53a29b91bc2537cfb8e92e3357d2080ebc8ec20dbbbdf9c8ae033bc527bdaf5b65bfb2a4a488227d49760ed77f05066cd59a58a050c0bd793162571dadd0665d046518ce74874368ecff8e34266520035b24f7c3500f01ecc24461308c33790774b7f2f48f4818da132701c76ed47098ab3b322272310620811b032024e767ddcb09a60bd1634da868f2f6736b472c86bab634099d3c7865aff3ceb265e035aceb0ed1ed937bf1564d3a41ea6c3157fd8290d43745751179a0c4ded3ad77e3b8d028927989dbf6fa711afeda81a2f21c042d69452b30f472ed5b607b0421acef38fab1066085cb171f54e7f1d2cdca8f56766ff179f944e35c996ba9c5d091b63dfcfb2ebb1b1968845cb17ab0d5f2249af98326d4cd51eb6e18c2214b3e7787e8fd1b3b9764562889ce3aa5c19b211b3ffd49da1ba92506eacd385736b38365586346c453d078ffdf57ff9ae15988fb94265ae6e0dc94dfb3abbe4a69a9b9b0acdcb8872599f6d84b1cc18e8a2395bdf599af83420b6aba35705055867dcaf137f7ef19b220adc353ae4f12219acc6b5270b6960ab8d6bdaf5882d0d1b5d5ea413c0c217ac0fd0a23bf261c5f4eac97</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">站住！！！请输入暗号！_(:3 」∠ )_</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>idea</title>
    <url>/2023/11/17/idea/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="啥？你不知道？不知道还输。你到底在期待什么？？_____:(´□`」 ∠):_____蒙暗号是没用的，或许你贿赂城主（博主）能满足你的小小的愿望好奇心¯\" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bb01410711b972baf714a72a081de345f07904acbecab333b769c06dd62d715e">76fc3ae391b3c4b89afc7f8f81acab4b9f801fe66e60cd8eb555aaaa4e722a621ecf71896bcd87f869a047b4fc1b2019d331c403b9600638916955bc4a2b949e9a293b2ad6f730e3be193d4b7ea726f295feb46a207f69ea1086ea81ddfb19851bae848f43666e5ec4852ee8a6712ec2d610eb1add1598183b4ffa6378a858ae92cbb6395c960140303e450202a660cf5219f59b40aaeef9fc0d492ab0d68b3617ac82ffee29717785cd3fa40a1fb5ae55a91c92e27f839a6a12927112284d83b7a848b05e64496540a335d8c1e80e90013b62f244b519447c274bd44e96145c65bdefdc3f58bb29d0f7c60279c1523458046189362879436061fb5505f3697268837727a20a09017506b9c39cbbb782209994544c51ec9c91c5b8a6d28dca375c6383e076a6c87019704ffed6469ffb56b6543d7579a23e9c8679648ba2cbd452f543cdb3b7d3fdf9fcdf7aa8352d27df64162d607cca045e64a45584bce03e75b1e2e490060995966e4dcbed9f61bc1f07406334534b8d6973f69ef5602f2e9af2c9ffc760607f4b115bbc971b3a27f6c6db178155e05bded73f82eeaad026b3c24b7a158b4a59c725bfe5096ee4095495f022a7464f9c31a7091c2ab23c0c17f872ed4de86471e890f54d80fcb736179e87728053ee3bd802e28fdddb74e5ed03e0a9577c105609b47d3613475e9670930df1e9c5f28eb99f38949038d9e3989effa15587f27192c7d8566e6983e8223f001d5eb4657a7d47084400b0bd68e5d4adda0fef3d0a016dbac1576a5d6e5fa87c75093bfed1a96939bdcf8f3f64a2329b417e401926bf677a7bba3caf53f8c5a90a3b041fbd78822e6862a88a2bbda289a71d4005d1d6a86e1e9cdcc642934e4853e5a7058449e5aa6a67e0c8bc2a440bc041a68441a7895ca1572afa7f1cea82cd82bed0fed00d1d7bcad94a7cee443376bc49a36a2a100fabd2a9d9ab77d0b4b8551049a6476af4856a32a33556173bae11db0de3299a6fc1b25e4b0b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">站住！！！请输入暗号！_(:3 」∠ )_</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>分支结构</title>
    <url>/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h5 id="小学数学-N-合一"><a href="#小学数学-N-合一" class="headerlink" title="小学数学 N 合一"></a>小学数学 N 合一</h5><p><strong>题目描述</strong><span id="more"></span></p>
<p><strong>问题 1</strong></p>
<p>请输出 <code>I love Luogu!&lt;!-- more --&gt;</code></p>
<p><strong>问题 2</strong></p>
<p>这里有 10 个苹果，小 A 拿走了 2 个，Uim 拿走了 4 个，八尾勇拿走剩下的所有的苹果。我们想知道：</p>
<ol>
<li>小A 和 Uim 两个人一共拿走多少苹果？</li>
<li>八尾勇能拿走多少苹果？</li>
</ol>
<p>现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。</p>
<p><strong>问题 3</strong></p>
<p>现在有 14 个苹果。要均分给 4 名同学，分不掉的苹果放回冰箱。请问：</p>
<ol>
<li><p>每位同学能分得几个苹果？</p>
</li>
<li><p>一共分出去多少苹果？</p>
</li>
<li><p>把几个苹果放回冰箱？</p>
<p>  现在需要编写一个程序，输出三个数字作为答案，每个数字一行。</p>
</li>
</ol>
<p><strong>问题 4</strong></p>
<p>现在有 500 毫升的肥宅快乐水，要均分给 3 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留 6 位有效数字，且不使用科学计数法。</p>
<p><strong>问题 5</strong></p>
<p>甲列火车长 260 米，每秒行 12 米；乙列火车长 220 米，每秒行 20 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。</p>
<p><strong>问题 6</strong></p>
<p>一个长方形长宽分别是 6cm、9cm，求它的对角线长度(cm)。直接使用 <code>cout</code> 输出。</p>
<p><strong>问题 7</strong></p>
<p>Uim 银行账户里面有 100 元。经过了下面的操作：</p>
<ol>
<li><p>往里面存了 10 元；</p>
</li>
<li><p>购物花掉了 20 元；</p>
</li>
<li><p>把里面的钱全部取出。</p>
<p>  请在每次操作后输出账户余额，并使用换行符隔开。</p>
</li>
</ol>
<p><strong>问题 8</strong></p>
<p>当半径为 r&#x3D;5，请输出圆的周长、面积和球体积。取 \pi&#x3D;3.141593。请直接使用 <code>cout</code> 输出答案，每行一个数字。</p>
<p><strong>问题 9</strong></p>
<p>一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？</p>
<p><strong>问题 10</strong></p>
<p>洛谷的评测任务是单位时间内均匀增加的。8 台评测机 30 分钟可以刚好把评测队列中的程序评测完毕，10 台评测机 6 分钟可以刚好把评测队列中的程序评测完毕，请问几台评测机可以在 10 分钟时刚好把评测队列中的程序评测完毕？</p>
<p><strong>问题 11</strong></p>
<p>小 A 跑步速度 5  m&#x2F;s，八尾勇跑步速度 8  m&#x2F;s，八尾勇在小 A 后面 100  m，他们同时起跑，请问需要多长时间八尾勇可以追上小 A？输出一个数字表示答案，使用 <code>cout</code> 直接输出。</p>
<p><strong>问题 12</strong></p>
<p>大家都知道有 26 个英文字母，其中 A 是第一个字母。现在请编程求出：</p>
<ol>
<li>M 是字母表中的第几个字母？</li>
<li>第 18 个字母是什么？</li>
</ol>
<p>输出一个数字和一个字母，使用换行隔开。</p>
<p><strong>问题 13</strong></p>
<p>小 A 有两块球形橡皮泥，一个半径是 4，一个半径是 10。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少？如果结果不是整数，则舍去小数点之后的数字。取π&#x3D; 3.141593。</p>
<p><strong>问题 14</strong></p>
<p>根据咕咕网校的预测，当课程定价为 110 元时，会有 10 人报名。如果课程价格每降低 1 元，就会多 1 名报名者（反之亦然）。如果希望总共能收到 3500 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较小的那一个。如果这个答案不是整数，则需四舍五入精确到整数。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数，表示第几个问题。</p>
<p><strong>输出格式</strong></p>
<p>根据所输入的问题编号，输出对应问题的答案。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230712194658604.png" class="" title="image-20230712194658604">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">float</span> b,c,d,e;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;I love Luogu!&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;6 4&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;3\n12\n2&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.31f&quot;</span>,<span class="number">500</span>/<span class="number">3</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;15&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">6</span>: b=<span class="built_in">sqrt</span>(<span class="number">6</span>*<span class="number">6</span>+<span class="number">9</span>*<span class="number">9</span>); <span class="built_in">printf</span>(<span class="string">&quot;%0.4f&quot;</span>,b); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">&quot;110\n90\n0&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">8</span>: b=<span class="number">2</span>*<span class="number">3.141593</span>*<span class="number">5</span>; c=<span class="number">3.141593</span>*<span class="number">5</span>*<span class="number">5</span>;d=<span class="number">4</span>/<span class="number">3</span>*<span class="number">3.141593</span>*<span class="number">5</span>*<span class="number">5</span>*<span class="number">5</span>;<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n%.4f\n%.3f&quot;</span>,b,c,d); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;22&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">10</span>: <span class="built_in">printf</span>(<span class="string">&quot;9&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">11</span>: b=<span class="number">100</span>/<span class="number">3</span>; <span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>,b); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">12</span>: <span class="built_in">printf</span>(<span class="string">&quot;13\nR&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">13</span>: <span class="built_in">printf</span>(<span class="string">&quot;16&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">14</span>: <span class="built_in">printf</span>(<span class="string">&quot;50&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="苹果和虫子"><a href="#苹果和虫子" class="headerlink" title="苹果和虫子"></a>苹果和虫子</h5><p>八尾勇喜欢吃苹果。她现在有 <em>m</em>（1≤<em>m</em>≤100）个苹果，吃完一个苹果需要花费 <em>t</em>（0≤<em>t</em>≤100）分钟，吃完一个后立刻开始吃下一个。现在时间过去了 <em>s</em>（1≤<em>s</em>≤10000）分钟，请问她还有几个完整的苹果？</p>
<p><strong>输入格式</strong></p>
<p>输入三个<strong>非负整数</strong>表示 ,<em>m</em>,<em>t</em>,<em>s</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数表示答案。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714145620724.png" class="" title="image-20230714145620724">

<p>这不简单？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m,s,t,x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;t,&amp;s);</span><br><span class="line">	x=m-s/t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714150328891.png" class="" title="image-20230714150328891">

<p>考虑到除t&#x3D;0，和苹果完整性问题，修改后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m, s, t, x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;m, &amp;t, &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= t) </span><br><span class="line">	&#123;</span><br><span class="line">		x = m - s / t;  <span class="comment">//常规计算</span></span><br><span class="line">    	<span class="keyword">if</span>(s%t) x--;  <span class="comment">//考虑是否刚好吃完的情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = m<span class="number">-1</span>;  <span class="comment">//开始吃苹果，即使没吃完，完整的苹果也少一个。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) x=<span class="number">0</span>;  <span class="comment">//t=0的情况</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出特例代入计算，没有bug，不过仍未通过检测。</p>
<h5 id="数的性质"><a href="#数的性质" class="headerlink" title="数的性质"></a>数的性质</h5><p>一些整数可能拥有以下的性质：</p>
<ul>
<li>性质 1：是偶数；</li>
<li>性质 2：大于 44 且不大于 1212。</li>
</ul>
<p>小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；八尾勇喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 <em>x</em>，请问他们是否喜欢这个整数？</p>
<p><strong>输入格式</strong></p>
<p>输入一个整数 (0≤1000)<em>x</em>(0≤<em>x</em>≤1000)</p>
<p><strong>输出格式</strong></p>
<p>输出这 44 个人是否喜欢这个数字，如果喜欢则输出 <code>1</code>，否则输出 <code>0</code>，用空格分隔。输出顺序为：小 A、Uim、八尾勇、正妹。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714152230449.png" class="" title="image-20230714152230449">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,c,d,input,x,y; <span class="comment">//abcd代表四人，xy表示两个性质。 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input%<span class="number">2</span>) x=<span class="number">0</span>; <span class="keyword">else</span>&#123;x=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(input&gt;<span class="number">4</span>&amp;&amp;input&lt;=<span class="number">12</span>) y=<span class="number">1</span>;<span class="keyword">else</span> &#123;y=<span class="number">0</span>;&#125;;</span><br><span class="line">    a=(x&amp;&amp;y); b=(x||y);</span><br><span class="line">	<span class="keyword">if</span>(x*y==<span class="number">0</span>&amp;&amp;(x||y)==<span class="number">1</span>) c=<span class="number">1</span>; <span class="keyword">else</span> &#123;c=<span class="number">0</span>;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) d=<span class="number">1</span>; <span class="keyword">else</span> &#123;d=<span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,b,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得亏学过数电和单片机，反哺了。</p>
<h5 id="闰年判断"><a href="#闰年判断" class="headerlink" title="闰年判断"></a>闰年判断</h5><p>输入一个年份，判断这一年是否是闰年，如果是输出 11，否则输出 00。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714154108172.png" class="" title="image-20230714154108172">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;input%<span class="number">100</span>||input%<span class="number">400</span>==<span class="number">0</span>) x=<span class="number">1</span>; <span class="keyword">else</span>&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Apples"><a href="#Apples" class="headerlink" title="Apples"></a>Apples</h5><p>八尾勇喜欢吃苹果。她今天吃掉了 <em>x</em> 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1 个苹果，就输出 <code>Today, I ate 1 apple.</code>；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 <code>apple</code> 这个单词后面要加上代表复数的 <code>s</code>。你能帮她完成这个句子吗？</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714155007534.png" class="" title="image-20230714155007534">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input&lt;<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today, I ate %d apple.&quot;</span>,input);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Today, I ate %d apples.&quot;</span>,input);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用？：语句也可。</p>
<h5 id="洛谷团队系统"><a href="#洛谷团队系统" class="headerlink" title="洛谷团队系统"></a>洛谷团队系统</h5><p>在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 55 分钟；而在洛谷团队中上传私有题目，每题只需要花费 33 分钟，但是上传题目之前还需要一次性花费 1111 分钟创建与配置团队。现在要配置 n* 道题目，如果本地配置花费的总时间短，请输出 <code>Local</code>，否则输出 <code>Luogu</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>((input*<span class="number">5</span>)&gt;(input*<span class="number">3</span>+<span class="number">11</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Luogu&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Local&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="肥胖问题"><a href="#肥胖问题" class="headerlink" title="肥胖问题"></a>肥胖问题</h5><p>BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 m&#x2F;h²其中 <em>m</em> 是指体重（千克），ℎ 是指身高（米）。不同体型范围与判定结果如下：</p>
<ul>
<li>小于 18.518.5：体重过轻，输出 <code>Underweight</code>；</li>
<li>大于等于 18.518.5 且小于 2424：正常体重，输出 <code>Normal</code>；</li>
<li>大于等于 2424：肥胖，不仅要输出 BMI 值（使用 <code>cout</code> 的默认精度），然后换行，还要输出 <code>Overweight</code>；</li>
</ul>
<p>现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。</p>
<p>对于非 C++ 语言，在输出时，请四舍五入保留六位<strong>有效数字</strong>输出，如果小数部分存在后缀 00，不要输出后缀 00。</p>
<p>请注意，保留六位<strong>有效数字</strong>不是保留六位小数。例如 123.4567 应该输出为 123.457，5432.10 应该输出为 5432.1。</p>
<p><strong>输入格式</strong></p>
<p>共一行。</p>
<p>第一行，共 22 个浮点数，m*,*h，分别表示体重（单位为 kg），身高（单位为 m）。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个字符串，表示根据 BMI 的对应判断。特别地，对于 <code>Overweight</code> 情况的特别处理请参照题目所述。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714191105581.png" class="" title="image-20230714191105581">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> m,k,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">    x=m/k/k;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">18.5</span>) <span class="built_in">printf</span>(<span class="string">&quot;Underweight&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">25</span>&amp;&amp;x&gt;=<span class="number">18.5</span>) <span class="built_in">printf</span>(<span class="string">&quot;Normal&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">25</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.6g\nOverweight&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“.6g”意思是输出6位有效数字。</p>
<h5 id="三位数排序"><a href="#三位数排序" class="headerlink" title="三位数排序"></a>三位数排序</h5><p>给出三个整数a*,<em>b</em>,<em>c</em>(0≤<em>a</em>,<em>b</em>,*c≤100)，要求把这三位整数从小到大排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=b; b=i;  <span class="comment">//a和b互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=c; c=i; <span class="comment">//a和c互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=b; b=c; c=i; <span class="comment">//b和c互换</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总所周知，三位数需要比较三次。也可以用数组和指针的方法。</p>
<h5 id="月份天数"><a href="#月份天数" class="headerlink" title="月份天数"></a>月份天数</h5><p>输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数，分别表示年份 <em>y</em> 和月数 <em>m</em>，以空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个正整数，表示这个月有多少天。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230715112207643.png" class="" title="image-20230715112207643">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> y,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;y,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">2</span>&amp;&amp;(y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>||y%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;29&quot;</span>); <span class="comment">//闰年二月</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m%<span class="number">2</span>&amp;&amp;m!=<span class="number">2</span>||m==<span class="number">8</span>) <span class="built_in">printf</span>(<span class="string">&quot;31&quot;</span>); </span><br><span class="line">		<span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;m!=<span class="number">2</span>&amp;&amp;m!=<span class="number">8</span>) <span class="built_in">printf</span>(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;28&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人检测不出bug，不过仍未通过洛谷测试。</p>
<h5 id="不高兴的津津"><a href="#不高兴的津津" class="headerlink" title="不高兴的津津"></a>不高兴的津津</h5><p>津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。</p>
<p><strong>输入格式</strong></p>
<p>输入包括 77 行数据，分别表示周一到周日的日程安排。每行包括两个小于 1010 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。</p>
<p><strong>输出格式</strong></p>
<p>一个数字。如果不会不高兴则输出 00，如果会则输出最不高兴的是周几（用 1,2,3,4,5,6,71,2,3,4,5,6,7 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716095447576.png" class="" title="image-20230716095447576">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">6</span>],b[<span class="number">6</span>],i,x,y;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">		<span class="keyword">if</span>((a[i]+b[i])&gt;x&amp;&amp;(a[i]+b[i])&gt;<span class="number">8</span>) &#123;x=a[i]+b[i]; y=i+<span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（好像不需要数组），仍未通过洛谷测试点(12个差一)，本人查看无bug。</p>
<h5 id="买铅笔"><a href="#买铅笔" class="headerlink" title="买铅笔"></a>买铅笔</h5><p>P 老师需要去商店买<em>n</em> 支铅笔作为小朋友们参加 NOIP 的礼物。她发现商店一共有 33 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P 老师决定只买同一种包装的铅笔。</p>
<p>商店不允许将铅笔的包装拆开，因此 P 老师可能需要购买超过<em>n</em> 支铅笔才够给小朋友们发礼物。</p>
<p>现在 P 老师想知道，在商店每种包装的数量都足够的情况下，要买够至少<em>n</em> 支铅笔最少需要花费多少钱。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含一个正整数<em>n</em>，表示需要的铅笔数量。</p>
<p>接下来三行，每行用 2 个正整数描述一种包装的铅笔：其中第 1 个整数表示这种包装内铅笔的数量，第 2 个整数表示这种包装的价格。</p>
<p>保证所有的 7 个数都是不超过 10000 的正整数。</p>
<p><strong>输出格式</strong></p>
<p>11 个整数，表示 P 老师最少需要花费的钱。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,num,a[<span class="number">6</span>],x,money;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;a[i+<span class="number">1</span>]);</span><br><span class="line">		num=a[<span class="number">0</span>]/a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>]%a[i]) num++;</span><br><span class="line">		x=num*a[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) money=x;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;money) money=x; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三角形分类"><a href="#三角形分类" class="headerlink" title="三角形分类"></a>三角形分类</h5><p>给出三条线段 a*,<em>b</em>,*c 的长度，均是不大于 10000 的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？</p>
<ul>
<li>如果三条线段不能组成一个三角形，输出<code>Not triangle</code>；</li>
<li>如果是直角三角形，输出<code>Right triangle</code>；</li>
<li>如果是锐角三角形，输出<code>Acute triangle</code>；</li>
<li>如果是钝角三角形，输出<code>Obtuse triangle</code>；</li>
<li>如果是等腰三角形，输出<code>Isosceles triangle</code>；</li>
<li>如果是等边三角形，输出<code>Equilateral triangle</code>。</li>
</ul>
<p>如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716183534384.png" class="" title="image-20230716183534384">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)	&#123;i=a; a=b; b=i;&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)	&#123;i=a; a=c; c=i;&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)	&#123;i=b; b=c; c=i;&#125; <span class="comment">//排序，方便后续判断</span></span><br><span class="line">	<span class="keyword">if</span>(a+b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b==c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Right triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b&gt;c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Acute triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b&lt;c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Obtuse triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a==b) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Isosceles triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a==b==c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Equilateral triangle\n&quot;</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not triangle\n&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍未通过洛谷测试点，本人查看无bug。</p>
<h5 id="小玉家的电费"><a href="#小玉家的电费" class="headerlink" title="小玉家的电费"></a>小玉家的电费</h5><p>夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 150 千瓦时及以下部分按每千瓦时 0.4463 元执行，月用电量在 151∼400 千瓦时的部分按每千瓦时 0.4663 元执行，月用电量在 401 千瓦时及以上部分按每千瓦时 0.56630.5663 元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数，表示用电总计（单位以千瓦时计），不超过 10000。</p>
<p><strong>输出格式</strong></p>
<p>输出一个数，保留到小数点后 11 位（单位以元计，保留到小数点后 11 位）。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718094839494.png" class="" title="image-20230718094839494">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">150</span>) y=x*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">150</span>&amp;&amp;x&lt;<span class="number">400</span>) y=(x<span class="number">-150</span>)*<span class="number">0.4663</span>+<span class="number">150</span>*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">400</span>) y=(x<span class="number">-400</span>)*<span class="number">0.5663</span>+<span class="number">250</span>*<span class="number">0.4663</span>+<span class="number">150</span>*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小鱼的航程（改进版）"><a href="#小鱼的航程（改进版）" class="headerlink" title="小鱼的航程（改进版）"></a>小鱼的航程（改进版）</h5><p>有一只小鱼，它平日每天游泳 250250 公里，周末休息（实行双休日)，假设从周 <em>x</em> 开始算起，过了 <em>n</em> 天以后，小鱼一共累计游泳了多少公里呢？</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数 x*,*n，表示从周 x 算起，经过 n天。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示小鱼累计游泳了多少公里。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718100558164.png" class="" title="image-20230718100558164">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,n,y=<span class="number">0</span>,i; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=x;i&lt;x+n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">7</span>!=<span class="number">6</span>&amp;&amp;i%<span class="number">7</span>!=<span class="number">0</span>) &#123;y=y+<span class="number">250</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>输入一组勾股数 a*,<em>b</em>,<em>c</em>（<em>a</em>\&#x3D;<em>b</em>\&#x3D;<em>c</em>），用分数格式输出其较小锐角的正弦值。（要求约分。）</p>
<p><strong>输入格式</strong></p>
<p>一行，包含三个正整数，即勾股数 a*,<em>b</em>,*c（无大小顺序）。</p>
<p><strong>输出格式</strong></p>
<p>一行，包含一个分数，即较小锐角的正弦值</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718180733934.png" class="" title="image-20230718180733934">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=b; b=i;  <span class="comment">//a和b互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=c; c=i; <span class="comment">//a和c互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=b; b=c; c=i; <span class="comment">//b和c互换</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;a+b+c;i++) <span class="comment">//用于约分</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a%i==<span class="number">0</span>&amp;&amp;c%i==<span class="number">0</span>) &#123;a=a/i;c=c/i;i--;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>,a,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的输出只是最短边&#x2F;斜边，for循环用于暴力约分。假如4&#x2F;8，第一次可约为2&#x2F;4，然后i–,使数据再次尝试约2，直到无法约2位置，然后i++,尝试约3，以此类推。</p>
<h5 id="陶陶摘苹果"><a href="#陶陶摘苹果" class="headerlink" title="陶陶摘苹果"></a>陶陶摘苹果</h5><p>陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 10 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 30 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。</p>
<p>现在已知 10 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</p>
<p><strong>输入格式</strong></p>
<p>输入包括两行数据。第一行包含 1010 个 100 到 200 之间（包括 100 和 200 ）的整数（以厘米为单位）分别表示 10 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 100 到 120 之间（包含 100 和 120 ）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。</p>
<p><strong>输出格式</strong></p>
<p>输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">9</span>],b,num,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d %d %d %d %d&quot;</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>],&amp;a[<span class="number">4</span>],&amp;a[<span class="number">5</span>],&amp;a[<span class="number">6</span>],&amp;a[<span class="number">7</span>],&amp;a[<span class="number">8</span>],&amp;a[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((b+<span class="number">30</span>)/a[i]&gt;=<span class="number">1</span>) num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h5><p>三个整数分别为 A*,<em>B</em>,*C。这三个数字不会按照这样的顺序给你，但它们始终满足条件：A&lt;B&lt;C。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行包含三个正整数 A*,<em>B</em>,*C，不一定是按这个顺序。这三个数字都小于或等于 100100。第二行包含三个大写字母 A、B 和 C（它们之间<strong>没有</strong>空格）表示所需的顺序。</p>
<p><strong>【输出格式】</strong></p>
<p>在一行中输出 A，B和 C，用一个 （空格）隔开。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716231910507.png" class="" title="image-20230716231910507">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序，从小到大</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;n;q++)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>])  &#123;<span class="type">int</span> x=nums[i];nums[i]=nums[i+<span class="number">1</span>];nums[i+<span class="number">1</span>]=x;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">3</span>];</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;nums[<span class="number">0</span>],&amp;nums[<span class="number">1</span>],&amp;nums[<span class="number">2</span>]);</span><br><span class="line">	BubbleSort(nums,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (str[i])</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">2</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ISBN-号码"><a href="#ISBN-号码" class="headerlink" title="ISBN 号码"></a>ISBN 号码</h5><p>每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 <code>x-xxx-xxxxx-x</code>，其中符号 <code>-</code> 就是分隔符（键盘上的减号），最后一位是识别码，例如 <code>0-670-82162-4</code>就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 <code>-</code> 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p>
<p>识别码的计算方法如下：</p>
<p>首位数字乘以 1 加上次位数字乘以 2 ……以此类推，用所得的结果 mod11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 <code>0-670-82162-4</code> 中的识别码 44 是这样得到的：对 <code>067082162</code> 这 99 个数字，从左至右，分别乘以 1,2,…,9 再求和，即 0×1+6×2+……+2×9&#x3D;1580，然后取 158 mod 11的结果 4 作为识别码。</p>
<p>你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 <code>Right</code>；如果错误，则输出你认为是正确的 ISBN 号码。</p>
<p><strong>输入格式</strong></p>
<p>一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。</p>
<p><strong>输出格式</strong></p>
<p>一行，假如输入的 ISBN 号码的识别码正确，那么输出 <code>Right</code>，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 <code>-</code>）。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718085518325.png" class="" title="image-20230718085518325">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> b,c,d,x,y,a[<span class="number">9</span>],i,k=<span class="number">0</span>,num;</span><br><span class="line">	<span class="type">char</span> p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d-%s&quot;</span>,&amp;b,&amp;c,&amp;d,&amp;p);</span><br><span class="line">	a[<span class="number">0</span>]=b;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)	<span class="comment">//数据是3位，利用循环逐位取数，放入数组。比如123，分别将1,2,3放入a[1]，a[2]，a[3] </span></span><br><span class="line">	&#123;</span><br><span class="line">		y=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">3</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(y!=<span class="number">0</span>) x=c/y; </span><br><span class="line">		c=c%y;</span><br><span class="line">		a[i]=x;         </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">9</span>;i++)	<span class="comment">//同上，这次数据是5位，从a[4]开始往后取数放 </span></span><br><span class="line">	&#123; </span><br><span class="line">		y=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">8</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(y!=<span class="number">0</span>) x=d/y; </span><br><span class="line">		d=d%y;</span><br><span class="line">		a[i]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)	<span class="comment">//ISBN计算公式，先求和 </span></span><br><span class="line">	&#123;</span><br><span class="line">		k=k+a[i]*(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	num=k%<span class="number">11</span>;          <span class="comment">//ISBN计算公式，再取余 </span></span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>&amp;&amp;p==<span class="number">88</span>)  <span class="comment">//条件判断与输出 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Right&quot;</span>); <span class="keyword">goto</span> Break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>&amp;&amp;p!=<span class="number">88</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-%d%d%d-%d%d%d%d%d-X&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">4</span>],a[<span class="number">5</span>],a[<span class="number">6</span>],a[<span class="number">7</span>],a[<span class="number">8</span>]); <span class="keyword">goto</span> Break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((num+<span class="number">48</span>)==p&amp;&amp;p!=<span class="number">88</span>)	&#123;<span class="built_in">printf</span>(<span class="string">&quot;Right&quot;</span>);<span class="keyword">goto</span> Break;&#125;	</span><br><span class="line">	<span class="keyword">if</span>((num+<span class="number">48</span>)!=p)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d-%d%d%d-%d%d%d%d%d-%d\n&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">4</span>],a[<span class="number">5</span>],a[<span class="number">6</span>],a[<span class="number">7</span>],a[<span class="number">8</span>],num);<span class="keyword">goto</span> Break;&#125;</span><br><span class="line"></span><br><span class="line">Break:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到一个很烦的bug,第二次提取的五位数，在DEV中，输出</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718085116792.png" class="" title="image-20230718085116792">

<p>理论上，应该输出为0-670-82162-4。单独提取部分函数出来，进行测试，测试结果正常。怀疑定义时int长度不够，遂定为long，无果。最后换了一下编译器，在VC中结果正常。</p>
]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>实用软件</title>
    <url>/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>有段时间，对于某些需求挺强烈的，但是也花了不少时间，不过可能也就那段时间用用罢了。或许可以整理一下，已经容易忘事了。<span id="more"></span></p>
<h3 id="远程屏幕分享"><a href="#远程屏幕分享" class="headerlink" title="远程屏幕分享"></a>远程屏幕分享</h3><p>单纯的一对一进行屏幕分享，按照分享的画面质量，延迟，帧率，大致可以做一个排名。当然，都是白嫖的。</p>
<p>发送方是电脑，接收方可以是电脑，或者是手机。</p>
<p>B站直播&gt;网页&gt;Skype&gt;钉钉&gt;qq</p>
<p>B站直播简单易行，除非是注意隐私，或者分享禁播游戏。</p>
<p>网页：<a href="https://easychuan.cn/">轻松传 - 传文件，传文本，传屏幕，传实时视频 (easychuan.cn)</a></p>
<p>网页分享屏幕帧率上限30帧，画面比较清晰，偶有卡顿。</p>
<p>Skype：免费注册，使用无需翻墙（或许注册的时候要），本质是一个网络电话，可以视频通话并分享屏幕，非常稳定。</p>
<p>钉钉和qq懂的都懂，不做评价。</p>
<h3 id="远程同乐"><a href="#远程同乐" class="headerlink" title="远程同乐"></a>远程同乐</h3><p>steam自带的远程同乐，Parsec(网络要求较高，需要公网，参考比特彗星黄绿灯），搭建局域网可用樱花映射（账号需要实名认证，并在支付宝扫脸，支付宝必须是实名认证时所填的身份信息并且18+，需要扫脸。软件较为良心）。</p>
<p>好吧好吧，实际上当Parsec双方都有ipv6时就可以了。什么搭建局域网一类的，都只是下载没有深究。</p>
<p>或者Radmin VPN也行，只是对方是多屏幕，对方连我电脑可以控制，我连对方则是黑屏。按理说能上网翻翻解决的，不过最后还是懒。这款软件除了操控，也可以分享屏幕等等，小巧而且网络需求没有Parsec那么高。只是Radmin只能PC对PC，而Parsec可以手机平板控制PC等等。</p>
<p>moonlight也试过，不过并没有成功，而且Parsec可以控制电脑，而moonlight也只能串流游戏。（话说moonlight给熊孩子玩倒也不用担心什么）</p>
<h3 id="桌面管理"><a href="#桌面管理" class="headerlink" title="桌面管理"></a>桌面管理</h3><img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011091253017.png" class="" title="image-20231011091253017">

<p>对于我这种已经规划好的桌面，一不小心拖动图标都是一场灾难。所以可以使用Customize Fences进行桌面管理。</p>
<img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011092703313.png" class="" title="image-20231011092703313">

<p>我个人主要是使用屏幕快照，可以将桌面图标的布局生成快照，需要复原的时候则直接根据快照复原，非常方便。</p>
<p>当然，Fences的功能远不止于此，比如双击桌面就隐藏所有图标等等。</p>
<h3 id="磁盘空间分析器-SpaceSniffer"><a href="#磁盘空间分析器-SpaceSniffer" class="headerlink" title="磁盘空间分析器(SpaceSniffer)"></a>磁盘空间分析器(SpaceSniffer)</h3><p>用于分析磁盘各文件的占用大小。</p>
<img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011093959381.png" class="" title="image-20231011093959381">

<p>扫描后的显示非常人性化，我经常用于清理不知名的大文件。<img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011094036795.png" class="" title="image-20231011094036795"></p>
<p>点开后进入下一级。（好了，现在知道steam哪个游戏那么大了）</p>
<h3 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h3><p>window在文件管理的右上角有个搜索框，用于搜索文件。不过奇慢无比，所以才有了Everything.</p>
<img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011094325127.png" class="" title="image-20231011094325127">

<p>小巧简约。</p>
<img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011094338001.png" class="" title="image-20231011094338001">

<p>搜索速度非常快，而且能一次将各盘文件都搜索出来。</p>
<h3 id="快牙PC"><a href="#快牙PC" class="headerlink" title="快牙PC"></a>快牙PC</h3><img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011094436651.png" class="" title="image-20231011094436651">

<p>老软件了，尽管win10可以在设备之间用蓝牙传输，或者使用就近共享。但是当双方面对面的时候，还是建议快牙，它的传输速度非常快，而且可以一对多或者多对一的传输。只需要一台设备建立热点，其余设备加入即可。手机电脑，手机手机之间都可以互传。</p>
<h3 id="批量改名"><a href="#批量改名" class="headerlink" title="批量改名"></a>批量改名</h3><img src="/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/image-20231011094858790.png" class="" title="image-20231011094858790">

<p>当初在vol(现在叫kox)的群里拿的，上传图源制作kindle漫画的时候，图源需要按照命名规则顺序排列，所以用到了它。</p>
]]></content>
      <categories>
        <category>储物间</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构（未完）</title>
    <url>/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="找最小值"><a href="#找最小值" class="headerlink" title="找最小值"></a>找最小值</h3><p>给出 .<em>n</em> 和 .<em>n</em> 个整数a<del>i</del> ，求这 <em>n</em> 个整数中最小值是什么。<span id="more"></span></p>
<p><strong>输入格式</strong></p>
<p>第一行输入一个正整数 <em>n</em>，表示数字个数。</p>
<p>第二行输入 <em>n</em> 个非负整数，表示 a<del>1</del> ,a<del>2</del> …..a<del>n</del>，以空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>输出一个非负整数，表示这 <em>n</em> 个非负整数中的最小值。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718190411647.png" class="" title="image-20230718190411647">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,i,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    	<span class="keyword">if</span>(i==<span class="number">0</span>) num=a[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">if</span>(a[i]&lt;num) num=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="分类平均"><a href="#分类平均" class="headerlink" title="分类平均"></a>分类平均</h3><p>给定 <em>n</em> 和 <em>k</em>，将从 1 到 <em>n</em> 之间的所有正整数可以分为两类：A 类数可以被 <em>k</em> 整除（也就是说是 <em>k</em> 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 1 位，用空格隔开。</p>
<p>数据保证两类数的个数都不会是 0。</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数 <em>n</em> 与 <em>k</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，两个实数，分别表示 A 类数与 B 类数的平均数。精确到小数点后一位。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718191544415.png" class="" title="image-20230718191544415">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,i,num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//累加</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(i%k==<span class="number">0</span>) &#123;a+=i;num=num+<span class="number">1</span>;&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;b+=i;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;n) &#123;num=<span class="number">1</span>;	n=n+<span class="number">1</span>;&#125; <span class="comment">//如果k&gt;n，完善代码</span></span><br><span class="line">	a=a/(<span class="type">float</span>)num;         <span class="comment">//取平均数。</span></span><br><span class="line">	b=b/(<span class="type">float</span>)(n-num);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f %.1f&quot;</span>,a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>仍未通过洛谷测试点。</p>
<h3 id="一尺之棰"><a href="#一尺之棰" class="headerlink" title="一尺之棰"></a>一尺之棰</h3><p>《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 <em>a</em> 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍的长度会变为 1？</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数 <em>a</em>，表示木棍长度。</p>
<p><strong>输出格式</strong></p>
<p>输出一个正整数，表示要第几天的时候木棍长度会变为 1。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718212020030.png" class="" title="image-20230718212020030">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,k,i,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) num=<span class="number">1</span>; <span class="comment">//应付测试点，当a=1时，表示第1天木棍长度为1，若不加，则a=1时，第0天木棍长度为1。</span></span><br><span class="line">    <span class="keyword">while</span>(a<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(a%<span class="number">2</span>&amp;&amp;a!=<span class="number">1</span>) &#123;a++;&#125;</span><br><span class="line">    	a=a/<span class="number">2</span>;</span><br><span class="line">    	num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="数字直角三角形"><a href="#数字直角三角形" class="headerlink" title="数字直角三角形"></a>数字直角三角形</h3><p>给出 <em>n</em>，请输出一个直角边长度是 <em>n</em> 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数 <em>n</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出如题目要求的数字直角三角形。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718213101103.png" class="" title="image-20230718213101103">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,k,i,j,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    j=a;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a;i++)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				num++;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,num);	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			j--;	</span><br><span class="line">	 &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="阶乘之和（高精度）"><a href="#阶乘之和（高精度）" class="headerlink" title="阶乘之和（高精度）"></a>阶乘之和（高精度）</h3><p>用高精度计算出!<em>S</em>&#x3D;1!+2!+3!+⋯+<em>n</em>!（n*≤50）。</p>
<p>其中 <code>!</code> 表示阶乘，定义为n*!&#x3D;*n×(n−1)×(n−2)×⋯×1。例如，5!&#x3D;5×4×3×2×1&#x3D;120。</p>
<p><strong>输入格式</strong></p>
<p>一个正整数 <em>n</em>。</p>
<p><strong>输出格式</strong></p>
<p>一个正整数 <em>S</em>，表示计算结果。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718220220977.png" class="" title="image-20230718220220977">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,i,j,k,x=<span class="number">1</span>,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    k=a;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	x=x*j;  <span class="comment">//阶乘</span></span><br><span class="line">		&#125;</span><br><span class="line">		num=x+num;  <span class="comment">//求阶乘和</span></span><br><span class="line">		k--;</span><br><span class="line">		x=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>好吧好吧，还是想的太简单了。作为阶乘和，都是大整数，int和long甚至unsigned long long都无法存储。</p>
<p>那么拓展一下高精度的知识：</p>
<p>高精度乘法使用数组和逐位计算的方法来处理大整数乘法。每个数组元素存储整数的一位数字。通过使用数组来存储每个数字，可以处理任意长度的整数。</p>
<p>以下是高精度乘法的基本思路：</p>
<ol>
<li>创建两个整数的数组表示乘法运算的两个操作数，每个数组元素存储一个数字位。</li>
<li>从低位开始，逐位相乘，并将结果累加到结果数组中的相应位置。</li>
<li>处理进位：如果某个位置的乘积结果大于等于10，则将进位部分加到高位上。</li>
<li>重复上述步骤，直到乘法运算完成。</li>
<li>最后，将结果数组转换为所需的输出格式。</li>
</ol>
<p>高精度乘法的实现可能涉及到数组的遍历、进位处理和结果转换等操作。根据具体的需求和实现方式，代码可能会有所不同。在实际应用中，还可以使用现有的高精度计算库或使用其他更高效的算法来进行大整数乘法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">void AddStaff(void);</span><br><span class="line">int StaffNum=0;</span><br><span class="line">int Staff[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AddStaff();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void AddStaff(void)  //添加员工 </span><br><span class="line">&#123;</span><br><span class="line">	int i,j,a;</span><br><span class="line">	printf(&quot;您需要录入几位员工的数据，请输入：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">	if(a&lt;=0) &#123;printf(&quot;ERROR！请输入正确的格式&quot;);&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;开始录入员工编号\n&quot;);</span><br><span class="line">		for(i=1;i&lt;=a;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;您正在录入第%d位员工的编号，输入完毕后请按回车键。\n&quot;,StaffNum+i);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;Staff[StaffNum+i]);</span><br><span class="line">			for(j=1;j&lt;StaffNum+i;j++)      //判断输入数据是否和之前的一样。 </span><br><span class="line">			&#123;</span><br><span class="line">				if(Staff[StaffNum+i]==Staff[j])</span><br><span class="line">				&#123;</span><br><span class="line">					printf(&quot;系统已收录该员工编号，请重新输入。\n&quot;); </span><br><span class="line">					i--;	</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125; </span><br><span class="line">		</span><br><span class="line">			if(Staff[StaffNum+i]/10000000==0||Staff[StaffNum+i]/10000000&gt;10)  //判断输入编号格式 </span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;请按照正确格式输入，该次输入无效。\n&quot;);</span><br><span class="line">				i--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		printf(&quot;输入成功，已录入系统。&quot;);</span><br><span class="line">		StaffNum+=a; 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void LookStaff(void)   //查看录入的员工编号 </span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(StaffNum==0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;您还未录入员工编号，请先录入。&quot;);</span><br><span class="line">	 &#125; </span><br><span class="line">	 else</span><br><span class="line">	 &#123;</span><br><span class="line">		 printf(&quot;以下是系统已录入的员工编号：&quot;);</span><br><span class="line">		for(i=1;i&lt;=StaffNum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;第%d位员工：&quot;,StaffNum);</span><br><span class="line">			printf(&quot;%d\n&quot;,Staff[StaffNum]);</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><p><strong>题目描述</strong></p>
<p>试计算在区间 1 到 n 的所有整数中，数字 x（0 ≤ x ≤ 9）共出现了多少次？例如，在 1 到 11 中，即在 1,2,3,4,5,6,7,8,9,10,11中，数字 1 出现了 4 次。</p>
<p><strong>输入格式</strong></p>
<p>2 个整数 n,x，之间用一个空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>1 个整数，表示 x 出现的次数。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230926104854978.png" class="" title="image-20230926104854978">

<p>　　原本的想法是int两三个变量，用于存储n的每位数，比如123，存储为1,2,3，利用for循坏递增进位，每次个位数+1，都分别与x进行比对。but循环难写，而且n的输入范围达不到要求。</p>
<p>　　也想到一个较为巧妙的方法，比如x&#x3D;1,当i（0 ≤ i ≤ 9）,x&#x3D;i时，输出的y都为+1，当i&gt;10,则x&#x3D;i时，输出的y都为+2，因为10的十位都有1，所以个位+1时，y也要+1，以此类推。但是这种往后增加的方法，只能写固定的for循环，除非你真的写了很多很多很多很多个for循环，不然n的输入范围取决于你的for循坏和考虑的位数。</p>
<p>　　也想过用数组存储1234的每位数1,2,3,4。不过还是不太可行，直到我看题解，看到了一个很巧妙的方法。借此写出我的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,x,y,i,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    	b=i;</span><br><span class="line">		<span class="keyword">while</span>(b)</span><br><span class="line">		&#123;</span><br><span class="line">			a=b%<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(a==x) y++;</span><br><span class="line">			b=b/<span class="number">10</span>; </span><br><span class="line">		&#125;    	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个思路，很巧妙的将n“尾巴”进行“删减”，并提取出个位数进行比较。再通过for循环实行。</p>
<h3 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h3><p><strong>题目描述</strong></p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20231009195011571.png" class="" title="image-20231009195011571">

<p><strong>输入格式</strong></p>
<p>一个正整数<em>k</em>。</p>
<p><strong>输出格式</strong></p>
<p>一个正整数 <em>n</em>。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20231009195042957.png" class="" title="image-20231009195042957">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> s; </span><br><span class="line">	<span class="type">int</span> i,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=s+(<span class="number">1</span>/(<span class="type">float</span>)i);</span><br><span class="line">		<span class="keyword">if</span>((s-k)&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法通过洛谷测试，经过chatgpt检查和提供的代码验证，代码的确可行，可能是超时了？但chatgpt的代码却通过了，还是在下面贴上它的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="type">double</span> Sn = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Sn &lt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        Sn += <span class="number">1.0</span> / n;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="金币"><a href="#金币" class="headerlink" title="金币"></a>金币</h3><p><strong>题目描述</strong></p>
<p>国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币;之后两天(第二天和第三天)，每天收到两枚金币;之后三天(第四、五、六天)，每天收到三枚金币;之后四天(第七、八、九、十天)，每天收到四枚金币….这种工资发放模式会一直这样延续下去:当连续n天每天收到n枚金币后，骑士会在之后的连续n＋1天里，每天收到n＋1枚金币。</p>
<p><strong>输入格式</strong></p>
<p>—个正整数k，表示发放金币的天数。</p>
<p><strong>输出格式</strong></p>
<p>—个正整数，即骑士收到的金币数。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20231009200509498.png" class="" title="image-20231009200509498">

<p>这简单，随便套几个循环暴力解决就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k,i,n,num,x=<span class="number">1</span>; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=x;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			n += x;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">if</span>(num==k) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		x++;</span><br><span class="line">		<span class="keyword">if</span>(num==k) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过时间复杂度太高了，无法通过，解决问题容易，优化难。这种循环的主要问题，是不知道循环的天数，如果这个能解决，就不必用while。</p>
<p>贴一个别人的答案吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k,i,j,t=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)          <span class="comment">//其实就是简单模拟，这里的i表示的是多少轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t+i&lt;=k)              <span class="comment">//如果下一轮没有超过k天，直接加平方</span></span><br><span class="line">        &#123;</span><br><span class="line">            t+=i;                <span class="comment">//记天数</span></span><br><span class="line">            s+=i*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t+i&gt;k)            <span class="comment">//如果下一轮超过k天，加这一轮与k的差乘当前轮数</span></span><br><span class="line">        &#123;</span><br><span class="line">            s+=i*(k-t);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的方法是逐层相加，并在每一步进行天数比较。其它的求解则是干脆完整的执行一轮又一轮，比如5天，先求出“1+2+2+3+3+3”，再减一个3.而我是“1+2+2+3+3”，每一步都进行的比较。看来还是太暴力了，懒~</p>
<h3 id="数列求和"><a href="#数列求和" class="headerlink" title="数列求和"></a>数列求和</h3><p><strong>题目描述</strong></p>
<p>计算1＋2＋3＋·…＋(n - 1)＋n的值，其中正整数n不大于100。由于你没有高斯聪明，所以你不被允许使用等差数列求和公式直接求出答案。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数n。</p>
<p><strong>输出格式</strong></p>
<p>输出一个正整数，表示最后求和的答案。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20231010095422150.png" class="" title="image-20231010095422150">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,n,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		num+=i;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="质数口袋"><a href="#质数口袋" class="headerlink" title="质数口袋"></a>质数口袋</h3><p><strong>题目描述</strong></p>
<p>小A有一个质数口袋，里面可以装各个质数。他从2开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。口袋的负载量就是口袋里的所有数字之和。但是口袋的承重量有限，装的质数的和不能超过L。给出L，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。</p>
<p><strong>输入格式</strong></p>
<p>—行一个正整数L。</p>
<p><strong>输出格式</strong></p>
<p>将这些质数从小往大输出，然后输出最多能装下的质数个数，所有数字之间有一空行。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20231010100127386.png" class="" title="image-20231010100127386">

<p>我只知道质数只能除1和它本身，并利用这点进行质数计算，存储到数组。当发现新的质数时，将对质数数组的和进行计算，并与输入进行比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,n,num,a[<span class="number">50</span>],x=<span class="number">2</span>,y,flag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=x<span class="number">-1</span>;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((x%i)==<span class="number">0</span>) flag=<span class="number">1</span>; <span class="comment">//判断是否为质数的标志位，不是质数标志位置1； </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)            <span class="comment">//如果发现新的质数，将存放至数组并计算已有质数和。 </span></span><br><span class="line">		&#123;</span><br><span class="line">			a[y]=x;</span><br><span class="line">			<span class="keyword">for</span>(i=y;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			&#123;</span><br><span class="line">				num = num+a[i];</span><br><span class="line">			&#125;</span><br><span class="line">			y++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;n)  <span class="keyword">break</span>;   <span class="comment">//质数和与输入比较，达到要求就结束循环。 </span></span><br><span class="line">		num = <span class="number">0</span> ;</span><br><span class="line">		x++;</span><br><span class="line">	&#125;  </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)  y++;         <span class="comment">//处理特例</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;y<span class="number">-1</span>;i++)    <span class="comment">//按需输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好吧，尽管有效，但是无法通过洛谷的编译（真的，等我做完这几个题库，以后就去力扣了，想着由浅入深。）看了答案区，才发现有个<a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC?fromModule=lemma_inlink">埃拉托斯特尼</a>筛法。好吧，这种方法的确高效，不必像我这样每个数进行判断。对于小范围的质数，达到题目的要求，我还是觉得我这个更好些。</p>
<p>而且题解区和贴吧没啥两样，不同的是贴吧真有大神。找不到简洁清晰的C语言埃氏筛，就先这样吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    float a,b,s;</span><br><span class="line">    int x;</span><br><span class="line">    a=2;</span><br><span class="line">    scanf(&quot;%f.1&quot;,&amp;s);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(a&gt;=s) break;</span><br><span class="line">    	b=2*0.98;</span><br><span class="line">    	a+=b;</span><br><span class="line">    	x++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构和选择结构</title>
    <url>/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h6 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">语句块 <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句块 <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span><img src="/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/image-20230709100009541.png" class="" title="image-20230709100009541">

<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">	<span class="type">int</span> a, b, max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入两个整数： &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">if</span> (a&gt;b) max = a;</span><br><span class="line">		<span class="keyword">else</span> max = b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d和%d的较大值是： %d\n&quot;</span>, a, b, max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>输入两个整数： 34 28↙<br>34 和 28 的较大值是： 34</p>
<h6 id="只使用-if-语句"><a href="#只使用-if-语句" class="headerlink" title="只使用 if 语句"></a>只使用 if 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123; 语句块 &#125;</span><br></pre></td></tr></table></figure>

<h6 id=""><a href="#" class="headerlink" title=""></a><img src="/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/image-20230709110223414.png" class="" title="image-20230709110223414"></h6><p>只使用 if 语句来求两个数中的较大值：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">	<span class="type">int</span> a, b, max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入两个整数： &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    max = b; <span class="comment">// 假设b最大</span></span><br><span class="line">    <span class="keyword">if</span> (a&gt;b) max = a; <span class="comment">// 如果a&gt;b，那么更改max的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d和%d的较大值是： %d\n&quot;</span>, a, b, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>输入两个整数： 34 28<br>34 和 28 的较大值是： 34  </p>
<h6 id="多个-if-else-语句"><a href="#多个-if-else-语句" class="headerlink" title="多个 if else 语句"></a>多个 if else 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件 <span class="number">1</span>)&#123;</span><br><span class="line">语句块 <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件 <span class="number">2</span>)&#123;</span><br><span class="line">语句块 <span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件 <span class="number">3</span>)&#123;</span><br><span class="line">语句块 <span class="number">3</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件 m)&#123;</span><br><span class="line">语句块 m</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句块 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>使用多个 if else 语句判断输入的字符的类别  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Input a character:&quot;</span>);</span><br><span class="line">     c = getchar();</span><br><span class="line">     <span class="keyword">if</span> (c&lt;<span class="number">32</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a control character\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a digit\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a capital letter\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a small letter\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is an other character\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a character:e↙<br>This is a small letter  </p>
<h6 id="if-语句的嵌套"><a href="#if-语句的嵌套" class="headerlink" title="if 语句的嵌套"></a>if 语句的嵌套</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123; <span class="comment">//!=表示不等于</span></span><br><span class="line">    <span class="keyword">if</span> (a&gt;b) <span class="built_in">printf</span>(<span class="string">&quot;a&gt;b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;a&lt;b\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;a=b\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers:12 68<br>a&lt;b  </p>
<p>if 语句嵌套时，要注意 if 和 else 的配对问题。 C 语言规定， else 总是与它前面最近的 if 配对，例 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b) <span class="built_in">printf</span>(<span class="string">&quot;a&gt;b\n&quot;</span>); <span class="comment">// ②</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;a&lt;b\n&quot;</span>); <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>

<p>③和②配对，而不是和①配对  。</p>
<h6 id="C-语言逻辑运算符"><a href="#C-语言逻辑运算符" class="headerlink" title="C 语言逻辑运算符"></a>C 语言逻辑运算符</h6><p>\1) 与运算(&amp;&amp;)<br>参与运算的两个表达式都为真时，结果才为真，否则为假。例如：<br>5&amp;&amp;0<br>5 为真， 0 为假，相与的结果为假，也就是 0。<br>(5&gt;0) &amp;&amp; (4&gt;2)<br>5&gt;0 的结果是 1，为真， 4&gt;2 结果是 1，也为真，所以相与的结果为真，也就是 1。<br>\2) 或运算(||)<br>参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假。例如：<br>10 || 0<br>10 为真， 0 为假，相或的结果为真，也就是 1。<br>(5&gt;0) || (5&gt;8)<br>5&gt;0 的结果是 1，为真， 5&gt;8 的结果是 0，为假，所以相或的结果为真，也就是 1。<br>\3) 非运算(!)<br>参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。例如：<br>!0<br>0 为假，非运算的结果为真，也就是 1。<br>!(5&gt;0)<br>5&gt;0 的结果是 1，为真，非运算的结果为假，也就是 0。  </p>
<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>逻辑运算符和其它运算符优先级从低到高依次为：<br>赋值运算符(&#x3D;) &lt; &amp;&amp;和|| &lt; 关系运算符 &lt; 算术运算符 &lt; 非(!)<br>&amp;&amp; 和 || 低于关系运算符， ! 高于算术运算符。<br>按照运算符的优先顺序可以得出：<br>    a&gt;b &amp;&amp; c&gt;d 等价于 (a&gt;b)&amp;&amp;(c&gt;d)<br>    !b&#x3D;&#x3D;c||d&lt;a 等价于 ((!b)&#x3D;&#x3D;c)||(d&lt;a)<br>     a+b&gt;c&amp;&amp;x+y&lt;b 等价于 ((a+b)&gt;c)&amp;&amp;((x+y)&lt;b)<br>另外，逻辑表达式也可以嵌套使用，例如 a&gt;b &amp;&amp; b || 9&gt;c， a || c&gt;d &amp;&amp; !p。  </p>
<h6 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 整型数值 <span class="number">1</span>: 语句 <span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> 整型数值 <span class="number">2</span>: 语句 <span class="number">2</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> 整型数值 n: 语句 n;</span><br><span class="line"><span class="keyword">default</span>: 语句 n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（? :）"></a>条件运算符（? :）</h6><p>语法格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式 <span class="number">1</span> ? 表达式 <span class="number">2</span> : 表达式 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果表达式 1 的值为真，则以表达式 2 的值作为<br>整个条件表达式的值，否则以表达式 3 的值作为整个条件表达式的值。条件表达式通常用于赋值语句之中。  </p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) &#123;</span><br><span class="line">       max = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       max = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = (a&gt;b) ? a : b;</span><br></pre></td></tr></table></figure>

<p>使用条件表达式时，还应注意以下几点：<br>\1) 条件运算符的优先级低于关系运算符和算术运算符，但高于赋值符。因此<br>    max&#x3D;(a&gt;b) ? a : b;<br>可以去掉括号而写为<br>    max&#x3D;a&gt;b ? a : b;<br>\2) 条件运算符?和：是一对运算符，不能分开单独使用。<br>\3) 条件运算符的结合方向是自右至左。例如：<br>    a&gt;b ? a : c&gt;d ? c : d;  </p>
<p>应理解为：<br>a&gt;b ? a : ( c&gt;d ? c : d );<br>这也就是条件表达式嵌套的情形，即其中的表达式又是一个条件表达式。  </p>
<h6 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">	语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是，先计算“表达式”的值，当值为真（非 0）时， 执行“语句块”；执行完“语句块”，再次计算表达式的值，如果为真，继续执行“语句块”……这个过程会一直重复，直到表达式的值为假（0），就退出循环，执行 while后面的代码。  </p>
<h6 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>do-while 循环与 while 循环的不同在于：它会先执行“语句块”，然后再判断表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此， do-while 循环至少要执行一次“语句块”。  </p>
<h6 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的运行过程为：<br>\1) 先执行“表达式 1”。<br>\2) 再执行“表达式 2”，如果它的值为真（非 0），则执行循环体，否则结束循环。<br>\3) 执行完循环体后再执行“表达式 3”。<br>\4) 重复执行步骤 2) 和 3)，直到“表达式 2”的值为假，就结束循环。  </p>
<h6 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h6><p>当 break 关键字用于 while、 for 循环时，会终止循环而执行整个循环语句后面的代码。 break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环 。</p>
<p>例：使用 while 循环计算 1 加到 100 的值：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//循环条件为死循环</span></span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：5050<br>while 循环条件为 1，是一个死循环。当执行到第 100 次循环的时候，计算完 i++;后 i 的值为 101，此时 if 语句的条件 i&gt; 100 成立，执行 break;语句，结束循环。  </p>
<p>在多层循环中，一个 break 语句只向外跳一层。  </p>
<h6 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h6><p>continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环。 continue 语句只用在 while、 for 循环中，常与 if 条件语句一起使用，判断条件是否成立。  </p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>童年的正午小路</title>
    <url>/2023/07/10/%E7%AB%A5%E5%B9%B4%E7%9A%84%E6%AD%A3%E5%8D%88%E5%B0%8F%E8%B7%AF/</url>
    <content><![CDATA[<p>​		在我小学的时候，蛮喜欢玩的。有邻居好友，有同学玩伴。上课学习一下，中午跑到学校附近一个类似于“托管班”的地儿。<span id="more"></span>应该是一个私人住宅，主人是原先小学的老师，应该退休了。叫“陈老师”。和班上几位同学，同校的一些校友在里头吃中午饭，年纪小的要睡午觉，大孩子则到二楼闹腾。</p>
<p>​		小学生嘛，流行什么玩什么。在那里，玩过老鹰抓小鸡，蒙过眼睛抓人，玩过弹珠，比过陀螺，也有那种砸卡。硬币大小的卡套，可以放几张圆形的卡进去。卡套两边有个小坡，可以被其他卡套滑上去。一般规则就是谁被滑上去了，卡套里的卡归就归谁了，有时候卡套也算在内。后面五六年级，就是打扑克，三国杀为主了。也有一些西游杀等等。</p>
<p>​		那附近也有一个小卖部。有卖一根葱之类的小零食。印象比较深的是小卖部有一次进了那种花钱抽奖的小纸片。5毛还是1块钱一张。同学第一次中了5块，老板娘不认账了。说这5块只能继续拿来抽卡，然后气不过，又没办法。只能再抽，不过爆率是真的高。后续是一盒纸片，给我们抽了个六成，倒是过了把瘾。后面就没再见过店里有这个了。</p>
<p>​		中午闹腾够了，下午则结伴上学去了。路途有一个废弃的房子，斑驳的锁，关不严的门。曾偷偷顺着门缝儿往里面看去。一片土地，零星的水泥，几点的杂草。还有一滩白骨和一个猫脑袋的骷髅。白骨看上去像是粉末一般，已经是一片了，看不出是什么。看那骷髅脑袋推断的。当初是很想拿出来瞅瞅的，感觉如果带到学校去，一定很酷。</p>
<p>​		也在下午结伴的时候，甩书包玩，像是电视里甩链球的动画一样，抓着书包，原地转圈甩出去。有个玩伴，丢的时候，书包正好飞向小河的方向。好巧不巧，那里正好有个小石凳，书包磕到石凳边缘。然后从石凳上缓慢滚了一下，最后还是滑下去了。冲过去的时候，书包正飘在水面上。自己当时觉得这个画面太滑稽了，笑的上气不接下气，还是叫住了前面另一个玩伴。然后他用树枝想把书包划到岸边，结果书包在水的一阵阵涟漪中反复横跳。不肯走也不肯来，小孩子的喧哗倒是惊动了附近的一位老太太。她从家中找了跟长竹竿，最后书包才得以上岸，最后作业当然是全湿了。</p>
<p>​		也是那条路，傍晚回家的时候，每每走到巷子里的时候，总会远远地见到一直猫，黑猫，但它会笑，而且笑起来特别诡异。令我毛骨悚然。它的微笑直接咧到耳根子。一向它走去，它就扭头撒丫子跑了。一连几天。那时候自己看了老哥送的《笑猫日记——寻找黑骑士》。似乎还看了《马小跳》。杨红樱的作品看了零星点点。当初是有点相信世界上有会笑的猫的，不过也没见过，想象中应该笑的很可爱。后续啊后续，终于它有一次从我面前跳了出来。瞟了我一眼，我清晰的看到它脸上有两条印。就两条黄黑色的线，从嘴巴斜着到眼睛，两边都很均匀。配合它一身黑毛，远远的看上去，就像是只看到一双眼睛，和眼睛下的一个“V”。非常渗人。还好最后还是明白的它的笑是怎么一回事。不过后面就再也没有见过它了。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>求生之路2双人分屏归档</title>
    <url>/2023/10/06/%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF2%E5%8F%8C%E4%BA%BA%E5%88%86%E5%B1%8F%E5%BD%92%E6%A1%A3/</url>
    <content><![CDATA[<p>本方式无需MOD，无需虚拟键盘等杂七杂八的玩意。可用于求生之路2本地分屏双人游玩。</p>
<span id="more"></span>

<p>按~键打开控制台。</p>
<p>ss_map c1m1 　　　　　　　　　　　　　（选地图，默认为旅馆）</p>
<details>  <summary><font size="4" color="orange">其余地图指令</font></summary>  <pre><code class="language-c">
一，死亡中心
c1m1_hotel            1旅馆
c1m2_streets          2街道
c1m3_mall             3购物中心
c1m4_atrium           4中厅
二，黑色狂欢节          
c2m1_highway          1高速公路
c2m2_fairgrounds      2游乐场
c2m3_coaster          3过山车
c2m4_barns            4谷仓
c2m5_concert          5音乐会
三，沼泽激战
c3m1_plankcountry     1乡村
c3m2_swamp            2沼泽
c3m3_shantytown       3贫民窟
c3m4_plantation       4种植园
四，暴风骤雨
c4m1_milltown_a       1密尔城
c4m2_sugarmill_a      2糖厂
c4m3_sugarmill_b      3逃离工厂
c4m4_milltown_b       4重返小镇
c4m5_milltown_escape  5逃离小镇
五，郊区
c5m1_waterfront       1码头
c5m2_park             2公园
c5m3_cemetery         3墓地
c5m4_quarter          4特区
c5m5_bridge           5桥
</code> </pre> </details>

<p>connect_splitscreen localhost 2　　　　　　（屏幕一分为二）</p>
<p>sv_cheats 1　　　　　　　　　　　　　　（添加一位玩家，算是这么理解吧）</p>
<p>ss_splitmode 1　　　　　　　　　　　　（上下分屏）</p>
<p>ss_splitmode 2　　　　　　　　　　　　（左右分屏）</p>
<p>BindToggle z in_forceuser 　　　　　　　（按z切换操控角色）</p>
<p>此后则需要手动打开按键配置，设置键鼠端的操控按键（麻烦）。</p>
<p>手柄的操控按键。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">十字键：</span><br><span class="line">↑开灯 ↓物品栏  ←医药包 →物品栏</span><br><span class="line">左摇杆：控制移动</span><br><span class="line">右摇杆：控制视角</span><br><span class="line">A跳跃 B换子弹 Y切换主/副武器 X互动</span><br><span class="line">LB蹲 LT推 RB转身 RT射击</span><br><span class="line">RS开镜 LS不知道</span><br></pre></td></tr></table></figure>



<p>如果用parsec串流，需要控制主机和客机的音量。默认是主机端开扬声器后，客机才有声音。当主机使用蓝牙耳机一类，那么客机就无法听到声音。所以可以使用混音软件。</p>
<p>MEE耳机（A1）和WDM（A2）扬声器  电脑音乐选Aux</p>
<p>附两张键鼠默认按键配置图</p>


<img src="/2023/10/06/%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF2%E5%8F%8C%E4%BA%BA%E5%88%86%E5%B1%8F%E5%BD%92%E6%A1%A3/@4@U2OQ2HTHW_Q26F76C5D.png" class="" title="@4@U2OQ2HTHW_Q26F76C~5D">
]]></content>
      <categories>
        <category>储物间</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>　　其实做一个私人博客，是很早前就有的想法。最早是追溯到小学吧，觉得这是一件很酷的事情。就像是精心的养QQ空间的花给来访者看或者是配置背景音乐（后来需要绿钻）。<span id="more"></span>大抵在初中和高中，觉得自己会有一些比较有趣的想法，或者一些想做的事情，先记着，以后会做。当然，现在慢慢淡忘了，仅有一些，记载在高中的笔记本，亦或是回忆。那时候懒，不想写东西，也不愿留下什么。拍照也仅仅是消遣。  </p>
<p>　　再后来，觉得有些东西还是记下来好。出现记录的想法，源于我当初玩过的游戏，追过的漫画，看过的小说。明明当初很沉浸，或是冒险救公主，或是探索世界，或是征战一方。但渐渐的，就忘却当初的感觉。仅有一些印象极深的bgm和cg。再看再听时，能回忆起创作者们精心构建的世界。我是想把自己此刻喜欢的东西，记录下来。最好的办法应该是把它们构建成一幅画。比如：库巴顶着豌豆射手和坚果地刺构成的防线，就为了摘到后排的向日葵送给桃花公主。亚瑟深吸一口气，死亡之眼后，左轮已回腰间。百尺外的酒瓶岿然不动，倒是有个刺猬蓝毛小子戏谑的把玩子弹。如此如此，或许可以把一生所爱，都绘成一幅画。尽管有Ai，但构图和规模都是难以企及的。<br>​　　扯远了，私人博客除了分享我个人的一些东西。也是自己的归档。电脑和手机里有太多太多东西，草草被留在各处，现在打算给它们做个坟墓，也算是朝花夕拾。也想着来访的人，仅能在那一天，能见到墓碑。不过自己懒，或许只会给碑上刻一些自己才能看懂的墓志铭。既是赛博坟墓，自应万古长存。静态博客将在云端和硬盘中进行双备份。并挂载到github。</p>
]]></content>
      <categories>
        <category>杂谈与想法</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>草履车</title>
    <url>/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/</url>
    <content><![CDATA[<p>　　草履虫只能进行简单且本能的生命活动，没有智慧。草履车也是如此，它只能进行极其简单的机械运动。作为个人第一个项目，用于练手。</p>
<p>开源地址：<a href="https://github.com/wearexc/startup/tree/main/%E8%8D%89%E5%B1%A5%E8%BD%A6">https://github.com/wearexc/startup/tree/main/草履车</a></p>
<span id="more"></span>



<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这车按规划，应该是上学期完成。当初的目标是个遥控小车，看看能不能装上能装的外设。</p>
<p><strong>白驹过隙。</strong></p>
<p>还是在这个学期，差不多期中的时候才正式开始。好在平时闲的时候进行规划，做什么样的车，心中有个大致的规划。有实验室位置的时候，则可以快马加鞭。实验室效率太高了，一天顶我一周。</p>
<p>虽然车不是啥稀奇的玩意，网上代码的项目多如牛毛，但我还是决定自己重头写一个。自己布置线路，分配资源，写代码。</p>
<p>开始挺顺利，组装车，调试。遥控车辆，也不费啥劲。</p>
<p>然后，然后就开始遇到了奇奇怪怪的问题。有次把程序跑飞了，即使是看寄存器，也定位不到错误代码，然后又莫名好了。可能因为我今天左脚迈进电梯吧。</p>
<p>然后就开始碰壁，前期想当然的规划，实行后才发现有很多bug以及不切实际。很多时候需要推倒重来，这部分主要是数据处理。先前的数据格式用着用着发现有更好的，优化一下吧。然后就大改啊大改。如果只是蓝牙遥控小车或者避障，实在乏味。所以按照自己的设想，有至少6种模式可以进行切换。每种模式尽量设计的全面些，最后整理好代码，记录好项目，归档，最后彻底摆烂。</p>
<p>这些要在一个月之内完成，必须。</p>
<p>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆分割线☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</p>
<p><strong>11月23日：</strong></p>
<p>　　总算完成了个大概，完成后发现和预想差的还是蛮多的。项目越到尾声，反而越糟心。它并没有给我带来什么成就感，很多时候我都自我怀疑，我怎么花了这么久的时间，做了一坨屎一样的玩意。不过作为练手来说，还算彳亍吧。给代码上了注释，传了github，拍照并写博客记录一下，就该让它吃灰了。后续也不会再整了，最多调整一下参数。</p>
<h2 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h2><p><strong>太乱而且太随意了。</strong></p>
<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/78534A575D2C95F3B4A1505BA1A66D61.jpg" class="" title="img">



<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/6F99BF4FB19E225C0258A828F19C0279.jpg" class="" title="img">

<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/EAADEB0D5677A93B38E748F6AC7B8F22.jpg" class="" title="img">



<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/7EBC6FFD1BA578703DA05B227F33472A.jpg" class="" title="img">



<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/58D0FD51934463A1F6300EF42C4B1AD2.jpg" class="" title="img">



<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/D7D1D2FB3E7A8820A8CC8543C09C8424.jpg" class="" title="img">



<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>草履车使用STM32，NRF24L01蓝牙模块，电机驱动，舵机。电机驱动电源由两块18650串联，芯片则是用STlink配合PDD9.9包邮小充电宝供电。</p>
<p>主机端也是使用了STM32，还有摇杆，四个按钮以及一块OLED屏。</p>
<p>原计划用W25Q64丢到小车，用它来记录操作，后续改用芯片内部闪存。</p>
<p>运行情况参考状态机：</p>
<img src="/2023/11/23/%E8%8D%89%E5%B1%A5%E8%BD%A6/13.png" class="" title="img">







<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>　　这个点踩坑最多，数据原来计划是一个8位数。前四位就是摇杆状态等等，后四位是时间。即000（状态）0（标志位) 0000（时间）。读取数据的标志位，如果置1了，则切换到下一个状态。后来发现了丢包问题，想要每次传输的数据对方都成功接收，是不可能的。标志位不可取。</p>
<p>　　然后为000（摇杆）000（标志位）00（速度），时间存到另外的数组。三个数，三个标志位，表示不同的模式。后来发现不够用，干脆改为真值表吧。</p>
<p><strong>摇杆真值表</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>无法读取摇杆，error</td>
</tr>
<tr>
<td>001</td>
<td>y+</td>
</tr>
<tr>
<td>110</td>
<td>y-</td>
</tr>
<tr>
<td>010</td>
<td>x+,y+</td>
</tr>
<tr>
<td>101</td>
<td>x-,y-</td>
</tr>
<tr>
<td>011</td>
<td>x+,y-</td>
</tr>
<tr>
<td>100</td>
<td>x-,y+</td>
</tr>
<tr>
<td>111</td>
<td>摇杆其它状态</td>
</tr>
</tbody></table>
<p><strong>模式真值表</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>实时控制</td>
</tr>
<tr>
<td>001</td>
<td>观察模式</td>
</tr>
<tr>
<td>010</td>
<td>跟随模式</td>
</tr>
<tr>
<td>011</td>
<td>避障模式</td>
</tr>
<tr>
<td>100</td>
<td>睡眠模式</td>
</tr>
<tr>
<td>101</td>
<td>启动记录</td>
</tr>
<tr>
<td>110</td>
<td>启动回溯</td>
</tr>
<tr>
<td>111</td>
<td>记录操作</td>
</tr>
</tbody></table>
<p><strong>速度真值表</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输入</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>无速度</td>
</tr>
<tr>
<td>01</td>
<td>1档</td>
</tr>
<tr>
<td>10</td>
<td>2档</td>
</tr>
<tr>
<td>11</td>
<td>3档</td>
</tr>
</tbody></table>
<p>　　速度的改变是依靠按下的摇杆。但它的中断一言难尽。我原计划是 0 , 40 , 70 , 100。每按一次，切换一次档位，但摇杆的中断会迅速触发两次，在中断的代码上我无法规避。除非在中断里进行计数，根据计数来切换档位。感觉太麻烦了，所以实际情况是舍弃了0。以40为基础状态，每次按+15（因为它会触发两次，则是+30）。</p>
<p>　　最后让我纠结很久的是记录操作的时候，如何记录操作和时间，记录和存储的格式是怎样的。这个点卡了我很久，也让我多次推倒重来。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>　　这个原计划是小车对蓝牙模块和W25Q64进行写入读取，确保设备正常。然后发送数据给主机，主机收到后进行判断，数据没问题，则显示初始化成功，并向小车回传数据。</p>
<p>　　<strong>废弃原因：</strong>太麻烦了（懒得写两蓝牙的收发切换互传），并且的确没啥设备需要检测。</p>
<h3 id="实时遥控"><a href="#实时遥控" class="headerlink" title="实时遥控"></a>实时遥控</h3><p>　　读取摇杆状态并通过蓝牙发送，小车只需要傻傻接收数据，丢给驱动函数执行就行了。值得一提的是我给它设置了警告位，当它有一段时间没有收到蓝牙信号，则自动停下，并发出警告。只有复位后才能继续运行。算是防跑丢吧。</p>
<h3 id="观察模式"><a href="#观察模式" class="headerlink" title="观察模式"></a>观察模式</h3><p>　　舵机配合超声波，对各方向进行探测，数据传给主机。每n次探测，小车将切换为接收模式，看看有没有收到数据，如果收到，表示主机退出探测，小车也应该退出。退出后将超声波传感器复位。</p>
<p>　　其实一开始打算整个雷达图，然后实在实在是懒得画懒得调试。最后主机的界面感觉还不错。</p>
<h3 id="跟随模式"><a href="#跟随模式" class="headerlink" title="跟随模式"></a>跟随模式</h3><p>　　根据超声波传感器的数据，加个if判断。距离小了就像前，距离大了就退后。值得注意的是需要设置一个阈值，否则会因为误差的原因，即使距离达到要求，小车也会鬼畜前后的运动。（目前我设的阈值好像低了。）</p>
<h3 id="避障模式"><a href="#避障模式" class="headerlink" title="避障模式"></a>避障模式</h3><p>　　赶鸭子上架，参数还需调试，有点摆烂，不想调了。而且因为超声波传感器的位置比较高，它的避障效果并不好，除非是墙。这没啥办法，传感器位置低了，没法进行观察模式（因为会扫到两侧轮子）。</p>
<h3 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h3><p>　　按照我的想法，它应该是关闭所有时钟，内核等等，只有蓝牙模块工作，收到信号后进行唤醒。</p>
<p>　　后来了解到STM32的低功耗模式，最后发现，只有睡眠合适比较合适。但睡前还是需要手动关闭时钟。其它模式“睡的太死”了。这个模式没有深究。仅是调用了一个睡眠函数。</p>
<h3 id="记录操作"><a href="#记录操作" class="headerlink" title="记录操作"></a>记录操作</h3><p>　　<strong>这玩意我整了老久了。</strong></p>
<p><strong>设想情境：</strong></p>
<p>启动该模式，将记录用户操作，数据存储置W25Q64。记录完毕后，将回溯用户操作，比如前进的小车，回溯后将倒行。</p>
<p>数据格式为8位，高3位存储摇杆的状态，低5位存储记录时间。</p>
<p><strong>方案1:</strong></p>
<p>设想车辆控制端同步时序，在同一个200ms时间片内，控制发送命令数据，车辆存储，车辆状态200ms更新一次。因为无法同步时间片，而且担心传输丢包，卒。</p>
<p><strong>方案2:</strong></p>
<p>发送端同时发送命令和时间，车辆只需要处理，记录即可，命令更新时，车辆状态也随之更新。因为无法同时处理车辆状态，接收数据而卒。个人想法是边接收，边处理并放置缓存区。但因为某种原因，无法完成。本来不是啥复杂的玩意，但是遇到了奇怪的Bug,定义的全局变量会因为蓝牙模块的一个操作函数改变。摸不着头脑。</p>
<p><strong>方案3：</strong></p>
<p>发送端发送已处理的数据，车辆仅做傻瓜式接收，这总行了吧。原先不这样处理，是担心操作端的中断会打乱时序。并且操作端200ms才发送一次数据，这段时间足够车辆接收并处理数据了。</p>
<p>好吧好吧，我还是太理想了。</p>
<p>我现在两难了。</p>
<p>车辆接收数据，不能使用DMA。因为DMA太快了。会导致很多重复的数据被一直搬运，并且DMA只负责搬运，后续的处理会很麻烦。那咱退一步，每次接收数据后触发一次搬运不就行了？那不好意思，硬件触发DMA搬运，虽然每次可以很迅速的搬运，但是搬运过去的地址需要增加。而DMA似乎只能在初始化的时候配置次数，由此进行连续搬运自增地址。</p>
<p>这导致了如果想使用这种方法，则需要不断用软件更新DMA地址。这会导致数据无法迅速搬运，进而丢包。</p>
<p>那么就是有DMA却无法用吗？。。。</p>
<p>丢包率达到10%~20%,太夸张了。。。。。。</p>
<p><strong>方案4：</strong></p>
<p>下调发送端发送时间，改为500ms发送一次，测试丢包率。不行啊，即使调到1s发送一次，丢包仍不可避免。应该思考如何处理数据并进行优化了。似乎又要推倒重来。</p>
<p><strong>当时：</strong></p>
<p>大概是遇到了踩内存，全局变量只要涉及到蓝牙，就会被改。所以我的处理方法是定义一个局部变量，并使用while循环来事变量计次。记录完成后将使用DMA转运到另一个数组。作为缓存器数组还算够用，倒也用不到W25Q64，先实现功能，再完善吧。</p>
<p>目前是小车接收数据存至数组，操作记录完毕后使用DMA转运到另一个数组存起来。数据格式为原生数据，回溯时将数据的摇杆位取反。并使用定时器，每200ms将读取一次数据进行更新。</p>
<p>回溯勉强算是实现了。遇到踩内存BUG太难受了，所以代码很烂，用代码弥补BUG。除非能解决BUG，不然一优化就无法运行。</p>
<p><strong>最后：</strong></p>
<p>主机每200ms发送一次数据，小车接收后存放至临时数据，结束记录后，将用DMA转运至FLASH数组，并记录数据个数，放到FLASH数组首位。FLASH数组将数据记录到内部闪存。每次上电初始化，将读取FLASH至FLASH数组。播放和回溯操作将根据FLASH数组的数据进行。</p>
<h3 id="启动记录"><a href="#启动记录" class="headerlink" title="启动记录"></a>启动记录</h3><p>通过TIM2，每200ms读取一次FLASH数组数据，丢到驱动函数。然后自增，下一个200ms就能读取数组的下一个数据。至于读取次数，参考FLASH数组第一个数据，它记录了数据个数。</p>
<h3 id="回溯模式"><a href="#回溯模式" class="headerlink" title="回溯模式"></a>回溯模式</h3><p>也是通过TIM2，操作过程和启动记录差不多。只是执行顺序是从后往前。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大体上还是完成了，花了大致两周。有空就钻实验室捣鼓，花的时间还是蛮多的。增加了不少调试经验，吸取的教训就是数据格式这类了。项目没规划好，导致后续需要返工，为了更合理的代码。</p>


<p>　　草履车就像这鸟，当初出现踩内存的BUG，但还是硬着头皮写了下去。倒也能跑。后续发现是蓝牙接受数据的代码，数组越界了。后续修了BUG，大改了很多地方，一度觉得代码烂就烂吧，BUG能跑起来就行了，非常想摆烂。只是后续进度比我想象的快了很多。在写出了整体框架，规划并确定好了资源。后续也只需要随便往里面填些简单的代码。随便测试一下，然后觉得也就这样吧。感觉自己花了这么长时间，就整了个这么个没啥用的玩意。多少有点失望。</p>
<p>　　作为第一个练手的项目，选的还是比较经典的小车，尽管网上有很多实例可以参考，但还是自己一点点规划资源，写了出来。整个过程，第一个比较满意的就是数据规划了。一个8位，规划好了摇杆，模式和速度，个人觉得还是蛮合理。摇杆的真值表，相反的状况还特意取反，就是为了回溯做准备。第二个满意的就是观察模式。主机的界面还行。</p>
<p>　　尽管能记录操作并且执行，但我总觉得会有些BUG。我并没有对时间，数组这类进行严格的规划，当记录的操作过久或许会出现问题。自己也没有给它规划好上限。</p>
<p>它还有很多可以优化的地方，但就先这样吧。</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>说说(2023)</title>
    <url>/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/</url>
    <content><![CDATA[<p>　　<span id="more"></span>曾在初中高中的时候，想过说说的意义。当初是觉得别人发一条说说，很多人点赞，好厉害的样子。当时自己是不爱发说说的，那时候有相机记录生活，有kindle阅读世界，也有游戏机。不过到现在，自己倒是很平常的分享自己的日常了，说是分享，其实更多是记录，记录自己的生活，所以也开始发说说了，原本是仅自己可见，不过有些事，还是希望能让更多人知道。像是传教般，也渴望有人能在自己感兴趣的东西上交流。原来我的好友里，也有对这方面有兴趣的人啊。。。。。。不过直到现在，还是觉得自己记录就好了，或许现在还不习惯博客的载体，觉得比动动手指，发个QQ空间或者朋友圈要麻烦的多，希望自己能在这记载。相较于云上的存储，自己更安心能在本地，或者硬盘上存储自己的回忆。</p>
<h3 id="2023-7-26"><a href="#2023-7-26" class="headerlink" title="2023-7-26"></a>2023-7-26</h3><p>　　虽然她中考考差了，不过也是走出来了。倒是和之前想的一样，不过调整的时间还是蛮久的。这有点超乎意料，决定再复读一年也蛮好。希望她能加油，湖南的教育真的是太卷了。如果我以后有孩子，不希望看到ta和她一样。真的太累了。她决定暑假好好玩玩。倒也行。反正8月13号开学，也快。当是劳逸结合吧。</p>
<h3 id="2023-7-XX"><a href="#2023-7-XX" class="headerlink" title="2023-7-XX"></a>2023-7-XX</h3><p>　　因为实际上自己是8月14才决定试着写博客。这些事情或许是回忆，不过都有些繁琐。博客美化的挺满意的，因此也很乐意用它记述。不过本来是以说说为目的，到后面可能会变成日志了。还是决定记载后面的事吧，这个暑假，亦失亦得，事不少。</p>
<h3 id="2023-8-14"><a href="#2023-8-14" class="headerlink" title="2023-8-14"></a>2023-8-14</h3><p>时间过的好快，还有半个月就开学了。计划还是赶不上变化，自己应该在这个暑假，把车车搞好，小四轴焊好，至少调试没问题，四轴的深入研究可以等到以后。</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/image-20230814235033738.png" class="" title="image-20230814235033738">

<p>2023年9月8日，《YOSHIKI：UNDER THE SKY》记录片开播了，我觉得叫《天空之下》还不错，或许可以期待一手，不过没有到中国上映，也是偏冷门，希望能在10月初能看到资源，并且有翻译。这可以期待一手的，当初也是因为纪录片，才对X  JAPAN感兴趣。或许天空之下能带给我更多的惊喜。（但是林老板鸽了6年的新专辑呢？不会真打算10年磨一剑吧。。）</p>
<h3 id="2023-9-3"><a href="#2023-9-3" class="headerlink" title="2023-9-3"></a>2023-9-3</h3><p>新学期了，今天发教材，发现stm32那本书我买过？还稍微看了一下。不过一般还是去B站看的。（突然感觉我又可以翘课了）</p>
<p>贴一下，我原本是看到画才关注画师（優子鈴），觉得色彩很棒。</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/20230903_152234.jpg" class="" title="20230903_152234">

<p>后面喜欢这幅画的神情，不过上色感觉有点杂</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/20230901_150639.jpg" class="" title="20230901_150639">

<p>将我妹的小玩意布置了一下，似乎还不错？</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230901233238.jpg" class="" title="IMG20230901233238">

<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230902001659-16937269066041.jpg" class="" title="IMG20230902001659">

<p>（或许整理好电脑桌面再拍会更好些)。</p>
<h3 id="2023-9-5"><a href="#2023-9-5" class="headerlink" title="2023-9-5"></a>2023-9-5</h3><p>看到鸽子，理解鸽子，成为鸽子。</p>
<h3 id="2023-9-7"><a href="#2023-9-7" class="headerlink" title="2023-9-7"></a>2023-9-7</h3><p>年轻真好，博爱真好。</p>
<p>　　</p>
<p>　　</p>
<p>　　</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/image-20230907193520666.png" class="" title="image-20230907193520666">

<p>难得今天大更一下，灾难性的目录栏，自己甚至考虑到要更换音乐插件，为底部模式了，然后是各种头疼，自己当初可是东一铲西一铲，自己都不知道该翻哪里的屎堆，所幸只是hexo解析md目录只能支持逐级目录，而我经常越级，改好后上传，还算可以。</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/image-20230907194355312.png" class="" title="image-20230907194355312">

<h3 id="2023-9-13"><a href="#2023-9-13" class="headerlink" title="2023-9-13"></a>2023-9-13</h3><img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/Screenshot_2023-09-13-20-25-16-34_0b2fce7a16bf2b7.jpg" class="" title="Screenshot_2023-09-13-20-25-16-34_0b2fce7a16bf2b7">

<p>　　想不到这么快就48周年了啊，时间过得真快，这是我入坑pinkfloyd的歌。虽然当初乐队的其它歌一首也听不进，但有一天，我听不惯的歌，它的旋律在我心中响起，从此就一发不可收拾了一段时间。看到类似的构图，有人在底下评论“wish you were here?”仍会觉得感动。似乎真有可以共鸣的人。不过顺提一嘴，现在看哆啦A梦比小时候感动多了，似乎更能理解藤子老师构筑的世界。不过我要是有一件道具能让我喜欢的人也喜欢我，那就好了。或许自己以后也不需要这个道具。</p>
<h3 id="2023-9-22"><a href="#2023-9-22" class="headerlink" title="2023-9-22"></a>2023-9-22</h3><p>　　今天把我妹的小玩意重新摆了一下，感觉还不错！</p>
<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230922001205.jpg" class="" title="IMG20230922001205">

<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230922001359.jpg" class="" title="IMG20230922001359">

<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230922000826.jpg" class="" title="IMG20230922000826">

<img src="/2023/12/31/%E8%AF%B4%E8%AF%B4(2023)/IMG20230922001554.jpg" class="" title="IMG20230922001554">

<p>　　可能这是小废灯唯一的用处了。（不得不说磨砂的光线真的比全透的好）。看着就感觉我是个生活讲究，富有高雅情操的人。</p>
<h3 id="2023-9-27"><a href="#2023-9-27" class="headerlink" title="2023-9-27"></a>2023-9-27</h3><p>　　期待国庆ing…..</p>
<p>　　收到老哥反馈博客评论系统炸了，后看上线一看是给我归档了，可能是最近一个月没有API？又想着这个评论系统需要翻墙，本来打算换一个，不过Waline实在太主流了，评论系统的管理也很轻松。自己引入系统或者维护都需要网上大量的经验，怕自己没地方抄，这方面属于知识盲区，没有独立解决问题的能力。</p>
<p>　　还是决定不换系统吧，国内无法访问或许有其他办法，现在已经在<strong>EU.org</strong>上申请注册了一个域名了，（当然是白嫖的），坐等申请结果。或许能解决这个问题。</p>
<p>　　尝试引入加密博客，当然，都是自己的小秘密一类，现在比较担心的，只是挂载在github容易被破解？（一般没人这么闲的吧）。加密博客应该不难，希望自己不要滥用。如果能实现自动定期开放，那么Tomb的功能也能实现了。 不过自己希望能在进入加密博客时，背景和挂件与首页不同。比如炫酷乱飞的七彩代码，阴暗幽冥的BGM，仿佛你发现了美丽的shelter暗藏在阴影处的秘密！或许会很好玩吧，或许。。。</p>
<h3 id="2023-10-8"><a href="#2023-10-8" class="headerlink" title="2023-10-8"></a>2023-10-8</h3><p>　　国庆带电脑回去，结果忘带充电器了，包括nds和3ds都没带。最后还是捡起了我吃灰的kindle，看着里面一大堆杂乱的漫画。当然想整理，却发现只能在kindle设备上一本一本的勾选，繁琐。我无法在电脑上像建文件夹一样对漫画归类。然后开始越狱，然后发现自己的版本过高，即使是短接或者TTL，都没有公开的办法。（当然，淘宝店可以）。随后还是作罢，这笔账我先记着。亚马逊都退出中国了，给你关上门的时候，顺手帮你把窗给关了。临走前升级系统，堵了各种漏洞。（当然，老任的3ds也是，所幸我还是手快）。</p>
<h3 id="2023-10-17"><a href="#2023-10-17" class="headerlink" title="2023-10-17"></a>2023-10-17</h3><p>　　原本用的评论系统，只能翻墙才能评论，听闻申请了一个二级域名替换一下就行了，不过向EU,ORG申请的域名迟迟没有结果，用阿里云申请的域名捣鼓的又不行，涉及了太多了知识盲区，索性更换了一个系统——畅言。但个人其实非常不喜欢它，评论需要登录（最主要原因），不喜欢样式和冗余的管理系统。不过安装还是挺简单的。等申请的域名下发了，再换回Waline。</p>
<h3 id="2023-10-28"><a href="#2023-10-28" class="headerlink" title="2023-10-28"></a>2023-10-28</h3><p>　　申请的域名还是没有消息，另外，如果我真有个妹妹，我感觉我都要疯了。感觉现实没有想象中的那么美好。</p>
<h3 id="2023-11-6"><a href="#2023-11-6" class="headerlink" title="2023-11-6"></a>2023-11-6</h3><p>　　大师居然拍毕业照了，突然发现时间过的好快。忽然就有些迷茫，问了大师毕业去向，她也不知道。不论如何，自己似乎有些迷茫，或许真的时不我待了吧。算了算时间，我也刚好和姐一起毕业了。想起前些天找老师交流，或许我并不是特别热爱这行，但是又觉得这行比较轻松摸鱼，动动手也能整些小玩意玩，毕业后自己比较满意的，就是随便找一家公司，当个摸鱼的上班族。</p>
<p>　　似乎也不过如此，总感觉会和姐和大师渐行渐远。我妹的话，至少也有3年吧。3年后看缘分。我现在不知道自己的情感需求是什么了。有时候觉得自己身边拥有一切，但似乎都可以别离。现在是我妹，以后呢？</p>
<p>　　或许以后上班摸摸鱼，下班打打游戏，然后再想办法沉浸一个个世界。在对世界的感知中消磨时间，应该再好不过了。</p>
<p>　　但现在的确没什么时间了，多少得加把劲。我现在的野心就是混入好公司，然后摸鱼。轻松上班拿薪，下班享乐。尽可能长时间的享乐才是我的目标。</p>
<h3 id="2023-11-7"><a href="#2023-11-7" class="headerlink" title="2023-11-7"></a>2023-11-7</h3><p>博客文章的插入图片出了问题，网上四处搜索，翻代码，最后还是靠备份解决的。感谢我的未卜先知。</p>
<h3 id="2023-11-11"><a href="#2023-11-11" class="headerlink" title="2023-11-11"></a>2023-11-11</h3><p>　　昨晚嵌入式老师让我联系班主任要个实验室座位，今天就坐上了，感觉倍有效率。直到我遇见了一个BUG，我的蓝牙通讯模块死活无法发送和接收。检查，能读取设备状态和寄存器。先调试发送，关闭自动应答，失能接收通道等等。就单纯的发送然后读取寄存器，发现发送正常，然后又单独调试接收。接收寄存器是空的，也正常吧。？？？给我折腾了五六个小时，最后想起SPI时钟可能不对。</p>
<p>　　移植别人代码的时候，就看到人家专门写了函数用于控制SPI时钟，当初没想这么多。因为我的蓝牙和SPI是两份文件，懒得改，先跑起来再说。然后果然跑起来了，还没出错，美滋滋啊美滋滋，就抛到脑后了。</p>
<p>　　现在长记性了，当初SPI2时钟是128分频，也就是288k。反正蓝牙SPI手册里说了，0~8M。结果出现了奇奇怪怪的问题，人麻了。</p>
<h3 id="2023-11-21"><a href="#2023-11-21" class="headerlink" title="2023-11-21"></a>2023-11-21</h3><p>​		</p>
<p>　　昨晚花了一晚上，整了OLED屏，对图片进行二值化和取值的时候，还是有点点失望的。突然觉得嵌入式有点像一滩死水，这个行业并没有我想象的宽广和包容。23年了，最好用的，最广泛的仍是02年的一款取模软件。对于各种项目或者例程，看着也总有“也就那样”的感觉。</p>
<p>　　它有点像是制造业，只要安稳的运行即可。虽然感觉不可能，但我最想去的公司还是任天堂。我觉得近年来，或许只有游戏，才能看到点意思。我挺喜欢任天堂的软硬件结合，由nds和3ds管中窥豹。</p>




<p>　　这是我目前的草履车，现在，这只鸟要靠翅膀飞了。我现在很有惰性，实在懒得改。草履车的进度还是太慢了，从10号开始到现在。草履车只完成了一半，它还需要超声波的部分，然后加以完善。</p>
<p>　　开始做的有点意思，然后感觉啥啊，我花了这么长时间，才这点进度。而且很无聊，无非就是几个PWM，定时器，ADC，外加一些数据管理和格式。它花费的时间比我想象的多很多很多。有时候还是挺有挫败感的。我并没有感觉到自己在创造什么（虽然一开始也打算是一个练手的项目）。</p>
]]></content>
      <categories>
        <category>说说</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>远古的啊哈C</title>
    <url>/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/</url>
    <content><![CDATA[<p>　　在我小学六年级的时候，老哥给我买了本小学生坐在马桶上都能读懂的Ｃ语言书《啊哈Ｃ语言》。那时候老哥应该大学在读，大概是本着培养兴趣把这本书塞给我。当初对游戏着迷。家人们抱着“你那么爱玩游戏，做一个游戏给别人玩”的想法鼓励我敲敲代码。<span id="more"></span>虽然在小学生看来，对着电脑写代码就像黑客一样酷炫。看着满屏滚动的代码和窗口，自己动动手指，就能在世界的某个地方引起骚乱和轰动。亦或者是黑入某个企业或政府的网站，把主页改成“ＸＸＸ到此一游”。然后坐等媒体宣传，国家招安。但很快在过早的年龄，体验到头秃的感觉。</p>
<p>　<img src="/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/001.jpg" class=""></p>
<p>　　谁能想象，一个正值童年的小子，看着书对着电脑一个字母一个字母的敲。边敲边抓脑袋，痛苦着思考示例程序的代码逻辑，头发大把大把掉。真是童年的梦魇。</p>
<p>　　怎么可能？！</p>
<p>　　事实上，当自己用‘＃’和‘＠’等一些特殊字符，仿照书上手打了一两幅走迷宫的地图，便放弃了。又麻烦又不好玩。早早明白了做游戏是多累多无聊的事情。而且看了那么久书，也没教人什么好玩的东西。索性丢书逛论坛去了。论坛有不少人的示例程序，自己copy别人的代码，在电脑上跑着玩。现在才明白，这才是程序猿的正确打开方式。Ctrl+C和Ctrl+V使我在放弃后，仍能兴致勃勃的翻阅代码。</p>
<p>　　印象较深的是Ai对话和一款文字游戏《勇者斗恶龙》。Ai对话也不算Ai，更像是本字典。你填入提问的答案，它才会回答。不然就是不知道，不清楚。虽然交互上比现在的ChatGpt更方便调教，但是也极度无聊。或许大家交换自己的Ai，才会有点玩头。《勇者斗恶龙》应该是我第一款接触到的文字游戏。因为几个选项暴毙魔界后，便想着修改源码。抓耳挠腮的反复翻看几千行的代码，瞎改。不过有点小聪明，知道哪些地方不能动，哪些地方改了也白改。但还是无果。随后这份源码便保存在我的ＱＱ日志里，仅我可见。</p>
<p>　　<img src="/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/002.png" class=""></p>
<p>　　其他的代码，就是贪吃蛇推箱子这种无聊小游戏。或者是让运行框显示烟花啊，在黑色背景下滚动的绿色数字，满足一下童年对黑客的幻想。但自己也知道这些只是嚎头而已。稍稍有点意思的，也只是一些像病毒一样的恶作剧。比如超多的弹窗，再怎么点叉也叉不完。弹出个窗口，给你１分钟让你承认你是猪，不承认，叉掉或者时间到了，电脑就会强制关机。或者模拟蓝屏，但是能用任务管理器清掉，或者按Ｅｓｃ就能使全屏变窗口。又或者是一个乱动的鼠标，只能靠自己的能力，用键盘调出任务管理器，再用鼠标点那个程序。至于怎么点，那只能看你了。实际上乱动的ＣＤ不长，也可以迅速摸过去点一下。当然，自己也能设置ＣＤ，但是再短，自己也关不掉了，只能重启。这些恶作剧小程序，给我改了个名，上传到班群去了。觉得最有搞头的鼠标乱动，命名为“三维弹珠”，其他的冠以电脑课学过的软件。希望能有人下载打开，然后看到异常的电脑大惊失色，慌忙的喊大人过来。不过到现在为止，除了我，也没什么人下过。自己也没听过关于隐藏在群文件之中“病毒”的小道消息。　　</p>
<p>​			<img src="./003.png" style="zoom:75%;" /></p>
<p>　　后来，玩的差不多了，便丢在角落了。小孩子坐不住，谁会搁这电脑前坐一天，薅自己的头发写代码呢？哦，大一开始学Ｃ语言是这样的。大二开始学Ｃ５１和ｓｔｍ32标准库也是这样的。还好从小就深通ｃｏｐｙ的精髓，毕竟连牛顿也是站在巨人的肩膀上。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐启蒙</title>
    <url>/2023/07/16/%E9%9F%B3%E4%B9%90%E5%90%AF%E8%92%99/</url>
    <content><![CDATA[<p>​		其实我听歌的时候算晚的了。尝试寻找，选择自己喜欢的音乐，大抵是高中的时候。在此之前，我甚至不听歌，觉得没啥意思。</p>
<span id="more"></span>

<p>​		不过，漫长岁月里，我也不可能完全没听过音乐，童年里，有小学音乐课的《外婆的澎湖湾》，有家里点读机的《鲁冰花》，也有老哥唱的《风云决》，老爸兴起常哼的《好汗歌》。再着就是烂大街的凤凰传奇，因为在广东的缘故，身边也有人听beyond的《不再犹豫》(不过也是很久以后才发现的)。然后自己感觉我能和一首歌的旋律同步一样，就是没听过的歌，能认真的让自己脑中的旋律和它同步。不过有时候一些变奏也跟不上。</p>
<p>​		即使如此，仍觉无感。似乎我的童年只有纯粹的玩乐。我理解不了旋律，对歌词无感。觉得无非就是爱恨情仇，实在不太感冒。对歌星的了解也仅限于身边伙伴的谈论。小学六年级的时候，班里的广播放TF_boy的歌，倒有一堆童子童女捂住耳朵，十分不情愿的样子，看样子也不是很讨厌，自己当初感觉他们好像平时经常听。直到现在，也不太理解他们当时的想法，或许是听腻了？不想再听？当初在班里比较知名的，除了他好像就是周杰伦了，自己依稀记得班里有不少女生谈论或者有一些照片。</p>
<p>​		然后初中回到老家，仍是对音乐无感。并且对他们的品味嗤之以鼻，不是土嗨就是无聊的情歌。在初中，自己信息闭塞，班里人有智能手机，有的还打王者。自己有个老哥送的mp4,和村里一个小孩的游戏机。自己就用mp4看小说，或者玩玩游戏，那上面大多是古早的fc游戏，一代的超级玛丽或者实况足球。不过在校的话，还是喜欢学以致用，捣鼓了很多东西玩儿，这就是另一个故事了。在初中能记起的歌，似乎是纵贯线的《再见》（live）和李玉刚的《刚好遇见你》。这个是下课铃响后，自己冲入学校食堂吃饱饭足后，惬意的回到教室的时候，学校广播所放的歌。</p>
<p>​		直到高中，也只是高二高三的时候，发现写作业很无聊，于是边听电台边写作业。或者晚自习的时候，偷偷用mp4翻电台听。什么中国之声的，都听过。在那个闭塞的环境里，想用它为自己打开一些世界。最后发现听电台写作业太容易分心。自习听电台，也有时候要听不少广告，内容也不一定是自己感兴趣的。随后又下了不少相声或者说书，相声自己倒是从小看的时候觉得很有意思，但也没深入。</p>
<p>​		此后，自己用kindle看知乎周刊，有一期是关于摇滚的，内容看着很有意思，便听了一些期刊中列举的歌。有不少听不进去，但有不少却意外的喜欢，比如Pink floyd的《Wish you were here》。被里面的吉他和它的故事吸引。深感浪漫。于是一发不可收拾，在下载了《月之暗面》，一气呵成的听了两三遍后，就弃了。这啥啊，一个专辑，十多首歌，差不多一个多小时。但是它风评又很好，互联网上一堆吹的。行吧，或许自己没到那个地步，寻寻渐进，先听一些流行摇滚吧。然后就挑，知名摇滚乐队有啥啊。披头士，ACDC,齐柏林，大门。逐一挑几首热门的，听着不错，再挑销量不错的专辑，然后蛮喜欢，就干脆把作品都全下了，一首首慢慢听，喜欢的留着，可以反复听，不喜欢的就挪个位置。</p>
<p>​		不过遗憾的是，很多乐队的歌听不进。能听的进去就beyond，披头士，avantasia,X japan，pink floyd。这些比较喜欢。pink floyd是不知道哪一天，脑袋中回想起它的旋律，然后再听就喜欢上了。后面发现自己喜欢迷幻摇滚和金属歌剧。我喜欢一气呵成，连续一两个小时沉浸其中。其实高中的时候，比较空闲，对摇滚的探索是很多的。或许是迷恋于它的故事，它的寓意，它对世界的居高临下，和对自由的渴望等等。不过直到现在，它都是我最喜欢的音乐。</p>
<p>​		再后来，听过纯音乐，对古典音乐有过尝试，也听过rap和流行音乐。只是觉得这些太容易腻了，古典音乐也不太听不进（除非像猫和老鼠那样）。现在倒偶尔听听电音，摇滚似乎也是翻来覆去那些乐队。安于现状。</p>
<p>​		有想过弹贝斯，弹吉他，弹钢琴。我想用贝斯弹《つぎの夜へ》，沉沦其中。想怀抱吉他，跟着电台弹《Wish you  were here》，一遍遍用钢琴演奏《The last song》。如果能实现，那样十分惬意呐。</p>
<img src="/2023/07/16/%E9%9F%B3%E4%B9%90%E5%90%AF%E8%92%99/123.jpg" class="" title="img">

<p>不过只在大一，参加了社团培训，入门吉他一个学期。想必下次入门会更有经验了（笑）。</p>
<p>​		感谢音乐，倒是一路过来，或许没有同趣之人可以分享。窃以为，能与乐队，在音乐中相识同感即可。</p>
<p>应该附上自己喜欢的乐队和最喜欢的一首歌：</p>
<p>Pink Floyd								《Wish You Were Here》</p>
<p>X Japan									《The Last Song》</p>
<p>ゆらゆら帝国						《つぎの夜へ》</p>
<p>Avantasia								《The Seven Angels》</p>
<p>Metallica								《Fade To Black》</p>
<p>Guns N’ Roses 						《Novenmber Rain》</p>
<p>Wolf Alice 								《Soapy Water》</p>
<p>Stratovarius							《When Mountains Fall》</p>
<p>Porter Robinson						《Shelter》</p>
<p>beyond（挑不出）</p>
<p>…………….</p>
<p>​		高中时曾听闻同学以前班上晚会，有人失恋了，在全班上唱beyond《海阔天空》，或者用《真的爱你》表白。颇为不齿。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序结构</title>
    <url>/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h6 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World!"></a>Hello,World!</h6><p>编写一个能够输出 <code>Hello,World!</code> 的程序。<span id="more"></span></p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712000542827.png" class="" title="image-20230712000542827">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Hello,World!</p>
<h6 id="输出字符菱形"><a href="#输出字符菱形" class="headerlink" title="输出字符菱形"></a>输出字符菱形</h6><p>用 <code>*</code> 构造一个对角线长 55 个字符，倾斜放置的菱形。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712000922663.png" class="" title="image-20230712000922663">

<p>简单粗暴法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慵懒粗暴法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n ***\n*****\n ***\n  *\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="超级玛丽游戏"><a href="#超级玛丽游戏" class="headerlink" title="超级玛丽游戏"></a>超级玛丽游戏</h6><p>超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                ********</span><br><span class="line">               ************</span><br><span class="line">               ####....#.</span><br><span class="line">             #..###.....##....</span><br><span class="line">             ###.......######              ###            ###</span><br><span class="line">                ...........               #...#          #...#</span><br><span class="line">               ##*#######                 #.#.#          #.#.#</span><br><span class="line">            ####*******######             #.#.#          #.#.#</span><br><span class="line">           ...#***.****.*###....          #...#          #...#</span><br><span class="line">           ....**********##.....           ###            ###</span><br><span class="line">           ....****    *****....</span><br><span class="line">             ####        ####</span><br><span class="line">           ######        ######</span><br><span class="line">##############################################################</span><br><span class="line">#...#......#.##...#......#.##...#......#.##------------------#</span><br><span class="line">###########################################------------------#</span><br><span class="line">#..#....#....##..#....#....##..#....#....#####################</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.....#......##.....#......##.....#......#    #----------#</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#</span><br><span class="line">##########################################    ############</span><br></pre></td></tr></table></figure>

<p>有一种printf多行字符串的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;                ********\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ************\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ####....#.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             #..###.....##....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ###.......######              ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;                ...........               #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ##*#######                 #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;            ####*******######             #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ...#***.****.*###....          #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....**********##.....           ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....****    *****....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ####        ####\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ######        ######\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##############################################################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#...#......#.##...#......#.##...#......#.##------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;###########################################------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#..#....#....##..#....#....##..#....#....#####################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.....#......##.....#......##.....#......#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    ############\n&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A+B Problem"></a>A+B Problem</h6><p>输入两个整数a,b，输出它们的和；</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712003025442.png" class="" title="image-20230712003025442">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="字符三角形"><a href="#字符三角形" class="headerlink" title="字符三角形"></a>字符三角形</h6><p>给定一个字符，用它构造一个底边长 55 个字符，高 33 个字符的等腰字符三角形。</p>
<p>输入格式：	 输入只有一行，包含一个字符。</p>
<p>输出格式：	该字符构成的等腰三角形，底边长 55 个字符，高 33 个字符。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712003406362.png" class="" title="image-20230712003406362">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %c\n %c%c%c\n%c%c%c%c%c&quot;</span>,a,a,a,a,a,a,a,a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="苹果采购"><a href="#苹果采购" class="headerlink" title="苹果采购"></a>苹果采购</h6><p>现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？</p>
<p>输入格式：</p>
<p>输入两个不超过 109109 正整数，分别表示每人分到的数量和同学的人数。</p>
<p>输出格式：</p>
<p>一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712004708142.png" class="" title="image-20230712004708142">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a*b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="字母转换"><a href="#字母转换" class="headerlink" title="字母转换"></a>字母转换</h6><p>输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712004845534.png" class="" title="image-20230712004845534">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	a-=<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ASCII码表中，小写字母比大写字母大32.</p>
<h6 id="数字反转"><a href="#数字反转" class="headerlink" title="数字反转"></a>数字反转</h6><p>输入一个不小于 100100 且小于 10001000，同时包括小数点后一位的一个浮点数，例如 123.4 ，要求把这个数字翻转过来，变成 4.321 并输出。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712005845379.png" class="" title="image-20230712005845379">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a,b;</span><br><span class="line">	<span class="type">int</span> c,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;a);</span><br><span class="line">	c=a*<span class="number">10</span>;</span><br><span class="line">	d=c%<span class="number">10</span>*<span class="number">1000</span>+c/<span class="number">10</span>%<span class="number">10</span>*<span class="number">100</span>+c/<span class="number">100</span>%<span class="number">10</span>*<span class="number">10</span>+c/<span class="number">1000</span>;<span class="comment">//反转</span></span><br><span class="line">	b=(<span class="type">float</span>)d/<span class="number">10</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5.1f&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>656.8↙<br>865.6</p>
<p>浮点数不能取余，所以干脆变成整形转换，转换完成后在变回来。可以使用强制类型转换，也可定义中间变量。最后输出时“%5.1f”，意思是至少占5个字符宽度（包括一位小数和一个小数点），且小数点后面有1位小数，小数点占一位，所以整数部分至少占3位。</p>
<p>懒人法（直接利用字符串）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a, b, c, d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c.%c&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c.%c%c%c&quot;</span>, d, c, b, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="再分肥宅水"><a href="#再分肥宅水" class="headerlink" title="再分肥宅水"></a>再分肥宅水</h6><p>现在有 t 毫升肥宅快乐水，要均分给 n 名同学。每名同学需要 2 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后3 位），以及一共需要多少个杯子。</p>
<p>输入格式：</p>
<p>输入一个实数 t 和一个正整数 n，使用空格隔开。</p>
<p>输出格式：</p>
<p>输出两行。</p>
<p>第一行输出一个三位小数，表示可以获得多少毫升饮料。第二行输出一个正整数，表示一共需要多少个杯子。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712103702737.png" class="" title="image-20230712103702737">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> a,c;</span><br><span class="line"><span class="type">int</span> b,d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a/b;</span><br><span class="line">	d=<span class="number">2</span>*b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%0.3f\n%d&quot;</span>,c,d);;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h6><img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712104909313.png" class="" title="image-20230712104909313">

<p>输入格式：</p>
<p>第一行输入三个实数a*,<em>b</em>,*c，以空格隔开。</p>
<p>输出格式：</p>
<p>输出一个实数，表示三角形面积。精确到小数点后 1位。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712104959296.png" class="" title="image-20230712104959296">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> a,b,c,p,s;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	p=<span class="number">0.5</span>*(a+b+c);</span><br><span class="line">	s=p*(p-a)*(p-b)*(p-c);</span><br><span class="line">	s=<span class="built_in">sqrt</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,s);;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>double精度比float高，sqrt()是开根号的函数，使用时需引入头文件&lt;math.h&gt;。</p>
<h6 id="上学迟到"><a href="#上学迟到" class="headerlink" title="上学迟到"></a>上学迟到</h6><p>学校和 yyy 的家之间的距离为 s 米，而 yyy 以 v 米每分钟的速度匀速走向学校。</p>
<p>在上学的路上，yyy 还要额外花费 10 分钟的时间进行垃圾分类。</p>
<p>学校要求必须在上午 8:00 到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。</p>
<p>由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s,v,t,a,b,c,d,hour,min;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s,&amp;v);</span><br><span class="line">	t=s/v+<span class="number">10</span>;  <span class="comment">//计算所需总时间（min) </span></span><br><span class="line">	<span class="keyword">if</span>(s%v) &#123;t=t+<span class="number">1</span>;&#125; <span class="comment">//考虑时间计算，整形数据会忽略小数（秒），当有小数（秒）时，分钟+1； </span></span><br><span class="line">	hour=t/<span class="number">60</span>;  <span class="comment">//划分数据为时和分； </span></span><br><span class="line">	min=t%<span class="number">60</span>;  </span><br><span class="line">	<span class="keyword">if</span>(t&gt;=<span class="number">1440</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;输入条件无效，提前时间大于24小时。&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(hour&gt;<span class="number">8</span>) &#123;hour=<span class="number">8</span>+<span class="number">24</span>-hour;a=hour/<span class="number">10</span>;b=hour%<span class="number">10</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">8</span>&gt;hour&gt;<span class="number">0</span>)&#123;a=<span class="number">0</span>;b=<span class="number">8</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour==<span class="number">0</span>)&#123;a=<span class="number">0</span>;b=<span class="number">7</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(min!=<span class="number">0</span>) &#123;min=<span class="number">60</span>-min;c=min/<span class="number">10</span>;d=min%<span class="number">10</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;c=d=<span class="number">0</span>;&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d%d:%d%d\n&quot;</span>,a,b,c,d);</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍有麻烦的就是补零和时间格式。根据chatgpt建议修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s,v,t,hour,min;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s,&amp;v);</span><br><span class="line">	t=s/v+<span class="number">10</span>;  <span class="comment">//计算所需总时间（min) </span></span><br><span class="line">	<span class="keyword">if</span>(s%v) &#123;t=t+<span class="number">1</span>;&#125; <span class="comment">//考虑时间计算，整形数据会忽略小数（秒），当有小数（秒）时，分钟+1； </span></span><br><span class="line">	hour=t/<span class="number">60</span>;  <span class="comment">//划分数据为时和分； </span></span><br><span class="line">	min=t%<span class="number">60</span>;  </span><br><span class="line">	<span class="keyword">if</span>(t&gt;=<span class="number">1440</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;输入条件无效，提前时间大于24小时。&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(hour&gt;<span class="number">8</span>) &#123;hour=<span class="number">8</span>+<span class="number">24</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour&lt;<span class="number">8</span>&amp;&amp;hour&gt;<span class="number">0</span>) &#123;hour=<span class="number">8</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour==<span class="number">0</span>) &#123;hour=<span class="number">7</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(min==<span class="number">0</span>) &#123;min=<span class="number">60</span>;&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>,hour,<span class="number">60</span>-min);</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在条件判断语句 <code>8 &gt; hour &gt; 0</code> 中，C 语言不支持连续的比较操作符(但我的编译器Dve能通过)。四位数的拆分可以通过输出格式前导零简化。<em>不过还是没有通过洛谷的条件检测。可能有瑕疵尚未发现。</em></p>
<h6 id="大象喝水"><a href="#大象喝水" class="headerlink" title="大象喝水"></a>大象喝水</h6><p>一只大象口渴了，要喝 2020 升水才能解渴，但现在只有一个深 <em>h</em> 厘米，底面半径为 <em>r</em> 厘米的小圆桶 （h* 和 <em>r</em> 都是整数）。问大象至少要喝多少桶水才会解渴。这里我们近似地取圆周率 π&#x3D;3.14。</p>
<p>输入格式：</p>
<p>输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 <em>h</em> 和底面半径 <em>r</em>，单位都是厘米。</p>
<p>输出格式：</p>
<p>输出一行，包含一个整数，表示大象至少要喝水的桶数。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712164136390.png" class="" title="image-20230712164136390">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h,r,v,k;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;h,&amp;r);</span><br><span class="line">	v=<span class="number">3.14</span>*r*r*h*<span class="number">100</span>; <span class="comment">//多乘100，保存精度并且是整形方便计算 </span></span><br><span class="line">	k=<span class="number">2000000</span>/v;    <span class="comment">//相应的，20升也变为2000升。 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2000000</span>%v) &#123;k=k+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟没有2.5桶水，也不能四舍五入。所以引入条件判断。</p>
<h6 id="小鱼的游泳时间"><a href="#小鱼的游泳时间" class="headerlink" title="小鱼的游泳时间"></a>小鱼的游泳时间</h6><p>伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。</p>
<p>这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 2424 小时制计算），它发现自己从 <em>a</em> 时 <em>b</em> 分一直游泳到当天的 <em>c</em> 时 d* 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？</p>
<p>输入格式：</p>
<p>一行内输入四个整数，以空格隔开，分别表示题目中的 �,�,�,�<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>。</p>
<p>输出格式：</p>
<p>一行内输出两个整数 <em>e</em> 和 <em>f</em>，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 <em>f</em> 应该小于 6060。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712175006634.png" class="" title="image-20230712175006634">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">	f=(c-a)*<span class="number">60</span>+d-b;</span><br><span class="line">	e=f/<span class="number">60</span>;</span><br><span class="line">	f=f%<span class="number">60</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,e,f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="小玉买文具"><a href="#小玉买文具" class="headerlink" title="小玉买文具"></a>小玉买文具</h6><p>班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 11 元 99 角，而班主任给小玉的钱是 <em>a</em> 元 <em>b</em> 角，小玉想知道，她最多能买多少只签字笔呢。</p>
<p>输入格式：</p>
<p>输入只有一行两个整数，分别表示 <em>a</em> 和 <em>b</em>。</p>
<p>输出格式：</p>
<p>输出一行一个整数，表示小玉最多能买多少只签字笔。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712180113375.png" class="" title="image-20230712180113375">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a*<span class="number">10</span>+b;   <span class="comment">//计算现金为多少角 </span></span><br><span class="line">	c=c/<span class="number">19</span>;    <span class="comment">//1元9角为19角 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h6><p>牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：</p>
<p>总成绩&#x3D;作业成绩×20%+小测成绩×30%+期末考试成绩×50%</p>
<p>牛牛想知道，这门课程自己最终能得到多少分。</p>
<p>输入格式：</p>
<p>三个非负整数 A*,<em>B</em>,<em>C</em>，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是100 分。</p>
<p>输出格式：</p>
<p>一个整数，即牛牛这门课程的总成绩，满分也是 100 分。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712180509212.png" class="" title="image-20230712180509212">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c,x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	x=a*<span class="number">0.2</span>+b*<span class="number">0.3</span>+c*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
