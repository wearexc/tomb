<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言函数</title>
    <url>/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h5 id="函数定义（C-语言自定义函数）"><a href="#函数定义（C-语言自定义函数）" class="headerlink" title="函数定义（C 语言自定义函数）"></a>函数定义（C 语言自定义函数）</h5><p>函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。<span id="more"></span>接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明，根据这一点可以将函数分为有参函数和无参函数。<br>将代码段封装成函数的过程叫做函数定义。  </p>
<h6 id="无参函数的定义"><a href="#无参函数的定义" class="headerlink" title="无参函数的定义"></a>无参函数的定义</h6><p>如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br></pre></td></tr></table></figure>

<p>dataType 是返回值类型，它可以是 C 语言中的任意数据类型，例如 int、 float、 char 等。<br>functionName 是函数名，它是标识符的一种，命名规则和标识符相同。函数名后面的括号( )不能少。<br>body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由{ }包围。<br>如果有返回值，在函数体中使用 return 语句返回。 return 出来的数据的类型要和 dataType 一样  </p>
<p>无返回值函数<br>有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">printf(&quot;Hello,world \n&quot;); //没有返回值就不需要 return 语句 &#125;</span><br></pre></td></tr></table></figure>

<p>void 是 C 语言中的一个关键字，表示“空类型”或“无类型”，绝大部分情况下也就意味着没有 return 语句。</p>
<h6 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h6><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dataType1 param1, dataType2 param2 …是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由,分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。  </p>
<p>数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部。  </p>
<p>例如：计算从 m 加到 n 的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>调用 sum() 函数时，需要给它传递两份数据，一份传递给 m，一份传递给 n。你可以直接传递整数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = sum(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">//1 传递给 m， 100 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以传递变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> begin = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">86</span>;</span><br><span class="line"><span class="type">int</span> result = sum(begin, end); <span class="comment">//begin 传递给 m， end 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>也可以整数和变量一起传递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">33</span>;</span><br><span class="line"><span class="type">int</span> result = sum(num, <span class="number">80</span>); <span class="comment">//num 传递给 m， 80 传递给 n</span></span><br></pre></td></tr></table></figure>

<p>函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。<br>原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。  </p>
<h6 id="函数不能嵌套定义"><a href="#函数不能嵌套定义" class="headerlink" title="函数不能嵌套定义"></a>函数不能嵌套定义</h6><p>强调一点， C 语言不允许函数嵌套定义；也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。 main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。</p>
<p>函数不能嵌套定义，但可以嵌套调用，也就是在一个函数的定义或调用过程中允许出现对另外一个函数的调用。</p>
<h5 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h5><h6 id="形参（形式参数）"><a href="#形参（形式参数）" class="headerlink" title="形参（形式参数）"></a>形参（形式参数）</h6><p>在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。</p>
<h6 id="实参（实际参数）"><a href="#实参（实际参数）" class="headerlink" title="实参（实际参数）"></a>实参（实际参数）</h6><p>函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。<br>形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。</p>
<h6 id="形参和实参的区别和联系"><a href="#形参和实参的区别和联系" class="headerlink" title="形参和实参的区别和联系"></a>形参和实参的区别和联系</h6><p>(1) 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。<br>(2)  实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。<br>(4)  实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。<br>(5)  函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//计算从m加到n的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, total;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    total = sum(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d\n&quot;</span>, total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers: 1 100↙<br>a&#x3D;1, b&#x3D;100<br>total&#x3D;5050</p>
<p>在这段代码中，函数定义处的 m、 n 是形参，函数调用处的 a、 b 是实参。通过 scanf() 可以读取用户输入的数据，并赋值给 a、 b，在调用 sum() 函数时，这份数据会传递给形参 m、 n。</p>
<p>从运行情况看，输入 a 值为 1，即实参 a 的值为 1，把这个值传递给函数 sum() 后，形参 m 的初始值也为 1，在函数执行过程中，形参 m 的值变为 5050。函数运行结束后，输出实参 a 的值仍为 1，可见实参的值不会随形参的变化而变化。</p>
<p>以上调用 sum() 时是将变量作为函数实参，除此以外，你也可以将常量、表达式、函数返回值作为实参，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">total = sum(<span class="number">10</span>, <span class="number">98</span>); <span class="comment">//将常量作为实参</span></span><br><span class="line">total = sum(a + <span class="number">10</span>, b - <span class="number">3</span>); <span class="comment">//将表达式作为实参</span></span><br><span class="line">total = sum(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="built_in">abs</span>(<span class="number">-100</span>)); <span class="comment">//将函数返回值作为实参</span></span><br></pre></td></tr></table></figure>

<p>(6) 形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效。  </p>
<h5 id="函数声明以及函数原型"><a href="#函数声明以及函数原型" class="headerlink" title="函数声明以及函数原型"></a>函数声明以及函数原型</h5><p>函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号;，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>也可以不写形参，只写数据类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">( dataType1, dataType2 ... )</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，称为函数原型（Function Prototype） 。函数原型的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。  </p>
<p>一般情况下，将函数定义放到 main() 的后面，将函数声明放到 main() 的前面，这样就使得代码结构清晰明了，主次分明。  </p>
<h5 id="C-语言变量的作用域"><a href="#C-语言变量的作用域" class="headerlink" title="C 语言变量的作用域"></a>C 语言变量的作用域</h5><p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。   </p>
<h6 id="函数内部定义的变量（局部变量）"><a href="#函数内部定义的变量（局部变量）" class="headerlink" title="函数内部定义的变量（局部变量）"></a>函数内部定义的变量（局部变量）</h6><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable） 。函数的形参也是局部变量，也只能在函数内部使用。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//m、 n、 i、 sum 都是局部变量，只能在 sum() 内部使用</span></span><br><span class="line">    <span class="keyword">for</span>(i=m; i&lt;=n; i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">5</span>, end = <span class="number">86</span>;</span><br><span class="line">    <span class="type">int</span> result = sum(begin, end);</span><br><span class="line">    <span class="comment">//begin、 end、 result 也都是局部变量，只能在 main() 内部使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum from %d to %d is %d\n&quot;</span>, begin, end, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>m、 n、 i、 sum 是局部变量，只能在 sum() 内部使用； begin、 end、 result 也是局部变量，只能在 main() 内部使用。<br>对局部变量的两点说明：<br>    main() 也是一个函数，在 main() 内部定义的变量也是局部变量，只能在 main() 函数内部使用。  </p>
<p>​	形参也是局部变量，将实参传递给形参的过程，就是用实参给局部变量赋值的过程，它和 a&#x3D;b; sum&#x3D;m+n;这样的赋值没有什么区别  </p>
<h6 id="所有函数外部定义的变量（全局变量）"><a href="#所有函数外部定义的变量（全局变量）" class="headerlink" title="所有函数外部定义的变量（全局变量）"></a>所有函数外部定义的变量（全局变量）</h6><p>全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件） 。如果给全局变量加上 static 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。</p>
<p>例：定义一个函数，根据长方体的长宽高求它的体积以及三个面的面积。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义三个全局变量，分别表示三个面的面积</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vs</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width, <span class="type">int</span> height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> v; <span class="comment">//体积</span></span><br><span class="line">    v = length * width * height;</span><br><span class="line">    s1 = length * width;</span><br><span class="line">    s2 = width * height;</span><br><span class="line">    s3 = length * height;	</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    v = vs(<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    v = vs(<span class="number">5</span>, <span class="number">17</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v=%d, s1=%d, s2=%d, s3=%d\n&quot;</span>, v, s1, s2, s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>v&#x3D;9000, s1&#x3D;300, s2&#x3D;600, s3&#x3D;450<br>v&#x3D;680, s1&#x3D;85, s2&#x3D;136, s3&#x3D;40  </p>
<p>通过变量的使用可以得到： 在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。  </p>
<p>C 语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：<br>    不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；<br>    函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。  </p>
<p>当函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”，不再起作用。也就是说，在函数内部使用的是局部变量，而不是全局变量。</p>
<p>变量的使用遵循就近原则，如果在当前的局部作用域中找到了同名变量，就不会再去更大的全局作用域中查找。另外，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>; <span class="comment">//局部变量</span></span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>func1 n: 20<br>func2 n: 30<br>func3 n: 10<br>main n: 30</p>
<p>代码中虽然定义了多个同名变量 n，但它们的作用域不同，所有不会产生命名冲突。</p>
<p>下面是对输出结果的分析：<br>    对于 func1()，输出结果为 20，显然使用的是 func1() 内部的 n，而不是外部的 n。<br>    调用 func2() 时，会把 main() 中的实参 n 传递给 func2() 中的形参 n，此时形参 n 的值变为 30。形参 n 也<br>是局部变量，所以就使用它了。<br>    func3() 输出 10，使用的是全局变量，因为在 func3() 中不存在局部变量 n，所以编译器只能到函数外部，也<br>就是全局作用域中去寻找变量 n。<br>     main() 中 printf() 语句输出 30，说明使用的是 main() 中的 n，而不是外部的 n。  </p>
<h6 id="块级变量（在代码块内部定义的变量）"><a href="#块级变量（在代码块内部定义的变量）" class="headerlink" title="块级变量（在代码块内部定义的变量）"></a>块级变量（在代码块内部定义的变量）</h6><p>C 语言允许在代码块内部定义变量，这样的变量具有块级作用域；换句话说，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">22</span>; <span class="comment">//编号①</span></span><br><span class="line">    <span class="comment">//由&#123; &#125;包围的代码块</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">40</span>; <span class="comment">//编号②</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>block n: 40<br>main n: 22  </p>
<h6 id="再谈作用域"><a href="#再谈作用域" class="headerlink" title="再谈作用域"></a>再谈作用域</h6><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">822</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;if m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = i % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">2</span> &amp;&amp; n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;else m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710211606098.png" class="" title="image-20230710211606098">

<p>蓝色表示作用域的名称， 红色表示作用域中的变量， global 表示全局作用域。在灰色背景的作用域中，我们使用到了 m 变量，而该变量位于全局作用域中，所以得穿越好几层作用域才能找到 m。</p>
<h5 id="递归函数（递归调用）"><a href="#递归函数（递归调用）" class="headerlink" title="递归函数（递归调用）"></a>递归函数（递归调用）</h5><p>个函数在它的函数体内调用它自身称为递归调用，这种函数称为递归函数。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。  </p>
<p>以求阶乘为例，阶乘 n! 的计算公式如下：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710214033219.png" class="" title="image-20230710214033219">

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Factorial(%d) = %ld\n&quot;</span>, a, factorial(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 5↙<br>Factorial(5) &#x3D; 120  </p>
<p>factorial() 就是一个典型的递归函数。调用 factorial() 后即进入函数体，只有当 n&#x3D;&#x3D;0 或 n&#x3D;&#x3D;1 时函数才会执行结<br>束，否则就一直调用它自身。</p>
<p>由于每次调用的实参为 n-1，即把 n-1 的值赋给形参 n，所以每次递归实参的值都减 1，直到最后 n-1 的值为 1时再作递归调用，形参 n 的值也为 1，递归就终止了，会逐层退出。  </p>
<p>下表列出了逐层进入的过程：</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>实参&#x2F;形参</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>需要等待的结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>n&#x3D;5</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的结果</td>
</tr>
<tr>
<td>2</td>
<td>n&#x3D;4</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的结果</td>
</tr>
<tr>
<td>3</td>
<td>n&#x3D;3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的结果</td>
</tr>
<tr>
<td>4</td>
<td>n&#x3D;2</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的结果</td>
</tr>
<tr>
<td>5</td>
<td>n&#x3D;1</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
</tr>
</tbody></table>
<p>当递归进入到最内层的时候，递归就结束了，就开始逐层退出了，也就是逐层执行 return 语句。  </p>
<p>下表列出了逐层退出的过程</p>
<table>
<thead>
<tr>
<th>层次&#x2F;层数</th>
<th>调用形式</th>
<th>需要计算的表达式</th>
<th>从内层递归得到的结果 （内层函数的返回值）</th>
<th>表达式的值 （当次调用的结果）</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>factorial(1)</td>
<td>1</td>
<td>无</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>factorial(2)</td>
<td>factorial(1) * 2</td>
<td>factorial(1) 的返回值，也就是 1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>factorial(3)</td>
<td>factorial(2) * 3</td>
<td>factorial(2) 的返回值，也就是 2</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>factorial(4)</td>
<td>factorial(3) * 4</td>
<td>factorial(3) 的返回值，也就是 6</td>
<td>24</td>
</tr>
<tr>
<td>1</td>
<td>factorial(5)</td>
<td>factorial(4) * 5</td>
<td>factorial(4) 的返回值，也就是 24</td>
<td>120</td>
</tr>
</tbody></table>
<h6 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h6><p>每一个递归函数都应该只进行有限次的递归调用，否则它就会进入死胡同，永远也不能退出了，这样的程序是没有意义的。</p>
<p>要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题：<br>    存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束<br>了。<br>    每次递归调用之后越来越接近这个限制条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n<br>的值逐渐减小，越来越趋近于 1 或 0。  </p>
<h6 id="中间递归函数"><a href="#中间递归函数" class="headerlink" title="中间递归函数"></a>中间递归函数</h6><p>所谓中间递归，就是发生递归的位置在函数体的中间，而不是末尾。<br>尾递归在逐层退出时除了 return 语句，一般不再执行其他操作；而中间递归在逐层退出时还要执行一些其他的操作，所以比较复杂。</p>
<p>例如：字符串反转（逆置）函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//反转（逆置）字符串</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">reverse</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> ctemp = str[<span class="number">0</span>];</span><br><span class="line">            str[<span class="number">0</span>] = str[len - <span class="number">1</span>];</span><br><span class="line">            str[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//最后一个字符在下次递归时不再处理</span></span><br><span class="line">            reverse(str + <span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">            str[len - <span class="number">1</span>] = ctemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, reverse(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>987654321</p>
<p>每次调用函数，都会把字符串的第 0 个字符保存到 ctemp 变量，并把最后一个字符填充到第 0 个字符的位置，同时用’\0’来填充最后一个字符的位置。  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230710231414691.png" class="" title="image-20230710231414691">

<p>reverse() 的整体思路是，每次调用函数只交换字符串开头和末尾的两个字符，其它字符一律不管，并且这个交换过程也是分两个阶段完成的：</p>
<p>在逐层进入递归的阶段， reverse() 只是把字符串的最后一个字符移动到最前边，但是并没有把最前边一个字符移动到最后边，而是把最前边的字符保存到 ctemp 变量。</p>
<p>在逐层退出递归的阶段， reverse() 才把 ctemp 变量中保存的字符放到字符串的最前边。</p>
<p>两个阶段相互合作，才能最终完成两个字符的交换。  </p>
<h6 id="多层递归函数"><a href="#多层递归函数" class="headerlink" title="多层递归函数"></a>多层递归函数</h6><p>多层递归的调用关系比较复杂，整体上看起来像一颗倒立的树：对于双层递归，树的每个节点有两个分叉；对<br>于三层递归，树的每个节点有三个分叉；以此类推……<br>下面以「求菲波那契数」为例:</p>
<p>菲波那契数就是一个数列，数列中每个数的值就是它前面两个数的和，这种关系常常用以下形式进行描述：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112109326.png" class="" title="image-20230711112109326">

<p>代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 7↙<br>Fib(7) &#x3D; 13  </p>
<p>当 n≥2 时，每次调用 fib(n) 都要等待 fib(n-1) 和 fib(n-2) 的结果，这种调用关系看起来就像一棵倒立的二叉树，如下图所示：  </p>
<img src="/2023/07/10/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/image-20230711112233095.png" class="" title="image-20230711112233095">

<p>双层递归的调用关系和数据结构中二叉树的结构完全吻合，所以双层递归常用于二叉树的遍历。</p>
<p>单层递归每次只等待一个函数的结果，双层递归每次要等待两个函数的结果，这就是它们之间最本质的区别。  </p>
<h5 id="递归函数的缺陷和优化"><a href="#递归函数的缺陷和优化" class="headerlink" title="递归函数的缺陷和优化"></a>递归函数的缺陷和优化</h5><h6 id="递归函数的空间开销"><a href="#递归函数的空间开销" class="headerlink" title="递归函数的空间开销"></a>递归函数的空间开销</h6><p>递归函数内部嵌套了对自身的调用，除非等到最内层的函数调用结束，否则外层的所有函数都不会调用结束。</p>
<p>通俗地讲，外层函数被卡主了，它要等待所有的内层函数调用完成后，它自己才能调用完成。</p>
<p>每一层的递归调用都会在栈上分配一块内存， 有多少层递归调用就分配多少块相似的内存，所有内存加起来的总和是相当恐怖的，很容易超过栈内存的大小限制，这个时候就会导致程序崩溃。</p>
<p>例如，一个递归函数需要递归 10000 次，每次需要 1KB 的内存，那么最终就需要 10MB 的内存  </p>
<h6 id="递归函数的时间开销"><a href="#递归函数的时间开销" class="headerlink" title="递归函数的时间开销"></a>递归函数的时间开销</h6><p>每次调用函数都会在栈上分配内存，函数调用结束后再释放这一部分内存，内存的分配和释放都是需要时间的。<br>每次调用函数还会多次修改寄存器的值，函数调用结束后还需要找到上层函数的位置再继续执行，这也是需要时间的。 </p>
<p>以「求斐波那契数」为例  ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>   </span></span><br><span class="line"><span class="comment">// 递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start, time_end;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    time_start = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib(%d) = %ld\n&quot;</span>, a, fib(a));</span><br><span class="line">    time_end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end - time_start)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a number: 42↙<br>Fib(42) &#x3D; 267914296<br>run time: 0.833000s</p>
<p>可以看到，求 42 的斐波那契数程序所用的时间为 0.83 秒。  </p>
<h6 id="使用迭代来替换递归函数"><a href="#使用迭代来替换递归函数" class="headerlink" title="使用迭代来替换递归函数"></a>使用迭代来替换递归函数</h6><p>递归函数应为原理层面的缺陷，无法优化，但大部分能用递归解决的问题也能用迭代来解决。所谓迭代，就是循环。</p>
<p>许多问题是以递归的形式进行解释的，这只是因为它比非递归形式更为清晰。但是， 这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性可能稍差一些。  </p>
<p>还是以求斐波那契数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_recursion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib_recursion(n - <span class="number">1</span>) + fib_recursion(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代计算斐波那契数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fib_iteration</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="type">long</span> previous_result;</span><br><span class="line">    <span class="type">long</span> next_older_result;</span><br><span class="line">    result = previous_result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        next_older_result = previous_result;</span><br><span class="line">        previous_result = result;</span><br><span class="line">        result = previous_result + next_older_result;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">clock_t</span> time_start_recursion, time_end_recursion;</span><br><span class="line">    <span class="type">clock_t</span> time_start_iteration, time_end_iteration;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="comment">//递归的时间</span></span><br><span class="line">    time_start_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_recursion(%d) = %ld\n&quot;</span>, a, fib_recursion(a));</span><br><span class="line">    time_end_recursion = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with recursion: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_recursion -</span><br><span class="line">    time_start_recursion)/ CLOCKS_PER_SEC );</span><br><span class="line">    <span class="comment">//迭代的时间</span></span><br><span class="line">    time_start_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fib_iteration(%d) = %ld\n&quot;</span>, a, fib_iteration(a));</span><br><span class="line">    time_end_iteration = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run time with iteration: %lfs\n&quot;</span>, (<span class="type">double</span>)(time_end_iteration - time_start_iteration)</span><br><span class="line">    / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>Input a number: 42<br>Fib_recursion(42) &#x3D; 267914296<br>run time with recursion: 0.854000s<br>Fib_iteration(42) &#x3D; 267914296<br>run time with iteration: 0.000000s</p>
<p>可以看出迭代还是比递归快一点点的。</p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础概念</title>
    <url>/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h6 id="原码，反码和补码"><a href="#原码，反码和补码" class="headerlink" title="原码，反码和补码"></a>原码，反码和补码</h6><p>数据在C语言是以二进制的方式存储。因为二进制的加减运算问题。数据存储为补码。反码是原码逐一取反，补码为反码+1。</p>
<span id="more"></span>

<h6 id="进制中小数的转换"><a href="#进制中小数的转换" class="headerlink" title="进制中小数的转换"></a>进制中小数的转换</h6><p>十进制小数转换成 N 进制小数采用“乘 N 取整，顺序排列”法。具体做法是：<br>　　用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分；<br>　　将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积；<br>　　再将积的整数部分取出，继续用 N 乘以余下的小数部分；<br>　　……<br>　　如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求<br>的精度为止。  </p>
<img src="/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/002.png" class="">

<p>　十进制小数 0.6875 转换成二进制小数的结果为 0.1011。  </p>
<h6 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h6><p>　　当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory） 。  </p>
<h6 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h6><p>　　用固定的二进制数表示固定的字符。各国字符集在ASCII基础上扩展，原来 ASCII 中已经包含的字符，在国家编码（地区编码）中的位置不变（也就是编码值不变），只是在这些字符的后面增添了新的字符。  </p>
<h6 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h6><p>UTF-8：一种变长的编码方案，使用 1~6 个字节来存储；</p>
<p>如果只有一个字节， 那么最高的比特位为 0，这样可以兼容 ASCII；<br>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的<br>字节均以 10 开头。</p>
<p>UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；</p>
<p>特点：空间换效率</p>
<p>UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。  </p>
<h6 id="全角和半角输入法的区别"><a href="#全角和半角输入法的区别" class="headerlink" title="全角和半角输入法的区别"></a>全角和半角输入法的区别</h6><p>在计算机屏幕上，一个汉字要占两个英文字符的位置，人们把一个英文字符所占的位置称为“半角”，相对地把一个汉字所占的位置称为“全角”。</p>
<p> “相同”字符在全角和半角状态下对应的编码值（例如 Unicode 编码、 GBK 编码等）不一样，所以它们是不同的字符。  </p>
<h6 id="C语言程序的执行"><a href="#C语言程序的执行" class="headerlink" title="C语言程序的执行"></a>C语言程序的执行</h6><p>先把代码编译（转换成二进制），再链接（“打包”将所有二进制形式的目标文件和系统组件组合成一个可执行文件  ）。最后生成可执行文件。</p>
<h6 id="整形的长度"><a href="#整形的长度" class="headerlink" title="整形的长度"></a>整形的长度</h6><p>C 语言并没有严格规定 short、 int、 long 的长度，只做了宽泛的限制：<br>　short 至少占用 2 个字节。<br>　int 建议为一个机器字长。 32 位环境下机器字长为 4 字节， 64 位环境下机器字长为 8 字节。<br>　short 的长度不能大于 int， long 的长度不能小于 int。  </p>
<p>  获取某个数据类型的长度可以使用 sizeof 操作符  </p>
<h6 id="进制的表示"><a href="#进制的表示" class="headerlink" title="进制的表示"></a>进制的表示</h6><img src="/2023/07/07/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/001.png" class="">

<h6 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h6><p>​        转义字符以\或者\x 开头，以\开头表示后跟八进制形式的编码值，以\x 开头表示后跟十六进制形式的编码值。 对于<br>转义字符来说，只能使用八进制或者十六进制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\x31\x32\x33\x61\x62\x63&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果为“123abc”</p>
<h6 id="加减乘除的优先性"><a href="#加减乘除的优先性" class="headerlink" title="加减乘除的优先性"></a>加减乘除的优先性</h6><p>和数学上的优先级相同。如果符号的优先级相同，则更具结合性判断。先执行左边的叫左结合性，先执行右边的叫右结合性。  </p>
<h6 id="对取余运算的说明"><a href="#对取余运算的说明" class="headerlink" title="对取余运算的说明"></a>对取余运算的说明</h6><p>余数可以是正数也可以是负数，由 % 左边的整数决定：<br>　　如果 % 左边是正数，那么余数也是正数；<br>　　如果 % 左边是负数，那么余数也是负数  </p>
<h6 id="printf-的高级用法"><a href="#printf-的高级用法" class="headerlink" title="printf() 的高级用法"></a>printf() 的高级用法</h6><p>printf() 格式控制符的完整形式如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flag][width][.precision]type</span><br></pre></td></tr></table></figure>

<p>[ ] 表示此处的内容可有可无，是可以省略的。  </p>
<p>　　type 表示输出类型，比如 %d、 %f、 %c、 %lf， type 就分别对应 d、 f、 c、 lf；再如， %-9d 中 type 对应 d。<br>type 这一项必须有，这意味着输出时必须要知道是什么类型。<br>　　width 表示最小输出宽度，也就是至少占用几个字符的位置；例如， %-9d 中 width 对应 9，表示输出结果最少<br>占用 9 个字符的宽度。<br>　　当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；当输出结果的<br>宽度超过 width 时， width 不再起作用，按照数据本身的宽度来输出。  </p>
<h6 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h6><p>　　缓冲区位于用户程序和硬件设备之间，用来缓存数据，目的是让快速的 CPU 不必等待慢速的输入输出设备，同时减少操作硬件的次数。对于 IO 密集型的网络应用程序，比如网站、数据库、 DNS、 CDN 等，缓冲区的设计至关重要，它能十倍甚至一百倍得提高程序性能。  </p>
<h6 id="scanf-控制字符串"><a href="#scanf-控制字符串" class="headerlink" title="scanf()控制字符串"></a>scanf()控制字符串</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;*&#125; &#123;width&#125; type</span><br></pre></td></tr></table></figure>

<p>其中， { } 表示可有可无。各个部分的具体含义是：</p>
<p>type 表示读取什么类型的数据，例如 %d、 %s、 %[a-z]、 %[^\n] 等； type 必须有。</p>
<p>width 表示最大读取宽度，可有可无。<br>*表示丢弃读取到的数据，可有可无。</p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针</title>
    <url>/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h5 id="指针变量的定义和使用"><a href="#指针变量的定义和使用" class="headerlink" title="指针变量的定义和使用"></a>指针变量的定义和使用</h5><h6 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h6><p>定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">datatype *name;</span><br></pre></td></tr></table></figure>

<span id="more"></span>或者

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">datatype *name = value;</span><br></pre></td></tr></table></figure>

<p>*表示这是一个指针变量， datatype 表示该指针变量所指向的数据的类型 。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1;</span><br></pre></td></tr></table></figure>

<p>p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p_a = &amp;a;</span><br></pre></td></tr></table></figure>

<p>在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址， a 前面必须要加取地址符&amp;，否则是不对的。 和普通变量一样，指针变量也可以被多次写入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义普通变量 float a = 99.5, b = 10.6;</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;@&#x27;</span>, d = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//定义指针变量 float *p1 = &amp;a; char *p2 = &amp;c;</span></span><br><span class="line"><span class="comment">//修改指针变量的值 p1 = &amp;b; p2 = &amp;d;</span></span><br></pre></td></tr></table></figure>

<p>定义指针变量时必须带 *给指针变量赋值时不能带 *</p>
<p>假设变量 a、 b、 c、 d 的地址分别为 0X1000、 0X1004、 0X2000、 0X2004，下面的示意图很好地反映了 p1、 p2 指向的变化：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717102521773.png" class="" title="image-20230717102521773">

<p>另外，p1、 p2 的类型分别是 float *和 char *，而不是 float 和 char，它们是完全不同的数据类型。</p>
<h6 id="通过指针变量取得数据"><a href="#通过指针变量取得数据" class="headerlink" title="通过指针变量取得数据"></a>通过指针变量取得数据</h6><p>指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*pointer;</span><br></pre></td></tr></table></figure>

<p>这里的 * 称为指针运算符，用来取得某个地址上的数据，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a = <span class="number">15</span>; <span class="type">int</span> *p = &amp;a; <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a, *p); <span class="comment">//两种方式都可以输出a的值 return 0; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>15, 15  </p>
<p>假设变量 a、 p 的地址分别为 0X1000、 0XF0A0，它们的指向关系如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717103956709.png" class="" title="image-20230717103956709">

<p>程序被编译和链接后， a、 p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。  </p>
<p><strong>那么，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</strong>  </p>
<p>另外，给指针变量本身赋值时不能加 *，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>指针变量也可以出现在普通变量能出现的任何表达式中，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y, *px = &amp;x, *py = &amp;y;</span><br><span class="line">y = *px + <span class="number">5</span>; <span class="comment">//表示把x的内容加5并赋给y， *px+5相当于(*px)+5</span></span><br><span class="line">y = ++*px; <span class="comment">//px的内容加上1之后赋给y， ++*px相当于++(*px)</span></span><br><span class="line">y = *px++; <span class="comment">//相当于y=(*px)++</span></span><br><span class="line">py = px; <span class="comment">//把一个指针的值赋给另一个指针 </span></span><br></pre></td></tr></table></figure>

<h6 id="关于-和-amp-的拓展"><a href="#关于-和-amp-的拓展" class="headerlink" title="关于 * 和 &amp;的拓展"></a>关于 * 和 &amp;的拓展</h6><p>假设有一个 int 类型的变量 a， pa 是指向它的指针，那么* &amp;a 和&amp;* pa 分别是什么意思呢？</p>
<ul>
<li>&amp;a 可以理解为*(&amp;a)， &amp;a 表示取变量 a 的地址（等价于 pa）， *(&amp;a)表示取这个地址上的数据（等价于 <em>pa），绕来绕去，又回到了原点， * &amp;a 仍然等价于 a。<br>&amp;</em> pa 可以理解为&amp;(<em>pa)， * pa 表示取得 pa 指向的数据（等价于 a）， &amp;(</em> pa)表示数据的地址（等价于 &amp;a），所以&amp;*pa 等价于 pa。</li>
</ul>
<h6 id="指针变量的运算"><a href="#指针变量的运算" class="headerlink" title="指针变量的运算"></a>指针变量的运算</h6><p>指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, *pa = &amp;a, *paa = &amp;a;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">99.9</span>, *pb = &amp;b;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;@&#x27;</span>, *pc = &amp;c;</span><br><span class="line"><span class="comment">//最初的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%#X, &amp;b=%#X, &amp;c=%#X\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);</span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line">    pa++; pb++; pc++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);  </span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line">    pa -= <span class="number">2</span>; pb -= <span class="number">2</span>; pc -= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%#X, pb=%#X, pc=%#X\n&quot;</span>, pa, pb, pc);</span><br><span class="line"><span class="comment">//比较运算</span></span><br><span class="line">    <span class="keyword">if</span>(pa == paa)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *paa);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>&amp;a&#x3D;0X62FDFC, &amp;b&#x3D;0X62FDF0, &amp;c&#x3D;0X62FDEF<br>pa&#x3D;0X62FDFC, pb&#x3D;0X62FDF0, pc&#x3D;0X62FDEF<br>pa&#x3D;0X62FE00, pb&#x3D;0X62FDF8, pc&#x3D;0X62FDF0<br>pa&#x3D;0X62FDF8, pb&#x3D;0X62FDE8, pc&#x3D;0X62FDEE<br>4203849</p>
<p>从运算结果可以看出： pa、 pb、 pc 每次加 1，它们的地址分别增加 4、 8、 1，正好是 int、 double、 char 类型的长度；减 2 时，地址分别减少 8、 16、 2，正好是 int、 double、 char 类型长度的 2 倍 。</p>
<p>以 a 和 pa 为例， a 的类型为 int，占用 4 个字节， pa 是指向 a 的指针，如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110027660.png" class="" title="image-20230717110027660">

<p>这个时候 pa 指向整数 a 的中间， *pa 使用的是橙色虚线画出的 4 个字节，其中前 3 个是变量 a 的，后面 1 个是其它数据的，把它们“搅和”在一起显然没有实际的意义，取得的数据也会非常怪异。<br>如果 pa++;使得地址加 4 的话，正好能够完全跳过整数 a，指向它后面的内存，如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110107877.png" class="" title="image-20230717110107877">

<p>数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，这样指针的加减运算就具有了现实的意义。</p>
<p>但是，C 语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。    </p>
<h5 id="数组指针（指向数组的指针）"><a href="#数组指针（指向数组的指针）" class="headerlink" title="数组指针（指向数组的指针）"></a>数组指针（指向数组的指针）</h5><p>数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以 int arr[] &#x3D; { 99, 15, 100, 888, 252 };为例，该数组在内存中的分布如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110323031.png" class="" title="image-20230717110323031">

<p>定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。 在 C 语言中，我们将第 0 个元素的地址称为数组的首地址。 以上面的数组为例，下图是 arr 的指向：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717110348101.png" class="" title="image-20230717110348101">

<p>以指针的方式遍历数组元素为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">99</span>,<span class="number">15</span>,<span class="number">100</span>,<span class="number">888</span>,<span class="number">252</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">//求数组长度</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(arr+i)); <span class="comment">//*(arr+i)等价于arr[i]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>99 15 100 888 252</p>
<p>第 5 行代码用来求数组的长度， sizeof(arr) 会获得整个数组所占用的字节数， sizeof(int) 会获得一个数组元素所占用的字节数，它们相除的结果就是数组包含的元素个数，也即数组长度。<br>第 8 行代码中我们使用了*(arr+i)这个表达式， arr 是数组名，指向数组的第 0 个元素，表示数组首地址， arr+i 指向数组的第 i 个元素， *(arr+i) 表示取第 i 个元素的数据，它等价于 arr[i]。  </p>
<p>我们也可以定义一个指向数组的指针，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p>arr 本身就是一个指针，可以直接赋值给指针变量 p。 arr 是数组第 0 个元素的地址，所以 int *p &#x3D; arr;也可以写作int *p &#x3D; &amp;arr[0];。也就是说， arr、 p、 &amp;arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头 。</p>
<p>引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。  </p>
<p>(1) 使用下标<br>也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。</p>
<p>(2) 使用指针<br>也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。</p>
<p>不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。  </p>
<h6 id="关于数组指针的拓展"><a href="#关于数组指针的拓展" class="headerlink" title="关于数组指针的拓展"></a>关于数组指针的拓展</h6><p>假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、 *++p、 (*p)++ 分别是什么意思呢？</p>
<p>*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素。</p>
<p>*++p 等价于 * (++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 * (p+1)，所以会获得第 n+1 个数组元素的值。<br>(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0 个元素，并且第个元素的值为 99，执行完该语句后，第 0 个元素的值就会变为 100。  </p>
<h5 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h5><p>C 语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中 ，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str), i;</span><br><span class="line">	<span class="comment">//直接输出字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="comment">//每次输出一个字符</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<p>wearexc.github.io</p>
<p>使用指针的方式来输出字符串：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *pstr = str;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str), i;  <span class="comment">//strlen是计算数组的长度 </span></span><br><span class="line">	<span class="comment">//使用*(pstr+i)</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(pstr+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//使用pstr[i]</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, pstr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//使用*(str+i)</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(str+i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了字符数组， C 语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str = <span class="string">&quot;wearexc.github.io&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p>但需要注意的是，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。</p>
<h5 id="二级指针（指向指针的指针）"><a href="#二级指针（指向指针的指针）" class="headerlink" title="二级指针（指向指针的指针）"></a>二级指针（指向指针的指针）</h5><p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。</p>
<p>假设有一个 int 类型的变量 a， p1 是指向 a 的指针变量， p2 又是指向 p1 的指针变量，它们的关系如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717141917427.png" class="" title="image-20230717141917427">

<p>即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a =100;</span><br><span class="line">int *p1 = &amp;a;</span><br><span class="line">int **p2 = &amp;p1;</span><br></pre></td></tr></table></figure>

<p>指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。 C 语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 * 。 p1 是一级指针，指向普通类型的数据，定义时有一个 * ； p2 是二级指针，指向一级指针 p1，定义时有两个*。</p>
<p>如果我们希望再定义一个三级指针 p3，让它指向 p2，那么可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure>

<p>四级指针也是类似的道理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ****p4 = &amp;p3;  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;a;</span><br><span class="line">    <span class="type">int</span> **p2 = &amp;p1;</span><br><span class="line">    <span class="type">int</span> ***p3 = &amp;p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d\n&quot;</span>, a, *p1, **p2, ***p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p2 = %#X, p3 = %#X\n&quot;</span>, &amp;p2, p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n&quot;</span>, &amp;p1, p2, *p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n&quot;</span>, &amp;a, p1, *p2, **p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>100, 100, 100, 100<br>&amp;p2 &#x3D; 0X62FE00, p3 &#x3D; 0X62FE00<br>&amp;p1 &#x3D; 0X62FE08, p2 &#x3D; 0X62FE08, *p3 &#x3D; 0X62FE08<br> &amp;a &#x3D; 0X62FE14, p1 &#x3D; 0X62FE14, *p2 &#x3D; 0X62FE14, **p3 &#x3D; 0X62FE14</p>
<p>以三级指针 p3 为例来分析上面的代码。 *<em><em>p3 等价于</em>(</em> (*p3))。 *p3 得到的是 p2 的值，也即 p1 的地址； * (<em>p3)得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后， * (</em> (*p3)) 得到的才是 a 的值。</p>
<h5 id="指针数组（数组每个元素都是指针）"><a href="#指针数组（数组每个元素都是指针）" class="headerlink" title="指针数组（数组每个元素都是指针）"></a>指针数组（数组每个元素都是指针）</h5><p>如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType *arrayName[length];</span><br></pre></td></tr></table></figure>

<p>[ ]的优先级高于*，该定义形式应该理解为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType *(arrayName[length]);</span><br></pre></td></tr></table></figure>

<p>括号里面说明 arrayName 是一个数组，包含了 le  ngth 个元素，括号外面说明每个元素的类型为 dataType *。<br>除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">16</span>, b = <span class="number">932</span>, c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个指针数组</span></span><br><span class="line">    <span class="type">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//也可以不指定长度，直接写作 int *parr[]</span></span><br><span class="line">    <span class="comment">//定义一个指向指针数组的指针</span></span><br><span class="line">    <span class="type">int</span> **parr = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, *arr[<span class="number">0</span>], *arr[<span class="number">1</span>], *arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, **(parr+<span class="number">0</span>), **(parr+<span class="number">1</span>), **(parr+<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>16, 932, 100<br>16, 932, 100</p>
<p>arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、 b、 c 的地址对它进行了初始化，这和普通数组是多么地类似。</p>
<p>parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针，它的定义形式应该理解为 int *(<em>parr)，括号中的</em>表示 parr 是一个指针，括号外面的 int *表示 parr 指向的数据的类型。arr 第 0 个元素的类型为 int *，</p>
<p>所以在定义 parr 时要加两个 *。</p>
<p>第一个 printf() 语句中， arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。</p>
<p>第二个 printf() 语句中， parr+i 表示第 i 个元素的地址， *(parr+i) 表示获取第 i 个元素的值（该元素是一个指针），<br>**(parr+i) 表示获取第 i 个元素指向的数据。  </p>
<h5 id="二维数组指针（指向二维数组的指针）"><a href="#二维数组指针（指向二维数组的指针）" class="headerlink" title="二维数组指针（指向二维数组的指针）"></a>二维数组指针（指向二维数组的指针）</h5><p>二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;  </span><br></pre></td></tr></table></figure>

<p>从概念上理解， a 的分布像一个矩阵：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>但在内存中， a 的分布是一维线性的，整个数组占用一块连续的内存：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717205537599.png" class="" title="image-20230717205537599">

<p>C 语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) &#x3D; 48 个字节。<br>C 语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、 a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0] [0]、 a[0] [1]、 a[0] [2]、 a[0] [3]。<br>假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：  </p>
<img src="/2023/07/12/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/image-20230717205632015.png" class="" title="image-20230717205632015">

<p>为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = a;</span><br></pre></td></tr></table></figure>

<p>括号中的 * 表明 p 是一个指针，它指向一个数组，数组的类型为 int [4]，这正是 a 所包含的每个一维数组的类型。</p>
<p>[ ]的优先级高于*， ( )是必须要加的，如果赤裸裸地写作 int *p[4]，那么应该理解为 int *(p[4])， p 就成了一个指针数组，而不是二维数组指针。<br>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关， p 指向的数据类型是 int [4]，那么 p+1 就前进 4×4 &#x3D; 16 个字节， p-1 就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说， p+1 会使得指针指向二维数组的下一行， p-1 会使得指针指向数组的上一行。</p>
<p>那么，可以知道</p>
<p>(1) p 指向数组 a 的开头，也即第 0 行； p+1 前进一行，指向第 1 行。<br>(2) *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素。    </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(p+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>16  </p>
<p>(3) *(p+1)+1 表示第 1 行第 1 个元素的地址。如何理解呢？</p>
<p>*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；</p>
<p>就像一维数组的名字，在定义时或者和 sizeof、 &amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。</p>
<p>(4) *( *(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。<br>根据上面的结论，可以很容易推出以下的等价关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a+i == p+i</span><br><span class="line">a[i] == p[i] == *(a+i) == *(p+i)</span><br><span class="line">a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)  </span><br></pre></td></tr></table></figure>

<h6 id="指针数组和二维数组指针的区别"><a href="#指针数组和二维数组指针的区别" class="headerlink" title="指针数组和二维数组指针的区别"></a>指针数组和二维数组指针的区别</h6><p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *(p1[<span class="number">5</span>]); <span class="comment">//指针数组，可以去掉括号直接写作 int *p1[5];</span></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>]; <span class="comment">//二维数组指针，不能去掉括号 </span></span><br></pre></td></tr></table></figure>

<p> 指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1为例，在 32 位环境下它占用 4×5 &#x3D; 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。  </p>
<h5 id="函数指针（指向函数的指针）"><a href="#函数指针（指向函数的指针）" class="headerlink" title="函数指针（指向函数的指针）"></a>函数指针（指向函数的指针）</h5><p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。<br>函数指针的定义形式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);  </span><br></pre></td></tr></table></figure>

<p>returnType 为函数返回值类型， pointerNmae 为指针名称， param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。<br>注意( )的优先级高于*，第一个括号不能省略，如果写作 returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为 returnType *。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//返回两个数中较大的一个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, maxval;</span><br><span class="line">    <span class="comment">//定义函数指针</span></span><br><span class="line">    <span class="type">int</span> (*pmax)(<span class="type">int</span>, <span class="type">int</span>) = max; <span class="comment">//也可以写作int (*pmax)(int a, int b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    maxval = (*pmax)(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value: %d\n&quot;</span>, maxval);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers:10 50↙<br>Max value: 50</p>
<p>第 14 行代码对函数进行了调用。 pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。注意( )的优先级高于*，第一个括号不能省略。  </p>
<h5 id="对-C-语言指针的总结"><a href="#对-C-语言指针的总结" class="headerlink" title="对 C 语言指针的总结"></a>对 C 语言指针的总结</h5><p>指针（Pointer）就是内存的地址， C 语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。</p>
<p>程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。</p>
<p>常见指针变量的定义</p>
<table>
<thead>
<tr>
<th>定 义</th>
<th>含 义</th>
</tr>
</thead>
<tbody><tr>
<td>int *p;</td>
<td>p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。</td>
</tr>
<tr>
<td>int **p;</td>
<td>p 为二级指针，指向 int * 类型的数据。</td>
</tr>
<tr>
<td>int *p[n];</td>
<td>p 为指针数组。 [ ] 的优先级高于 *，所以应该理解为 int *(p[n]);</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言数组</title>
    <url>/2023/07/09/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h5 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h5><h6 id="数组的概念和定义"><a href="#数组的概念和定义" class="headerlink" title="数组的概念和定义"></a>数组的概念和定义</h6><p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这样，就在内存中分配了 4 个 int 类型的内存空间，共 4×4&#x3D;16 个字节，并为它们起了一个名字， 叫 a。<span id="more"></span><br>我们把这样的一组数据的集合称为数组（Array） ，它所包含的每一个数据叫做数组元素（Element） ，所包含的数据的个数称为数组长度（Length） ，例如 int a[4];就定义了一个长度为 4 的整型数组，名字是 a。<br>数组中的每个元素都有一个序号，这个序号从 0 开始，而不是从我们熟悉的 1 开始，称为下标（Index） 。使用数组元素时，指明下标即可，形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arrayName[index]</span><br></pre></td></tr></table></figure>

<p>arrayName 为数组名称， index 为下标。例如， a[0] 表示第 0 个元素， a[3] 表示第 3 个元素。    </p>
<p>所以数组的定义方式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType arrayName[length];  </span><br></pre></td></tr></table></figure>

<p>dataType 为数据类型， arrayName 为数组名称， length 为数组长度。  </p>
<h6 id="数组内存是连续的"><a href="#数组内存是连续的" class="headerlink" title="数组内存是连续的"></a>数组内存是连续的</h6><p>数组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。   </p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组定义的一般形式是：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType arrayName[length1][length2];  </span><br></pre></td></tr></table></figure>

<p>其中， dataType 为数据类型， arrayName 为数组名， length1 为第一维下标的长度， length2 为第二维下标的长度。<br>我们可以将二维数组看做一个 Excel 表格，有行有列， length1 表示行数， length2 表示列数，要在二维数组中定位某个元素，必须同时指明行和列。 例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];  </span><br></pre></td></tr></table></figure>

<p>定义了一个 3 行 4 列的二维数组，共有 3×4&#x3D;12 个元素，数组名为 a，即：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">0</span>][<span class="number">1</span>], a[<span class="number">0</span>][<span class="number">2</span>], a[<span class="number">0</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，二维数组是按行排列的。 也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4)&#x3D;48 个字节。<br>可以认为，二维数组是由多个长度相同的一维数组构成的。</p>
<h6 id="二维数组的初始化（赋值）"><a href="#二维数组的初始化（赋值）" class="headerlink" title="二维数组的初始化（赋值）"></a>二维数组的初始化（赋值）</h6><p>二维数组的初始化可以按行分段赋值，也可按行连续赋值。</p>
<p>例如，对于数组 a[5][3]，按行分段赋值应该写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;, &#123;<span class="number">61</span>,<span class="number">65</span>,<span class="number">71</span>&#125;, &#123;<span class="number">59</span>,<span class="number">63</span>,<span class="number">70</span>&#125;, &#123;<span class="number">85</span>,<span class="number">87</span>,<span class="number">90</span>&#125;, &#123;<span class="number">76</span>,<span class="number">77</span>,<span class="number">85</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>按行连续赋值应该写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>]=&#123;<span class="number">80</span>, <span class="number">75</span>, <span class="number">92</span>, <span class="number">61</span>, <span class="number">65</span>, <span class="number">71</span>, <span class="number">59</span>, <span class="number">63</span>, <span class="number">70</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">90</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">85</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这两种赋初值的结果是完全相同的。    </p>
<p>对于二维数组的初始化还要注意以下几点：  </p>
<p>(1) 可以只对部分元素赋值，未赋值的元素自动取“零”值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>是对每一行的第一列元素赋值，未赋值的元素的值为 0。赋值后各元素的值为：<br>1 0 0<br>2 0 0<br>3 0 0<br>再如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值后各元素的值为：<br>0 1 0<br>0 0 2<br>3 0 0<br>(2)如果对全部元素赋值，那么第一维的长度可以不给出。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;  </span><br></pre></td></tr></table></figure>



<p>(3) 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当<br>然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组， C 语言允许这种分解。<br>例如，二维数组 a[3][4]可分解为三个一维数组，它们的数组名分别为 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>]、 a[<span class="number">1</span>]、 a[<span class="number">2</span>]  </span><br></pre></td></tr></table></figure>

<p>这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素，比如，一维数组 a[0] 的元素为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]、 a[<span class="number">0</span>][<span class="number">1</span>]、a[<span class="number">0</span>][<span class="number">2</span>]、 a[<span class="number">0</span>][<span class="number">3</span>]。  </span><br></pre></td></tr></table></figure>

<h5 id="C-语言字符数组和字符串"><a href="#C-语言字符数组和字符串" class="headerlink" title="C 语言字符数组和字符串"></a>C 语言字符数组和字符串</h5><h6 id="字符数组的格式"><a href="#字符数组的格式" class="headerlink" title="字符数组的格式"></a>字符数组的格式</h6><p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>]; <span class="comment">//一维字符数组</span></span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>][<span class="number">10</span>]; <span class="comment">//二维字符数组</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">20</span>] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span> &#125;; <span class="comment">// 给部分数组元素赋值</span></span><br><span class="line"><span class="type">char</span> d[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span> &#125;; <span class="comment">//对全体元素赋值时可以省去长度  </span></span><br></pre></td></tr></table></figure>

<p>字符数组实际上是一系列字符的集合，也就是字符串（String） 。在 C 语言中，没有专门的字符串变量，没有 string类型，通常就用一个字符数组来存放一个字符串。  </p>
<p>C 语言规定，可以将字符串直接赋值给字符数组，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = &#123; <span class="string">&quot;c.biancheng.net&quot;</span> &#125;; </span><br><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = <span class="string">&quot;c.biancheng.net&quot;</span>; <span class="comment">//这种形式更加简洁，实际开发中常用</span></span><br></pre></td></tr></table></figure>

<p>数组第 0 个元素为’c’，第 1 个元素为’.’，第 2 个元素为’b’，后面的元素以此类推。</p>
<p>为了方便，你也可以不指定数组长度，从而写作： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123; <span class="string">&quot;c.biancheng.net&quot;</span> &#125;;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;c.biancheng.net&quot;</span>; <span class="comment">//这种形式更加简洁，实际开发中常用  </span></span><br></pre></td></tr></table></figure>

<p>这里需要留意一个坑，字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了。请看下面的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">7</span>];</span><br><span class="line">str = <span class="string">&quot;abc123&quot;</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; str[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; str[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">str[<span class="number">3</span>] = <span class="string">&#x27;1&#x27;</span>; str[<span class="number">4</span>] = <span class="string">&#x27;2&#x27;</span>; str[<span class="number">5</span>] = <span class="string">&#x27;3&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<h6 id="字符串结束标志"><a href="#字符串结束标志" class="headerlink" title="字符串结束标志"></a>字符串结束标志</h6><p>在 C 语言中，字符串总是以’\0’作为结尾，所以’\0’也被称为字符串结束标志，或者字符串结束符。  </p>
<p>由” “包围的字符串会自动在末尾添加’\0’。 例如， “abc123”从表面看起来只包含了 6 个字符，其实不然， C 语言会在最后隐式地添加一个’\0’。</p>
<p>比如”C program”在内存中的存储情形：  </p>
<img src="/2023/07/09/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/image-20230710153027537.png" class="" title="image-20230710153027537">

<p>需要注意的是，逐个字符地给数组赋值并不会自动添加’\0’，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;  </span><br></pre></td></tr></table></figure>

<p>数组 str 的长度为 3，而不是 4，因为最后没有’\0’。<br>当用字符数组存储字符串时，要特别注意’\0’，要为’\0’留个位置；这意味着，字符数组的长度至少要比字符串的长度大 1。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">7</span>] = <span class="string">&quot;abc123&quot;</span>;  </span><br></pre></td></tr></table></figure>

<p>“bc123”看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的’\0’。如果将 str 的长度定义为 6，它就无法容纳’\0’了  。</p>
<p>另外，在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的“零”值。 </p>
<h6 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h6><p>字符串长度，就是字符串包含了多少个字符（不包括最后的结束符’\0’）。例如”abc”的长度是 3，而不是 4。  </p>
<p>在 C 语言中，我们使用 string.h 头文件中的 strlen() 函数来求字符串的长度，它的用法为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">length <span class="title function_">strlen</span><span class="params">(strname)</span>;  </span><br></pre></td></tr></table></figure>

<p>strname 是字符串的名字，或者字符数组的名字； length 是使用 strlen() 后得到的字符串长度，是一个整数。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//记得引入该头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;wearexc.github.io&quot;</span>;</span><br><span class="line"><span class="type">long</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The lenth of the string is %ld.\n&quot;</span>, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>The lenth of the string is 17.  </p>
<h6 id="补充：字符串的输入"><a href="#补充：字符串的输入" class="headerlink" title="补充：字符串的输入"></a>补充：字符串的输入</h6><p>在 C 语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：<br>     scanf()：通过格式控制符%s 输入字符串。除了字符串， scanf() 还能输入其他类型的数据。<br>    gets()：直接输入字符串，并且只能输入字符串。</p>
<p>但是， scanf() 和 gets() 是有区别的：</p>
<p>​	scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，一般无法读取含有空格的字符串。<br>​	 gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说， gets() 用来读取一整行字符串。  </p>
<p>其实 scanf() 也可以读取带空格的字符串。在C语言基础概念结尾有scanf()函数格式。</p>
<h5 id="拓展：C-语言字符串处理函数"><a href="#拓展：C-语言字符串处理函数" class="headerlink" title="拓展：C 语言字符串处理函数"></a>拓展：C 语言字符串处理函数</h5><p>string.h 是一个专门用来处理字符串的头文件，它包含了很多字符串处理函数，由于篇幅限制，本节仅讲解几个常用的。</p>
<h6 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat()"></a>字符串连接函数 strcat()</h6><p>strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1、 arrayName2 为需要拼接的字符串。<br>strcat() 将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志’\0’。 这意味arrayName1 必须足够长，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）。</p>
<p>strcat() 的返回值为 arrayName1 的地址。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;The URL is &quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">60</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input a URL: &quot;</span>);</span><br><span class="line">gets(str2);</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<p>Input a URL: wearexc.github.io<br>The URL is wearexc.github.io</p>
<h6 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy()"></a>字符串复制函数 strcpy()</h6><p>strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(arrayName1, arrayName2);  </span><br></pre></td></tr></table></figure>

<p>strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志’\0’也一同拷贝。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">50</span>] = <span class="string">&quot;随便什么东西&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">50</span>]=<span class="string">&quot;wearex&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>str1: wearex</p>
<p>另外， strcpy() 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。  </p>
<h6 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp()"></a>字符串比较函数 strcmp()</h6><p>strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1 和 arrayName2 是需要比较的两个字符串。<br>字符本身没有大小之分， strcmp() 以各个字符对应的 ASCII 码值进行比较。 strcmp() 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。<br>返回值：若 arrayName1 和 arrayName2 相同，则返回 0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于 0 的值。  </p>
<p>例如：对4 组字符串进行比较</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> a[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">        <span class="type">char</span> b[] = <span class="string">&quot;AbCdEf&quot;</span>;</span><br><span class="line">        <span class="type">char</span> c[] = <span class="string">&quot;aacdef&quot;</span>;</span><br><span class="line">        <span class="type">char</span> d[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS b: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS c: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, c));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a VS d: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>a VS b: 32<br>a VS c: -31<br>a VS d: 0  </p>
<h5 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h5><h6 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h6><p>对数组元素进行排序的方法有很多种，比如冒泡排序、归并排序、选择排序、 插入排序、快速排序等，其中最经典最需要掌握的是「冒泡排序」。  </p>
<p>以从小到大排序为例，冒泡排序的整体思想是这样的：</p>
<p>​	从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。  </p>
<p>第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。</p>
<p>以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。  </p>
<p>整个排序过程就好像气泡不断从水里冒出来，最大的先出来，次大的第二出来，最小的最后出来，所以将这种排序<br>方式称为冒泡排序（Bubble Sort） 。</p>
<p>下面我们以“3 2 4 1”为例对冒泡排序进行说明。</p>
<p>第一轮 排序过程<br>3 2 4 1 （最初）<br>2 3 4 1 （比较 3 和 2，交换）<br>2 3 4 1 （比较 3 和 4，不交换）<br>2 3 1 4 （比较 4 和 1，交换）<br>第一轮结束，最大的数字 4 已经在最后面，因此第二轮排序只需要对前面三个数进行比较。</p>
<p>第二轮 排序过程<br>2 3 1 4 （第一轮排序结果）<br>2 3 1 4 （比较 2 和 3，不交换）<br>2 1 3 4 （比较 3 和 1，交换）<br>第二轮结束，次大的数字 3 已经排在倒数第二个位置，所以第三轮只需要比较前两个元素。</p>
<p>第三轮 排序过程<br>2 1 3 4 （第二轮排序结果）<br>1 2 3 4 （比较 2 和 1，交换）</p>
<p>至此，排序结束  </p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i, j, temp;</span><br><span class="line"><span class="comment">//冒泡排序算法：进行 n-1 轮比较  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">//每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">10</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = nums[j];</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出排序后的数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h6><p>上面的算法是大部分教材中提供的算法，其中有一点是可以优化的：当比较到第 i 轮的时候，如果剩下的元素已经排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。</p>
<p>优化后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i, j, temp, isSorted;</span><br><span class="line"><span class="comment">//优化算法：最多进行 n-1 轮比较</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    isSorted = <span class="number">1</span>; <span class="comment">//假设剩下的元素已经排序好了</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">10</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp = nums[j];</span><br><span class="line">            nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">            nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            isSorted = <span class="number">0</span>; <span class="comment">//一旦需要交换数组元素，就说明剩下的元素没有排序好</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) <span class="keyword">break</span>; <span class="comment">//如果没有发生交换，说明剩下的元素已经排序好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言知识点补充</title>
    <url>/2023/07/18/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h5 id="typedef-的用法"><a href="#typedef-的用法" class="headerlink" title="typedef 的用法"></a>typedef 的用法</h5><p>C 语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。<span id="more"></span>例如有一个结构体的名字是 stu，要想定义一个结构体变量就得这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br></pre></td></tr></table></figure>

<p>struct 看起来就是多余的，但不写又会报错。如果为 struct stu 起了一个别名 STU，书写起来就简单了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU stu1;</span><br></pre></td></tr></table></figure>

<p>这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。<br>使用关键字 typedef 可以为类型起一个新的别名。 typedef 的用法一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> oldName newName;  </span><br></pre></td></tr></table></figure>

<p>ldName 是类型原来的名字， newName 是类型新的名字。例如  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>INTEGER a, b;等效于 int a, b;。</p>
<p>typedef 还可以给数组、 指针、结构体等类型定义别名。先来看一个给数组类型定义别名的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ARRAY20[<span class="number">20</span>]  </span><br></pre></td></tr></table></figure>

<p>表示 ARRAY20 是类型 char [20]的别名。它是一个长度为 20 的数组类型。接着可以用 ARRAY20 定义数组：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARRAY20 a1, a2, s1, s2;</span><br></pre></td></tr></table></figure>

<p>它等价于：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>]  </span><br></pre></td></tr></table></figure>

<p>为结构体类型定义别名：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; STU;  </span><br></pre></td></tr></table></figure>

<p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STU body1,body2;</span><br></pre></td></tr></table></figure>

<p>它等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">body1</span>, <span class="title">body2</span>;</span>  </span><br></pre></td></tr></table></figure>

<p>为指针类型定义别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_ARR)</span>[4];  </span><br></pre></td></tr></table></figure>

<p>表示 PTR_TO_ARR 是类型 int * [4]的别名，它是一个二维数组指针类型。接着可以使用 PTR_TO_ARR 定义二维数组指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTR_TO_ARR p1, p2;</span><br></pre></td></tr></table></figure>

<p>按照类似的写法，还可以为函数指针类型定义别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">PTR_TO_FUNC pfunc;  </span><br></pre></td></tr></table></figure>

<h6 id="typedef-和-define-的区别"><a href="#typedef-和-define-的区别" class="headerlink" title="typedef 和 #define 的区别"></a>typedef 和 #define 的区别</h6><p>typedef 在表现上有时候类似于 #define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把 typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。  </p>
<p>(1) 可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERGE int</span></span><br><span class="line"><span class="type">unsigned</span> INTERGE n; <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTERGE;</span><br><span class="line"><span class="type">unsigned</span> INTERGE n; <span class="comment">//错误，不能在 INTERGE 前面添加 unsigned  </span></span><br></pre></td></tr></table></figure>

<p>(2) 在连续定义几个变量的时候， typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_INT int *</span></span><br><span class="line">PTR_INT p1, p2;  </span><br></pre></td></tr></table></figure>

<p>经过宏替换以后，第二行变为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1, p2;  </span><br></pre></td></tr></table></figure>

<p>这使得 p1、 p2 成为不同的类型： p1 是指向 int 类型的指针， p2 是 int 类型。<br>相反，在下面的代码中 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_INT</span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure>

<p>p1、 p2 类型相同，它们都是指向 int 类型的指针。  </p>
<h5 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h5><p>有时候我们希望定义这样一种变量，它的值不能被改变，在整个作用域中都保持固定。例如，用一个变量来表示班级的最大人数，或者表示缓冲区的大小。为了满足这一要求，可以使用 const 关键字对变量加以限定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNum = <span class="number">100</span>; <span class="comment">//班级的最大人数</span></span><br></pre></td></tr></table></figure>

<p>这样 MaxNum 的值就不能被修改了，任何对 MaxNum 赋值的行为都将引发错误：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MaxNum = <span class="number">90</span>; <span class="comment">//错误，试图向 const 变量写入数据</span></span><br></pre></td></tr></table></figure>

<p>我们经常将 const 变量称为常量（Constant） 。创建常量的格式通常为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> type name = value;</span><br></pre></td></tr></table></figure>

<p>const 和 type 都是用来修饰变量的，它们的位置可以互换，也就是将 type 放在 const 前面：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="type">const</span> name = value;</span><br></pre></td></tr></table></figure>

<p>但我们通常采用第一种方式，不采用第二种方式。另外建议将常量名的首字母大写，以提醒程序员这是个常量。</p>
<p>由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。一如既往，初始化常量可以使用任意形式的表达式，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">90</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum1 = getNum(); <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum2 = n; <span class="comment">//运行时初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MaxNum3 = <span class="number">80</span>; <span class="comment">//编译时初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, MaxNum1, MaxNum2, MaxNum3); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>100, 90, 80  </p>
<h6 id="const-和指针"><a href="#const-和指针" class="headerlink" title="const 和指针"></a>const 和指针</h6><p>const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。 const 和指针一起使用会有几种不同的顺序，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p1;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p2;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p3;  </span><br></pre></td></tr></table></figure>

<p>在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、 p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。<br>当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p4;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p5;</span><br></pre></td></tr></table></figure>

<p>const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。  </p>
<h6 id="const-和函数形参"><a href="#const-和函数形参" class="headerlink" title="const 和函数形参"></a>const 和函数形参</h6><p>在 C 语言中，单独定义 const 变量没有明显的优势，完全可以使用#define 命令代替。 const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。  </p>
<p>在 C 语言标准库中，有很多函数的形参都被 const 限制了，下面是部分函数的原型：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* command)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * format, ... )</span>;  </span><br></pre></td></tr></table></figure>

<p>我们自己在定义函数时也可以使用 const 对形参加以限制，例如查找字符串中某个字符出现的次数：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strnchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> ch)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="number">0</span>, len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(str[i] == ch)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n = strnchr(str, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>3<br>根据 strnchr() 的功能可以推断，函数内部要对字符串 str 进行遍历，不应该有修改的动作，用 const 加以限制，不但可以防止由于程序员误操作引起的字符串修改，还可以给用户一个提示，函数不会修改你提供的字符串，请你放心。  </p>
<h6 id="const-和非-const-类型转换"><a href="#const-和非-const-类型转换" class="headerlink" title="const 和非 const 类型转换"></a>const 和非 const 类型转换</h6><p>当一个指针变量 str1 被 const 限制时，并且类似 const char *str1 这种形式，说明指针指向的数据不能被修改；如果将 str1 赋值给另外一个未被 const 修饰的指针变量 str2，就有可能发生危险。因为通过 str1 不能修改数据，</p>
<p>而赋值后通过 str2 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。<br>也就是说， const char *和 char *是不同的类型，不能将 const char *类型的数据赋值给 char *类型的变量。但反过来是可以的，编译器允许将 char *类型的数据赋值给 const char *类型的变量。</p>
<p>这种限制很容易理解， char *指向的数据有读取和写入权限，而 const char *指向的数据只有读取权限，降低数据的权限不会带来任何问题，但提升数据的权限就有可能发生危险。</p>
<p>下面是一个将 const 类型赋值给非 const 类型的例子：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *str)</span>&#123; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *str2 = str1;</span><br><span class="line">    func(str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 7、 8 行代码分别通过赋值、传参（传参的本质也是赋值）将 const 类型的数据交给了非 const 类型的变量，编译器不会容忍这种行为，会给出警告，甚至直接报错。  </p>
<h5 id="随机数：-rand-和-srand-函数"><a href="#随机数：-rand-和-srand-函数" class="headerlink" title="随机数： rand()和 srand()函数"></a>随机数： rand()和 srand()函数</h5><p>我们一般使用 &lt;stdlib.h&gt; 头文件中的 rand() 函数来生成随机数，它的用法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>void 表示不需要传递参数。<br>C 语言中还有一个 random() 函数可以获取随机数，但是 random() 不是标准函数，不能在 VC&#x2F;VS 等编译器通过，<br>所以比较少用。</p>
<p>rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。</p>
<p>RAND_MAX 是 &lt;stdlib.h&gt; 头文件中的一个宏，它用来指明 rand() 所能返回的随机数的最大值。 C 语言标准并没有规定 RAND_MAX 的具体数值，只是规定它的值至少为 32767。在实际编程中，我们也不需要知道 RAND_MAX的具体值，把它当做一个很大的数来对待即可。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>41</p>
<h6 id="随机数的本质"><a href="#随机数的本质" class="headerlink" title="随机数的本质"></a>随机数的本质</h6><p>多次运行，我们发现上面的代码产生的随机数都一样。因为， rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布，如下图所示：  </p>
<img src="/2023/07/18/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/image-20230719211647507.png" class="" title="image-20230719211647507">

<p>种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。  </p>
<h6 id="重新播种"><a href="#重新播种" class="headerlink" title="重新播种"></a>重新播种</h6><p>我们可以通过 srand() 函数来重新“播种”，这样种子就会发生改变。 srand() 的用法为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure>

<p>它需要一个 unsigned int 类型的参数。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。<br>使用 &lt;time.h&gt; 头文件中的 time() 函数即可得到当前的时间（精确到秒），就像下面这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));  </span><br></pre></td></tr></table></figure>

<p>对上面的代码进行修改，生成随机数之前先进行播种：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>多次运行程序，会发现每次生成的随机数都不一样了。但是，这些随机数会有逐渐增大或者逐渐减小的趋势，这是因为我们以时间为种子，时间是逐渐增大的，结合上面的正态分布图，很容易推断出随机数也会逐渐增大或者减小。  </p>
<h6 id="生成一定范围内的随机数"><a href="#生成一定范围内的随机数" class="headerlink" title="生成一定范围内的随机数"></a>生成一定范围内的随机数</h6><p>我们可以利用取模的方法，产生一定范围的随机数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = rand() % <span class="number">10</span>; <span class="comment">//产生 0~9 的随机数，注意 10 会被整除  </span></span><br></pre></td></tr></table></figure>

<p>如果要规定上下限：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = rand() % <span class="number">51</span> + <span class="number">13</span>; <span class="comment">//产生 13~63 的随机数  </span></span><br></pre></td></tr></table></figure>

<p>分析：取模即取余， rand()%51+13 我们可以看成两部分： rand()%51 是产生 0~50 的随机数，后面+13 保证 a 最小只能是 13，最大就是 50+13&#x3D;63。  </p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言结构体</title>
    <url>/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h5 id="结构体的基本概念"><a href="#结构体的基本概念" class="headerlink" title="结构体的基本概念"></a>结构体的基本概念</h5><p>C 语言结构体（Struct）从本质上讲是一种自定义的数据类型，只不过这种数据类型比较复杂，是由 int、 char、 float等基本类型组成的。你可以认为结构体是一种聚合类型。<span id="more"></span>   </p>
<p>结构体的定义形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">结构体所包含的变量或数组</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member） 。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>stu 为结构体名，它包含了 5 个成员，分别是 name、 num、 age、 group、 score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">注意大括号后面的分号;不能少，这是一条完整的语句。</span><br></pre></td></tr></table></figure>

<p>结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。</p>
<p>像 int、 float、 char 等是由 C 语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可<br>以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为复杂数据类型或构造数据类型。  </p>
<h6 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h6><p>既然结构体是一种数据类型，那么就可以用它来定义变量。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span></span><br></pre></td></tr></table></figure>

<p>定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字 struct 不能少。  </p>
<p>也可以在定义结构体的同时定义结构体变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号  </span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;  </span><br></pre></td></tr></table></figure>

<p>将变量放在结构体定义的最后即可。<br>如果只需要 stu1、 stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//没有写 stu</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;  </span><br></pre></td></tr></table></figure>

<p>理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 stu1、 stu2 的内存<br>分布如下图所示，共占用 4+4+4+1+4 &#x3D; 17 个字节。  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230718181836280.png" class="" title="image-20230718181836280">

<p>但是在编译器的具体实现中，各个成员之间可能会存在缝隙，对于 stu1、 stu2，成员变量 group 和 score 之间就存在 3 个字节的空白填充（见下图）。这样算来， stu1、 stu2 其实占用了 17 + 3 &#x3D; 20 个字节  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230718181858187.png" class="" title="image-20230718181858187">

<h6 id="成员的获取和赋值"><a href="#成员的获取和赋值" class="headerlink" title="成员的获取和赋值"></a>成员的获取和赋值</h6><p>结构体使用点号.获取单个成员。获取结构体成员的一般格式为 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">结构体变量名.成员名;  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">        <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">        <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">        <span class="type">char</span> group; <span class="comment">//所在小组  </span></span><br><span class="line">        <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">    &#125; stu1;</span><br><span class="line">    <span class="comment">//给结构体成员赋值</span></span><br><span class="line">    stu1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    stu1.num = <span class="number">12</span>;</span><br><span class="line">    stu1.age = <span class="number">18</span>;</span><br><span class="line">    stu1.group = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    stu1.score = <span class="number">136.5</span>;</span><br><span class="line">    <span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, stu1.name, stu1.num, stu1.age,</span><br><span class="line">    stu1.group, stu1.score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果<br>Tom 的学号是 12，年龄是 18，在 A 组，今年的成绩是 136.5！ </p>
<p> 除了可以对成员进行逐一赋值，也可以在定义时整体赋值，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;;  </span><br></pre></td></tr></table></figure>

<p>不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。</p>
<p>需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储 。</p>
<h5 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h5><p>所谓结构体数组，是指数组中的每个元素都是一个结构体。在实际应用中， C 语言结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。  </p>
<p>定义结构体数组和定义结构体变量的方式类似，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组  </span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[5];</span></span><br></pre></td></tr></table></figure>

<p>表示一个班级有 5 个学生。<br>结构体数组在定义的同时也可以初始化，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[5] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>当对数组中全部元素赋值时，也可不给出数组长度，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>结构体数组的使用也很简单，例如，获取 Wang ming 的成绩：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>[4].<span class="title">score</span>;</span></span><br></pre></td></tr></table></figure>

<p>修改 Li ping 的学习小组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>[0].<span class="title">group</span> =</span> <span class="string">&#x27;B&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<h5 id="结构体指针（指向结构体的指针）"><a href="#结构体指针（指向结构体的指针）" class="headerlink" title="结构体指针（指向结构体的指针）"></a>结构体指针（指向结构体的指针）</h5><p>当一个指针变量指向结构体时，我们就称它为结构体指针。 C 语言结构体指针的定义形式一般为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *变量名;</span></span><br></pre></td></tr></table></figure>

<p>例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;;</span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu1;  </span><br></pre></td></tr></table></figure>

<p>也可以在定义结构体的同时定义结构体指针：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;, *pstu = &amp;stu1;  </span><br></pre></td></tr></table></figure>

<p>注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表<br>达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp;，所以给 pstu 赋值只能写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu1;</span><br></pre></td></tr></table></figure>

<p>而不能写作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> stu1;</span><br></pre></td></tr></table></figure>

<p>还应该注意，结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不会为它分配内存空间，就像 int、 float、 char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。</p>
<p>下面的写法是错误的，不可能去取一个结构体名的地址，也不能将它赋值给其他变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> stu;  </span><br></pre></td></tr></table></figure>

<h6 id="获取结构体成员"><a href="#获取结构体成员" class="headerlink" title="获取结构体成员"></a>获取结构体成员</h6><p>通过结构体指针可以获取结构体成员，一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure>

<p>第一种写法中， .的优先级高于* ， ( * pointer)两边的括号不能少。如果去掉括号写作* pointer.memberName，那么就<br>等效于*(pointer.memberName)，这样意义就完全不对了。<br>第二种写法中，-&gt;是一个新的运算符，有了它，可以通过结构体指针直接取得结构体成员；</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄  </span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;, *pstu = &amp;stu1;</span><br><span class="line"><span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, (*pstu).name, (*pstu).num,(*pstu).age, (*pstu).group, (*pstu).score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！ \n&quot;</span>, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age,pstu-&gt;group, pstu-&gt;score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！<br>Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！</p>
<h6 id="结构体指针作为函数参数"><a href="#结构体指针作为函数参数" class="headerlink" title="结构体指针作为函数参数"></a>结构体指针作为函数参数</h6><p>结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编<br>译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运<br>行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。  </p>
<p>【示例】计算全班学生的总成绩、平均成绩和以及 140 分以下的人数。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;stus[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Li ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;He fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">average</span><span class="params">(<span class="keyword">struct</span> stu *ps, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(stus) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu);</span><br><span class="line">    average(stus, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">average</span><span class="params">(<span class="keyword">struct</span> stu *ps, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, num_140 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> average, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        sum += (ps + i) -&gt; score;  </span><br><span class="line">    <span class="keyword">if</span>((ps + i)-&gt;score &lt; <span class="number">140</span>) num_140++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%.2f\naverage=%.2f\nnum_140=%d\n&quot;</span>, sum, sum/<span class="number">5</span>, num_140);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>sum&#x3D;707.50<br>average&#x3D;141.50<br>num_140&#x3D;2  </p>
<h5 id="枚举类型（enum-关键字）"><a href="#枚举类型（enum-关键字）" class="headerlink" title="枚举类型（enum 关键字）"></a>枚举类型（enum 关键字）</h5><p>在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。</p>
<p>以每周七天为例，我们可以使用#define 命令来给每天指定一个名字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mon 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tues 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Wed 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Thurs 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fri 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sun 7</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> Mon: <span class="built_in">puts</span>(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tues: <span class="built_in">puts</span>(<span class="string">&quot;Tuesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Wed: <span class="built_in">puts</span>(<span class="string">&quot;Wednesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Thurs: <span class="built_in">puts</span>(<span class="string">&quot;Thursday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Fri: <span class="built_in">puts</span>(<span class="string">&quot;Friday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sat: <span class="built_in">puts</span>(<span class="string">&quot;Saturday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sun: <span class="built_in">puts</span>(<span class="string">&quot;Sunday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>5↙<br>Friday  </p>
<p>#define 命令虽然能解决问题，但也带来了不小的副作用，导致宏名过多，代码松散，看起来总有点不舒服。 C 语言提供了一种枚举（Enum）类型，能够列出所有可能的取值，并给它们取一个名字。  </p>
<p>枚举类型的定义形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;  </span><br></pre></td></tr></table></figure>

<p>enum 是一个新的关键字，专门用来定义枚举类型，这也是它在 C 语言中的唯一用途； typeName 是枚举类型的名字； valueName1, valueName2, valueName3, ……是每个值对应的名字的列表。</p>
<p>例如，列出一个星期有几天：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（增）；也就是说， week 中的 Mon、 Tues …… Sun 对应的值分别为 0、 1 …… 6。<br>我们也可以给每个名字都指定一个值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>更为简单的方法是只给第一个名字指定值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>这样枚举值就从 1 开始递增，跟上面的写法是等效的。<br>枚举是一种类型，通过它可以定义枚举变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>

<p>也可以在定义枚举类型的同时定义变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a, b, c;</span><br></pre></td></tr></table></figure>

<p>有了枚举变量，就可以把列表中的值赋给它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br><span class="line">enum week a = Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a = Mon, b = Wed, c = Sat;  </span><br></pre></td></tr></table></figure>

<p>【示例】判断用户输入的是星期几。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;  </span><br><span class="line">    <span class="keyword">case</span> Mon: <span class="built_in">puts</span>(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Tues: <span class="built_in">puts</span>(<span class="string">&quot;Tuesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Wed: <span class="built_in">puts</span>(<span class="string">&quot;Wednesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Thurs: <span class="built_in">puts</span>(<span class="string">&quot;Thursday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Fri: <span class="built_in">puts</span>(<span class="string">&quot;Friday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sat: <span class="built_in">puts</span>(<span class="string">&quot;Saturday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sun: <span class="built_in">puts</span>(<span class="string">&quot;Sunday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>4↙<br>Thursday</p>
<p>需要注意的两点是：</p>
<p>(1) 枚举列表中的 Mon、 Tues、 Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。</p>
<p>(2) Mon、 Tues、 Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。</p>
<p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可<br>以将枚举理解为编译阶段的宏。  </p>
<h5 id="共用体（union-关键字）"><a href="#共用体（union-关键字）" class="headerlink" title="共用体（union 关键字）"></a>共用体（union 关键字）</h5><p>共用体（Union）和结构体的语法类似 ，它的定义格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">成员列表</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。</p>
<p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。  </p>
<p>共用体也是一种自定义类型，可以通过它来创建变量，例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;  </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125; a, b, c;  </span><br></pre></td></tr></table></figure>

<p>如果不再定义新的变量，也可以将共用体的名字省略：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125; a, b, c;  </span><br></pre></td></tr></table></figure>

<p>共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、 b、 c）也占用 8 个字节的内存，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> data) );</span><br><span class="line">    a.n = <span class="number">0x40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.ch = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.m = <span class="number">0x2059</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%X, %c, %hX\n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>4, 4<br>40, @, 40<br>39, 9, 39<br>2059, Y, 2059<br>3E25AD54, T, AD54</p>
<p>这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。<br>要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的data 为例，各个成员在内存中的分布如下：  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230719001444454.png" class="" title="image-20230719001444454">

<p>成员 n、 ch、 m 在内存中“对齐”到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对n 赋值修改的是全部字节。也就是说， ch、 m 会影响到 n 的一部分数据，而 n 会影响到 ch、 m 的全部数据。  </p>
<p>上图是在绝大多数 PC 机上的内存分布情况，如果是 51 单片机，情况就会有所不同：  </p>
<img src="/2023/07/15/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/image-20230719001645782.png" class="" title="image-20230719001645782">

<p>这是和机器的存储模式，大端小端有关。</p>
<h6 id="共用体的应用"><a href="#共用体的应用" class="headerlink" title="共用体的应用"></a>共用体的应用</h6><p>共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：  </p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Num</th>
<th>Sex</th>
<th>Profession</th>
<th>Score &#x2F; Course</th>
</tr>
</thead>
<tbody><tr>
<td>HanXiaoXiao</td>
<td>501</td>
<td>f</td>
<td>s</td>
<td>89.5</td>
</tr>
<tr>
<td>YanWeiMin</td>
<td>1011</td>
<td>m</td>
<td>t</td>
<td>math</td>
</tr>
<tr>
<td>LiuZhenTao</td>
<td>109</td>
<td>f</td>
<td>t</td>
<td>English</td>
</tr>
<tr>
<td>ZhaoFeiYan</td>
<td>982</td>
<td>m</td>
<td>s</td>
<td>95.0</td>
</tr>
</tbody></table>
<p>f 和 m 分别表示女性和男性， s 表示学生， t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。</p>
<p>如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。</p>
<p>经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 4 <span class="comment">//人员总数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">char</span> profession;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">        <span class="type">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc;</span><br><span class="line">&#125; bodys[TOTAL];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input info: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %c %c&quot;</span>, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession));</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex,bodys[i].profession, bodys[i].sc.score);  </span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex,</span><br><span class="line">bodys[i].profession, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input info: HanXiaoXiao 501 f s 89.5↙<br>Input info: YanWeiMin 1011 m t math↙<br>Input info: LiuZhenTao 109 f t English↙<br>Input info: ZhaoFeiYan 982 m s 95.0↙</p>
<p>Name Num Sex Profession Score &#x2F; Course<br>HanXiaoXiao 501 f s 89.500000<br>YanWeiMin 1011 m t math<br>LiuZhenTao 109 f t English<br>ZhaoFeiYan 982 m s 95.000000  </p>
<h5 id="大端小端以及判别方式"><a href="#大端小端以及判别方式" class="headerlink" title="大端小端以及判别方式"></a>大端小端以及判别方式</h5><p>大端和小端是指数据在内存中的存储模式，它由 CPU 决定：<br>(1) 大端模式（ Big-endian） 是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。</p>
<p>(2) 小端模式（ Little-endian） 是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。  </p>
<h6 id="为什么有大小端模式之分"><a href="#为什么有大小端模式之分" class="headerlink" title="为什么有大小端模式之分"></a>为什么有大小端模式之分</h6><p>计算机中的数据是以字节（ Byte）为单位存储的，每个字节都有不同的地址。现代 CPU 的位数（可以理解为一次能处理的数据的位数）都超过了 8 位（一个字节）， PC 机、服务器的 CPU 基本都是 64 位的，嵌入式系统或单片机系统仍然在使用 32 位和 16 位的 CPU。</p>
<p>对于一次能处理多个字节的 CPU，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以 int 类型的 0x12345678 为例，它占用 4 个字节，如果是小端模式（ Little-endian），那么在内存中的分布情况为（假设从地址 0x 4000 开始存放）：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody><tr>
<td>存放内容</td>
<td>0x78</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>如果是大端模式（ Big-endian），那么分布情况正好相反：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000</th>
<th>0x4001</th>
<th>0x4002</th>
<th>0x4003</th>
</tr>
</thead>
<tbody><tr>
<td>存放内容</td>
<td>0x12</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78</td>
</tr>
</tbody></table>
<p>我们的 PC 机上使用的是 X86 结构的 CPU，它是小端模式； 51 单片机是大端模式；很多 ARM、 DSP 也是小端模式（部分 ARM 处理器还可以由硬件来选择是大端模式还是小端模式）。</p>
<h5 id="位域（位段）"><a href="#位域（位段）" class="headerlink" title="位域（位段）"></a>位域（位段）</h5><p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑， C 语言又提供了一种叫做位域的数据结构。</p>
<p><strong>在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。</strong>  例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> m;</span><br><span class="line">    <span class="type">unsigned</span> n: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ch: <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后面的数字用来限定成员变量占用的位数。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、 ch 被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、 6 位（Bit）的内存。  </p>
<p>C 语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度， :后面的数字不能超过这个长度。  </p>
<p>C 语言标准还规定，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、 signed int 和unsigned int（int 默认就是 signed int）；到了 C99， _Bool 也被支持了。</p>
<h6 id="无名位域"><a href="#无名位域" class="headerlink" title="无名位域"></a>无名位域</h6><p>  位域成员可以没有名称，只给出数据类型和位宽，如下所示：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> m: <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> : <span class="number">20</span>; <span class="comment">//该位域成员不能使用</span></span><br><span class="line">    <span class="type">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。  </p>
<h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>这个在数字电路和单片机学过，C语言的也一样，仅记录。</p>
<p>C 语言提供了六种位运算符：  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>&amp;</th>
<th>|</th>
<th>^</th>
<th>~</th>
<th>&lt;&lt;</th>
<th>&gt;&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>按位与</td>
<td>按位或</td>
<td>按位异或</td>
<td>取反</td>
<td>左移</td>
<td>右移</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言预处理命令</title>
    <url>/2023/07/11/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h6 id="预处理命令简谈"><a href="#预处理命令简谈" class="headerlink" title="预处理命令简谈"></a>预处理命令简谈</h6><p>使用库函数之前，应该用#include 引入对应的头文件。 这种以#号开<br>头的命令称为预处理命令。  <span id="more"></span></p>
<p>预处理是 C 语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。</p>
<p>编译器会将预处理的结果保存到和源文件同名的.i 文件中，例如 main.c 的预处理结果在 main.i 中。和.c 一样， .i也是文本文件，可以用编辑器打开直接查看内容。</p>
<p>C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。  </p>
<h6 id="include-的用法（文件包含命令）"><a href="#include-的用法（文件包含命令）" class="headerlink" title="#include 的用法（文件包含命令）"></a>#include 的用法（文件包含命令）</h6><p>#include 叫做文件包含命令，用来引入对应的头文件（.h 文件）  </p>
<p>用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdHeader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myHeader.h&quot;</span>  </span></span><br></pre></td></tr></table></figure>

<p>使用尖括号&lt; &gt;和双引号” “的区别在于头文件的搜索路径不同：</p>
<p>​	使用尖括号&lt; &gt;，编译器会到系统路径下查找头文件；</p>
<p>​	而使用双引号” “，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</p>
<p>stdio.h 和 stdlib.h 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。  </p>
<p>例如：</p>
<img src="/2023/07/11/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/image-20230711171446610.png" class="" title="image-20230711171446610">

<p>my.c 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算从m加到n的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>my.h 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span>;  </span><br></pre></td></tr></table></figure>

<p>main.c 所包含的代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>另外，不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。  </p>
<h5 id="宏定义（-define-的用法）"><a href="#宏定义（-define-的用法）" class="headerlink" title="宏定义（#define 的用法）"></a>宏定义（#define 的用法）</h5><p>#define 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">20</span> + N;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>120  </p>
<p>注意第 6 行代码 int sum &#x3D; 20 + N， N 被 100 代替了。</p>
<p>#define N 100 就是宏定义， N 为宏名， 100 是宏的内容（宏所表示的字符串）。在预处理阶段，对程序中所有出现  的“宏名”，预处理器都会用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p>
<p>宏定义是由源程序中的宏定义命令#define 完成的，宏替换是由预处理程序完成的。</p>
<p>宏定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></table></figure>

<p>#表示这是一条预处理命令，所有的预处理命令都以 # 开头。 宏名是标识符的一种，命名规则和变量相同。 字符串可以是数字、表达式、 if 语句、函数等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号。</span><br></pre></td></tr></table></figure>

<p>程序中反复使用的表达式就可以使用宏定义，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M (n*n+3*n)</span></span><br></pre></td></tr></table></figure>

<p>它的作用是指定标识符 M 来表示(y<em>y+3</em>y)这个表达式。在编写代码时，所有出现 (y<em>y+3</em>y) 的地方都可以用 M 来表示，而对源程序编译时，将先由预处理程序进行宏代替，即用 (y<em>y+3</em>y) 去替换所有的宏名 M，然后再进行编译。  </p>
<h6 id="对-define-用法的几点说明"><a href="#对-define-用法的几点说明" class="headerlink" title="对 #define 用法的几点说明"></a>对 #define 用法的几点说明</h6><p>(1) 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中<br>可以含任何字符，它可以是常数、表达式、 if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编<br>译已被宏展开后的源程序时发现。<br>(2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。<br>(3) 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef 命令。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>表示 PI 只在 main() 函数中有效，在 func() 中无效。  </p>
<p>(4) 代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替，例如 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果：<br>OK<br>该例中定义宏名 OK 表示 100，但在 printf 语句中 OK 被引号括起来，因此不作宏替换，而作为字符串处理。  </p>
<p>(5) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。例如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S PI*y*y <span class="comment">/* PI 是已定义的宏名*/</span>  </span></span><br></pre></td></tr></table></figure>

<p>对语句：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, S);  </span><br></pre></td></tr></table></figure>

<p>在宏代换后变为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, <span class="number">3.1415926</span>*y*y);  </span><br></pre></td></tr></table></figure>

<p>(6) 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。<br>(7) 可用宏定义表示数据类型，使书写方便。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UINT unsigned int</span></span><br></pre></td></tr></table></figure>

<p>在程序中可用 UINT 作变量说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UINT a, b;</span><br></pre></td></tr></table></figure>

<p>应注意用宏定义表示数据类型和用 typedef 定义数据说明符的区别。 宏定义只是简单的字符串替换，由预处理器来处理；而 typedef 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。<br>请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIN1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *PIN2; <span class="comment">//也可以写作 typedef int (*PIN2);</span></span><br></pre></td></tr></table></figure>

<p>从形式上看这两者相似， 但在实际使用中却不相同。<br>下面用 PIN1， PIN2 说明变量时就可以看出它们的区别：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIN1 a, b;</span><br></pre></td></tr></table></figure>

<p>在宏代换后变成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a, b;</span><br></pre></td></tr></table></figure>

<p>表示 a 是指向整型的指针变量，而 b 是整型变量。然而：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIN2 a,b;</span><br></pre></td></tr></table></figure>

<p>表示 a、 b 都是指向整型的指针变量。因为 PIN2 是一个新的、完整的数据类型。 由这个例子可见，宏定义虽然也可表示数据类型， 但毕竟只是简单的字符串替换。在使用时要格外小心，以避出错。  </p>
<h5 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h5><p>C 语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。<br>对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。<br>带参宏定义的一般形式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(形参列表) 字符串  </span></span><br></pre></td></tr></table></figure>

<p>在字符串中可以含有各个形参。<br>带参宏调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">宏名(实参列表);  </span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M(y) y*y+3*y <span class="comment">//宏定义</span></span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">k=M(<span class="number">5</span>); <span class="comment">//宏调用</span></span><br></pre></td></tr></table></figure>

<p>在宏展开时，用实参 5 去代替形参 y，经预处理程序展开后的语句为 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k=<span class="number">5</span>*<span class="number">5</span>+<span class="number">3</span>*<span class="number">5</span>。 </span><br></pre></td></tr></table></figure>

<h6 id="对带参宏定义的说明"><a href="#对带参宏定义的说明" class="headerlink" title="对带参宏定义的说明"></a>对带参宏定义的说明</h6><p>(1) 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。例如把：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b)?a:b</span></span><br></pre></td></tr></table></figure>

<p>写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (a,b) (a&gt;b)?a:b</span></span><br></pre></td></tr></table></figure>

<p>将被认为是无参宏定义，宏名 MAX 代表字符串(a,b) (a&gt;b)?a:b。宏展开时，宏调用语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = MAX(x,y);  </span><br></pre></td></tr></table></figure>

<p>将变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = (a,b)(a&gt;b)?a:b(x,y);</span><br></pre></td></tr></table></figure>

<p>这显然是错误的。  </p>
<p>(2) 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。</p>
<p>这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。  </p>
<p>带参宏定义和函数的区别 ：</p>
<p>带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。  </p>
<h6 id="宏参数的字符串化和宏参数的连接"><a href="#宏参数的字符串化和宏参数的连接" class="headerlink" title="宏参数的字符串化和宏参数的连接"></a>宏参数的字符串化和宏参数的连接</h6><p>在宏定义中，有时还会用到#和##两个符号，它们能够对宏参数进行操作。<br><strong># 的用法</strong><br>#用来将宏参数转换为字符串，也就是在宏参数的开头和末尾添加引号。例如有如下宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) #s</span></span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(c.biancheng.net));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(<span class="string">&quot;c.biancheng.net&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>分别被展开为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;c.biancheng.net&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\&quot;c.biancheng.net\&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现，即使给宏参数“传递”的数据中包含引号，使用#仍然会在两头添加新的引号，而原来的引号会被转义。  </p>
<p><strong>##的用法</strong><br>##称为连接符，用来将宏参数或其他的串连接起来。例如有如下的宏定义：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CON1(a, b) a##e##b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CON2(a, b) a##b##00</span></span><br></pre></td></tr></table></figure>

<p>那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, CON1(<span class="number">8.5</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CON2(<span class="number">12</span>, <span class="number">34</span>));</span><br></pre></td></tr></table></figure>

<p>将被展开为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">8.5e2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123400</span>);  </span><br></pre></td></tr></table></figure>

<h6 id="C-语言中几个预定义宏"><a href="#C-语言中几个预定义宏" class="headerlink" title="C 语言中几个预定义宏"></a>C 语言中几个预定义宏</h6><p>顾名思义，预定义宏就是已经预先定义好的宏，我们可以直接使用，无需再重新定义。<br>ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用：<br>     __LINE__：表示当前源代码的行号；<br>    __FILE__：表示当前源文件的名称；<br>    __DATE__：表示当前的编译日期；<br>    __TIME__：表示当前的编译时间；<br>    __STDC__：当要求程序严格遵循 ANSI C 标准时该标识被赋值为 1；<br>    __cplusplus：当编写 C++程序时该标识符被定义  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Date : %s\n&quot;</span>, __DATE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time : %s\n&quot;</span>, __TIME__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File : %s\n&quot;</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Line : %d\n&quot;</span>, __LINE__);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Date : Jul 12 2023<br>Time : 18:57:36<br>File : C:\Users\90872\Desktop\未命名1.cpp<br>Line : 7</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>简单来说，根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。 条件编译是预处理程序的功能，不是编译器的功能。  </p>
<h6 id="if-的用法"><a href="#if-的用法" class="headerlink" title="#if 的用法"></a>#if 的用法</h6><p>#if 用法的一般格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 整型常量表达式 1</span></span><br><span class="line">程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整型常量表达式 2</span></span><br><span class="line">程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整型常量表达式 3</span></span><br><span class="line">程序段 <span class="number">3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段 <span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>它的意思是：如常“表达式 1”的值为真（非 0），就对“程序段 1”进行编译，否则就计算“表达式 2”，结果为真的话就对“程序段 2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。</p>
<p>需要注意的是， #if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。  </p>
<p>和 #else 也可以省略，如下所示 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is Windows!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unknown platform!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is Linux!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h6 id="ifdef-的用法"><a href="#ifdef-的用法" class="headerlink" title="#ifdef 的用法"></a>#ifdef 的用法</h6><p>#ifdef 用法的一般格式为：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    程序段 <span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>它的意思是，如果当前的宏已被定义过，则对“程序段 1”进行编译，否则对“程序段 2”进行编译。<br>也可以省略 #else：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    程序段</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<h6 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a>#ifndef 的用法</h6><p>#ifndef 用法的一般格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">	程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br></pre></td></tr></table></figure>

<p>与 #ifdef 相比，仅仅是将 #ifdef 改为了 #ifndef。它的意思是，如果当前的宏未被定义，则对“程序段 1”进行编译，否则对“程序段 2”进行编译，这与 #ifdef 的功能正好相反  </p>
<h6 id="三者之间的区别"><a href="#三者之间的区别" class="headerlink" title="三者之间的区别"></a>三者之间的区别</h6><p>最后需要注意的是， #if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。  </p>
<p>#ifdef 可以认为是 #if defined 的缩写  </p>
<h5 id="error-命令，阻止程序编译"><a href="#error-命令，阻止程序编译" class="headerlink" title="#error 命令，阻止程序编译"></a>#error 命令，阻止程序编译</h5><p>#error 指令用于在编译期间产生错误信息，并阻止程序的编译，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span> error_message</span></span><br></pre></td></tr></table></figure>

<p>例如，我们的程序针对 Linux 编写，不保证兼容 Windows，那么可以这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> This programme cannot compile at Windows Platform</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>WIN32 是 Windows 下的预定义宏。当用户在 Windows 下编译该程序时，由于定义了 WIN32 这个宏，所以<br>会执行 #error 命令，提示用户发生了编译错误，错误信息是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">This programme cannot compile at Windows Platform</span><br></pre></td></tr></table></figure>

<p>这和发生语法错误的效果是一样的，程序编译失败。</p>
<h5 id="C-语言预处理命令总结"><a href="#C-语言预处理命令总结" class="headerlink" title="C 语言预处理命令总结"></a>C 语言预处理命令总结</h5><p>预处理指令是以#号开头的代码行， # 号必须是该行除了任何空白字符外的第一个字符。 # 后是指令关键字，在关键字和 # 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。  </p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>空指令，无任何效果</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则编译下面代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则编译下面代码</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的#if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个#if……#else 条件编译块</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32标准库</title>
    <url>/2023/08/02/STM32%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p>整理笔记时发现自己如果列举代码，会更加有效。但插入代码块到其中会比较繁琐，而且各个知识的代码的耦合性较强，反复列举较为麻烦，所以开一个新的文章，专门记录整理标准库代码。仅记录个人常用，建议参考手册，或直接跳转函数定义，浏览官方说明。<span id="more"></span></p>
<h3 id="时钟控制"><a href="#时钟控制" class="headerlink" title="时钟控制"></a>时钟控制</h3><p>时钟就像人的心跳，人的运动先需要跳动心脏。STM32的片上外设也是一样，如果要使用外设，例如：GPIO，NVIC，ADC等等，需要先开启外设挂载的总线时钟。</p>
<p>以下是标准库中对时钟控制函数的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AHB总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//APB2总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//APB1总线时钟控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数为外设，例如APB2的外设：RCC_APB2Periph_GPIOA，RCC_APB2Periph_GPIOB，RCC_APB2Periph_TIM1等，</p>
<p>第二个参数为使能或者失能。（ENABLE&#x2F;DISABLE）</p>
<p>比如开启APB2的GPIOA为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br></pre></td></tr></table></figure>

<p>外设的使用必须先开启时钟。</p>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定GPIO初始化为默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//功能复用，重新映射事件控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//用结构体参数初始化GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//将结构体的变量，赋为初始值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">//读取指定输入GPIO口的值，返回0/1</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//读取指定输入GPIO组的数据端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//读取指定输出GPIO口的值，返回0/1</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//读取指定输出GPIO组的数据端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">//指定端口输出为高电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//指定端口输出为低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//指定GPIO组的某个GPIO并赋值（高低电平）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;</span><br><span class="line"><span class="comment">//指定GPIO组，并写入端口输出数据寄存器（ODR寄存器）的值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">//锁定GPIO管脚配置寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="comment">//选择用作事件输出的GPIO引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;</span><br><span class="line"><span class="comment">//使能输出事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//改变指定管脚的映射，为了更大利用IO口，部分IO口可以进行复用或者映射。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//选择 GPIO 管脚用作外部中断源</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;</span><br><span class="line"><span class="comment">//选择以太网媒体接口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ETH_MediaInterfaceConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_ETH_MediaInterface)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">//选择GPIO口</span></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">//选择运行速度</span></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">//配置G</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p><strong>GPIO模式</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span> GPIO_Mode_AIN = <span class="number">0x0</span>,               <span class="comment">//模拟输入</span></span><br><span class="line">  GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,      <span class="comment">//浮空输入</span></span><br><span class="line">  GPIO_Mode_IPD = <span class="number">0x28</span>,              <span class="comment">//下拉输入</span></span><br><span class="line">  GPIO_Mode_IPU = <span class="number">0x48</span>,              <span class="comment">//上拉输入</span></span><br><span class="line">  GPIO_Mode_Out_OD = <span class="number">0x14</span>,           <span class="comment">//开漏输出</span></span><br><span class="line">  GPIO_Mode_Out_PP = <span class="number">0x10</span>,           <span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_Mode_AF_OD = <span class="number">0x1C</span>,            <span class="comment">//复用开漏</span></span><br><span class="line">  GPIO_Mode_AF_PP = <span class="number">0x18</span>             <span class="comment">//复用推挽</span></span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>



<h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;                  <span class="comment">//设置中断优先级分组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span>;                           <span class="comment">//用结构体参数配置NVIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SetVectorTable</span><span class="params">(<span class="type">uint32_t</span> NVIC_VectTab, <span class="type">uint32_t</span> Offset)</span>;            <span class="comment">//设置中断向量表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SystemLPConfig</span><span class="params">(<span class="type">uint8_t</span> LowPowerMode, FunctionalState NewState)</span>;    <span class="comment">//系统低功耗配置</span></span><br></pre></td></tr></table></figure>



<h3 id="EXIT"><a href="#EXIT" class="headerlink" title="EXIT"></a>EXIT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI_DeInit</span><span class="params">(<span class="type">void</span>)</span>;              	                   <span class="comment">//清除EXTI配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;         <span class="comment">//用结构体参数配置EXTI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;   <span class="comment">//给结构体赋予默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;         <span class="comment">//软件触发外部中断</span></span><br><span class="line">FlagStatus <span class="title function_">EXTI_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;         <span class="comment">//获取指定的的中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;                   <span class="comment">//清除中断标志位</span></span><br><span class="line">ITStatus <span class="title function_">EXTI_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;             <span class="comment">//在中断函数里获取标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;           <span class="comment">//在中断函数里清除标志位</span></span><br></pre></td></tr></table></figure>

<p><strong>结构体</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> EXTI_Line;               <span class="comment">//指定配置的中断线</span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;       <span class="comment">//指定中断模式</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger; <span class="comment">//指定配置的中断线</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;     <span class="comment">//指定触发中断的模式</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h3 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h3><p>过长，具体参考STM32固件函数库手册。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TIM_DeInit</td>
<td>将外设 TIMx 寄存器重设为缺省值</td>
</tr>
<tr>
<td>TIM_TimeBaseInit</td>
<td>根据 TIM_TimeBaseInitStruct 中指定的参数初始化   间基数单位</td>
</tr>
<tr>
<td>TIM_OCInit</td>
<td>根据 TIM_OCInitStruct 中指定的参数初始化外设</td>
</tr>
<tr>
<td>TIM_ICInit</td>
<td>根据 TIM_ICInitStruct 中指定的参数初始化外设 T</td>
</tr>
<tr>
<td>TIM_TimeBaseStructInit</td>
<td>把 TIM_TimeBaseInitStruct 中的每一个参数按缺省</td>
</tr>
<tr>
<td>TIM_OCStructInit</td>
<td>把 TIM_OCInitStruct 中的每一个参数按缺省值填</td>
</tr>
<tr>
<td>TIM_ICStructInit</td>
<td>把 TIM_ICInitStruct 中的每一个参数按缺省值填入</td>
</tr>
<tr>
<td>TIM_Cmd</td>
<td>使能或者失能 TIMx 外设</td>
</tr>
<tr>
<td>TIM _ITConfig</td>
<td>使能或者失能指定的 TIM 中断</td>
</tr>
<tr>
<td>TIM_DMAConfig</td>
<td>设置 TIMx 的 DMA 接口</td>
</tr>
<tr>
<td>TIM_DMACmd</td>
<td>使能或者失能指定的 TIMx 的 DMA 请求</td>
</tr>
<tr>
<td>TIM_InternalClockConfig</td>
<td>设置 TIMx 内部时钟</td>
</tr>
<tr>
<td>TIM_ITRxExternalClockConfig</td>
<td>设置 TIMx 内部触发为外部时钟模式</td>
</tr>
<tr>
<td>TIM_TIxExternalClockConfig</td>
<td>设置 TIMx 触发为外部时钟</td>
</tr>
<tr>
<td>TIM_ETRClockMode1Config</td>
<td>配置 TIMx 外部时钟模式  1</td>
</tr>
<tr>
<td>TIM_ETRClockMode2Config</td>
<td>配置 TIMx 外部时钟模式  2</td>
</tr>
<tr>
<td>TIM_ETRConfig</td>
<td>配置 TIMx 外部触发</td>
</tr>
<tr>
<td>TIM_SelectInputTrigger</td>
<td>选择 TIMx 输入触发源</td>
</tr>
<tr>
<td>TIM_PrescalerConfig</td>
<td>设置 TIMx 预分频</td>
</tr>
<tr>
<td>TIM_CounterModeConfig</td>
<td>设置 TIMx 计数器模式</td>
</tr>
<tr>
<td>TIM_ForcedOC1Config</td>
<td>置 TIMx 输出 1 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC2Config</td>
<td>置 TIMx 输出 2 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC3Config</td>
<td>置 TIMx 输出 3 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ForcedOC4Config</td>
<td>置 TIMx 输出 4 为活动或者非活动电平</td>
</tr>
<tr>
<td>TIM_ARRPreloadConfig</td>
<td>使能或者失能 TIMx 在 ARR 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_SelectCCDMA</td>
<td>选择 TIMx 外设的捕获比较  DMA 源</td>
</tr>
<tr>
<td>TIM_OC1PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR1 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC2PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR2 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC3PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR3 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC4PreloadConfig</td>
<td>使能或者失能 TIMx 在 CCR4 上的预装载寄存器</td>
</tr>
<tr>
<td>TIM_OC1FastConfig</td>
<td>设置 TIMx 捕获比较  1 快速特征</td>
</tr>
<tr>
<td>TIM_OC2FastConfig</td>
<td>设置 TIMx 捕获比较 2  快速特征</td>
</tr>
<tr>
<td>TIM_OC3FastConfig</td>
<td>设置 TIMx 捕获比较 3  快速特征</td>
</tr>
<tr>
<td>TIM_OC4FastConfig</td>
<td>设置 TIMx 捕获比较 4  快速特征</td>
</tr>
<tr>
<td>TIM_ClearOC1Ref</td>
<td>在一个外部事件时清除或者保持 OCREF1 信号</td>
</tr>
<tr>
<td>TIM_ClearOC2Ref</td>
<td>在一个外部事件时清除或者保持 OCREF2 信号</td>
</tr>
<tr>
<td>TIM_ClearOC3Ref</td>
<td>在一个外部事件时清除或者保持 OCREF3 信号</td>
</tr>
<tr>
<td>TIM_ClearOC4Ref</td>
<td>在一个外部事件时清除或者保持 OCREF4 信号</td>
</tr>
<tr>
<td>TIM_UpdateDisableConfig</td>
<td>使能或者失能 TIMx 更新事件</td>
</tr>
<tr>
<td>TIM_EncoderInterfaceConfig</td>
<td>设置 TIMx 编码界面</td>
</tr>
<tr>
<td>TIM_GenerateEvent</td>
<td>设置 TIMx 事件由软件产生</td>
</tr>
<tr>
<td>TIM_OC1PolarityConfig</td>
<td>设置 TIMx 通道 1 极性</td>
</tr>
<tr>
<td>TIM_OC2PolarityConfig</td>
<td>设置 TIMx 通道 2 极性</td>
</tr>
<tr>
<td>TIM_OC3PolarityConfig</td>
<td>设置 TIMx 通道 3 极性</td>
</tr>
<tr>
<td>TIM_OC4PolarityConfig</td>
<td>设置 TIMx 通道 4 极性</td>
</tr>
<tr>
<td>TIM_UpdateRequestConfig</td>
<td>设置 TIMx 更新请求源</td>
</tr>
<tr>
<td>TIM_SelectHallSensor</td>
<td>使能或者失能 TIMx 霍尔传感器接口</td>
</tr>
<tr>
<td>TIM_SelectOnePulseMode</td>
<td>设置 TIMx 单脉冲模式</td>
</tr>
<tr>
<td>TIM_SelectOutputTrigger</td>
<td>选择 TIMx 触发输出模式</td>
</tr>
<tr>
<td>TIM_SelectSlaveMode</td>
<td>选择 TIMx 从模式</td>
</tr>
<tr>
<td>TIM_SelectMasterSlaveMode</td>
<td>设置或者重置 TIMx 主&#x2F;从模式</td>
</tr>
<tr>
<td>TIM_SetCounter</td>
<td>设置 TIMx 计数器寄存器值</td>
</tr>
<tr>
<td>TIM_SetAutoreload</td>
<td>设置 TIMx 自动重装载寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare1</td>
<td>设置 TIMx 捕获比较 1  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare2</td>
<td>设置 TIMx 捕获比较 2  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare3</td>
<td>设置 TIMx 捕获比较 3  寄存器值</td>
</tr>
<tr>
<td>TIM_SetCompare4</td>
<td>设置 TIMx 捕获比较 4  寄存器值</td>
</tr>
<tr>
<td>TIM_SetIC1Prescaler</td>
<td>设置 TIMx 输入捕获 1  预分频</td>
</tr>
<tr>
<td>TIM_SetIC2Prescaler</td>
<td>设置 TIMx 输入捕获 2  预分频</td>
</tr>
<tr>
<td>TIM_SetIC3Prescaler</td>
<td>设置 TIMx 输入捕获 3  预分频</td>
</tr>
<tr>
<td>TIM_SetIC4Prescaler</td>
<td>设置 TIMx 输入捕获 4  预分频</td>
</tr>
<tr>
<td>TIM_SetClockDivision</td>
<td>设置 TIMx 的时钟分割值</td>
</tr>
<tr>
<td>TIM_GetCapture1</td>
<td>获得 TIMx 输入捕获 1  的值</td>
</tr>
<tr>
<td>TIM_GetCapture2</td>
<td>获得 TIMx 输入捕获 2  的值</td>
</tr>
<tr>
<td>TIM_GetCapture3</td>
<td>获得 TIMx 输入捕获 3  的值</td>
</tr>
<tr>
<td>TIM_GetCapture4</td>
<td>获得 TIMx 输入捕获 4  的值</td>
</tr>
<tr>
<td>TIM_GetCounter</td>
<td>获得 TIMx 计数器的值</td>
</tr>
<tr>
<td>TIM_GetPrescaler</td>
<td>获得 TIMx 预分频值</td>
</tr>
<tr>
<td>TIM_GetFlagStatus</td>
<td>检查指定的 TIM 标志位设置与否</td>
</tr>
<tr>
<td>TIM_ClearFlag</td>
<td>清除 TIMx 的待处理标志位</td>
</tr>
<tr>
<td>TIM_GetITStatus</td>
<td>检查指定的 TIM 中断发生与否</td>
</tr>
<tr>
<td>TIM_ClearITPendingBit</td>
<td>清除 TIMx 的中断待处理位</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32综述</title>
    <url>/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>　　大概有一段时间没看stm32，通过之前学51的经历，大概是明白自己一段时间不看就会忘，虽然随便翻翻又能快速上手，但是东找西翻比较麻烦。所以打算复习的时候，顺便做个笔记记录一下。自己所用的型号为<strong>STM32F103C8T6</strong>。<span id="more"></span></p>
<h6 id="STM简述"><a href="#STM简述" class="headerlink" title="STM简述"></a>STM简述</h6><p>　　STM32是ST公司基于ARM- Cortex-M内核开发的32位微控制器（MCU）。自己所用的是STM32F1系列，属于Mainstream，内核Cortex-M3。ARM公司设计ARM内核，半导体厂商完善内核周边电路并产生芯片。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104303863.png" class="" title="image-20230724104303863">

<p>图中的ARM由ARM公司设计，芯片内的存储和外设（比如GPIO,定时器）由ST公司设计。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104427576.png" class="" title="image-20230724104427576">

<p>这是一枚STM32F103C8T6的芯片，由芯片可以看出型号和封装。封装为LQFP48，芯片表面左下角有个圆点，圆点下的引脚为1顺着原点逆时针开始数。如果芯片有两个圆点，则从最小的圆点开始数。</p>
<h6 id="片上资源-x2F-外设"><a href="#片上资源-x2F-外设" class="headerlink" title="片上资源&#x2F;外设"></a><strong>片上资源&#x2F;外设</strong></h6><img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724104939703.png" class="" title="image-20230724104939703">

<p>绿色背景加黑的是位于内核的外设。另外C8T6并没有表中的DAC,SDIO,FSMC和USB OTG外设。</p>
<p>NVIC:内核里面用于管理中断的设备，例如配置中断优先级。</p>
<p>SysTick:用来给操作系统提供定时服务。应为STM32可以加入Freektos，ucos等操作系统，利用SysTick提供定时进行任务切换的功能。</p>
<p>RCC：复位和时钟控制，可以对系统的时钟进行配置，还能使能各模块的时钟。在STM32中，外设上电后是默认没有时钟。没有时钟，外设无法工作。</p>
<p>GPIO：通用的IO口，可以用于操控模块，比如灯，马达等。</p>
<p>AFIO：完成复用功能端口的重定义，还有中断端口的置配。</p>
<p>EXTI：配置好外部中断后，当引脚有电平变化时，就可以触发中断，让CPU来处理任务。</p>
<p>TIM定时器：分为基本定时器，通用定时器，高级定时器。不仅可以完成定时中断的任务，还可以用于测频率，生成PWM波形，配置为专用的编码器接口。</p>
<p>ADC：模数转换器，STM32内置了12位的AD转换器，可以直接读取IO口的模拟电压，无需外置。</p>
<p>DMA：直接内存访问，可以帮助CPU搬运大量数据等这种繁杂任务。</p>
<p>I2C&#x2F;SPI：两种常见的通信协议。</p>
<p>RTC：实时时钟，在STM32内部完成时，分，秒的计时功能，还可以外接电源，即使掉电也能</p>
<p>正常运行（此时会启用芯片备用电池）。</p>
<p>CRC：一种数据校验方式，用于判断接受的数据是否正确。</p>
<p>IWDG&#x2F;WWDG:当单片机因为电磁干扰死机或者程序设计不合理导致的死循环时，看门狗可以及时复位，保证系统稳定。</p>
<p>DAC：数模转换器，可以在IO口直接输出模拟电压。</p>
<p>OTG：使STM32作为USB主机去读取其它USB设备。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111613998.png" class="" title="image-20230724111613998">

<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111625157.png" class="" title="image-20230724111625157">



<h6 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a><strong>系统结构</strong></h6><img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230724111735194.png" class="" title="image-20230724111735194">

<p>ICode（指令总线）和Dcode（数据总线）用来连接Flash闪存，Flash存放的是我们编写的程序，ICode用于加载程序指令，Dcode用于加载数据，如常数和调试数据。</p>
<p>系统总线就连接到如SRAM（用于存储程序运行时的变量数据）</p>
<p>AHB系统总线：用于挂载主要的外设，AHB指先进高性能总线，挂载最基本的或者性能比较高的外设，如复位和时钟控制  SDIO。</p>
<p>APB：先进外设总线，用于连接一般的外设。</p>
<p>DMA：大量的数据搬运，防止覆盖。</p>
<h6 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h6><p>红色是电源相关的引脚</p>
<p>蓝色是最小系统相关的引脚</p>
<p>绿色是IO口&#x2F;功能口相关的引脚</p>
<p>S代表电源，I&#x2F;O代表输入输出，I&#x2F;O电平代表所能容忍的电压。FT代表能容忍5V，默认复用是IO口上同时连接的外设功能引脚。重定义：如果有2个功能同时复用在了1个IO口上，可以把其中一个复用功能重映射到其他端口上。</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230726084013246.png" class="" title="image-20230726084013246">



<p>1.　　　VBAT：备用电池供电引脚，当系统电源断电时，备用电池可以给内部的RTC时钟和备份寄存器提供电源。</p>
<p>2.　　　IO口&#x2F;侵入检测&#x2F;RTC：IO口可以根据程序输出读取高低电平</p>
<p>3.4　IO口&#x2F;接32.768kHZ的RTC晶振</p>
<p>5,6　接系统的主晶振，芯片内有锁相环电路，对8MHZ进行倍频形成72MHZ。</p>
<p>7　　系统复位引脚，N代表低电平复位</p>
<p>8,9　内部模拟部分的电源，如ADC,RC振荡器  VSS(-) VDD(+)</p>
<p>10-19　都是IO口，10号引脚还兼具了WKUP用于唤醒对于待机模式的STM32</p>
<p>20　IO口&#x2F;BOOT1引脚，BOOT用来配置启动模式    44.　BOOT0</p>
<p>21.22.25-33.41-43.45.46 都是IO口</p>
<p>23,24是系统的主电源口， 35.36.47.48    STM32采用分区供电模式</p>
<p>34,37-40　IO口&#x2F;调试端口      STM32支持SWD和JTAG两种调试方法</p>
<p>启动配置（BOOT0和BOOT1）</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230801140258741.png" class="" title="image-20230801140258741">

<p>作用：指定程序开始运行的位置，一般情况下，程序是在Flash程序存储器开始执行</p>
<p>接1指3.3V电源正的意思</p>
<p>系统存储器就是STM32中的一段BootLoader(接受串口数据，然后刷新到主闪存中)</p>
<p>核心板原理图</p>
<img src="/2023/07/24/STM32%E7%BB%BC%E8%BF%B0/image-20230801140602387.png" class="" title="image-20230801140602387">

]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32归档</title>
    <url>/2023/08/02/STM32%E5%BD%92%E6%A1%A3/</url>
    <content><![CDATA[<p>个人学习笔记，将对知识点进行概述，主要学习请参考B站江科大的视频。或者STM32手册。<span id="more"></span></p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="GPIO简介"><a href="#GPIO简介" class="headerlink" title="GPIO简介"></a>GPIO简介</h2><p>•GPIO（General Purpose Input Output）通用输入输出口</p>
<p>•可配置为8种输入输出模式</p>
<p>•引脚电平：0V~3.3V，部分引脚可容忍5V</p>
<p>•输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</p>
<p>•输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
<h3 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802090509772.png" class="" title="image-20230802090509772">

<p>所有GPIO都挂载在APB2总线上。PA0~PB15为GPIO外设引脚</p>
<p><strong>寄存器</strong>是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写</p>
<p>，以完成输出电平和读取电平的功能，但只有低16位才有对应端口。</p>
<p><strong>驱动器</strong>负责增大驱动能力。</p>
<h4 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092111160.png" class="" title="image-20230802092111160">

<h2 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092501391.png" class="" title="image-20230802092501391">

<p>推挽输出的高低电平均有较强的驱动能力。</p>
<h3 id="浮空-x2F-上拉-x2F-下拉输入"><a href="#浮空-x2F-上拉-x2F-下拉输入" class="headerlink" title="浮空&#x2F;上拉&#x2F;下拉输入"></a>浮空&#x2F;上拉&#x2F;下拉输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092609813.png" class="" title="image-20230802092609813">

<p>在输入模式下，出入驱动器断开。</p>
<h3 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802092744941.png" class="" title="image-20230802092744941">

<p>使用ADC的专用配置。输入和输出驱动器都断开无效，信号从引脚后，直接进入片上外设。</p>
<h3 id="开漏-x2F-推挽输出"><a href="#开漏-x2F-推挽输出" class="headerlink" title="开漏&#x2F;推挽输出"></a>开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093041456.png" class="" title="image-20230802093041456">

<p>一个端口可以有多个输入，但只能有一个输出。通过输出驱动器的MOS管，可以控制输出为推挽或开漏模式。</p>
<h3 id="复用开漏-x2F-推挽输出"><a href="#复用开漏-x2F-推挽输出" class="headerlink" title="复用开漏&#x2F;推挽输出"></a>复用开漏&#x2F;推挽输出</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093323996.png" class="" title="image-20230802093323996">

<p>输出控制由片上外设控制，输入时，片上外设和输入驱动器都有效。</p>
<h3 id="外设GPIO配置"><a href="#外设GPIO配置" class="headerlink" title="外设GPIO配置"></a>外设GPIO配置</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230802093547488.png" class="" title="image-20230802093547488">

<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><details>  <summary><font size="4" color="orange">流水灯</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                      // 延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启APB2时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //为结构体命名
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        //设为GPIO为推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;             //所有引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       //输出速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_Write(GPIOA, ~0x0001);	//0000 0000 0000 0001   //一次写入16个端口，控制GPIO
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0002);	//0000 0000 0000 0010
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0004);	//0000 0000 0000 0100
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0008);	//0000 0000 0000 1000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0010);	//0000 0000 0001 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0020);	//0000 0000 0010 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0040);	//0000 0000 0100 0000
        Delay_ms(100);
        GPIO_Write(GPIOA, ~0x0080);	//0000 0000 1000 0000
        Delay_ms(100);
    &#125;
&#125;
</code> </pre> </details>


<details> 
<summary><font size="4" color="orange">LED闪烁</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"                     //延时函数
int main(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    //开启时钟
    GPIO_InitTypeDef GPIO_InitStructure;                    //结构体，初始化GPIO
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       //推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;              //初始化的引脚为GPIOA的pin0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;      //运行速度
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    while (1)
    &#123;
        GPIO_ResetBits(GPIOA, GPIO_Pin_0);             //把pin0置为低电平
        Delay_ms(500);
        GPIO_SetBits(GPIOA, GPIO_Pin_0);               //把pin0置为高电平
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)0);
        Delay_ms(500);
        GPIO_WriteBit(GPIOA, GPIO_Pin_0, (BitAction)1);
        Delay_ms(500);
    &#125;
&#125;
</code>
</pre> </details>




<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断：　　　　　在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p>
<p>中断优先级：　　当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p>
<p>中断嵌套：　　　当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</p>
<p><strong>中断执行流程</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085322283.png" class="" title="image-20230803085322283">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230803085339575.png" class="" title="image-20230803085339575">

<p>程序由硬件电路自动跳转到中断程序中</p>
<h3 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a><strong>STM32中断</strong></h3><p>•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p>
<p>•使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级。  </p>
<p>内核中断：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804091214547.png" class="" title="image-20230804091214547">

<h3 id="NVIC的基本结构"><a href="#NVIC的基本结构" class="headerlink" title="NVIC的基本结构"></a>NVIC的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140450873.png" class="" title="image-20230804140450873">

<p>一个外设可能占用多个中断通道</p>
<h3 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h3><p>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p>
<p>•抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804140815853.png" class="" title="image-20230804140815853">

<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><h3 id="EXTI简介"><a href="#EXTI简介" class="headerlink" title="EXTI简介"></a>EXTI简介</h3><p>•EXTI（Extern Interrupt）外部中断</p>
<p>•EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p>
<p>•支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p>
<p>•支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断。（PA1和PB1不能同时用）</p>
<p>•通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
<p>•触发响应方式：中断响应&#x2F;事件响应</p>
<p>中断响应：让CPU执行中断函数</p>
<p>事件响应：当外部中断检测到引脚变化时，中断信号就不会通向CPU了，而是通到其它外设，用来触发其它外设的操作（ADC,DMA）属于外设之间的联合工作。</p>
<h3 id="EXTI的基本结构"><a href="#EXTI的基本结构" class="headerlink" title="EXTI的基本结构"></a>EXTI的基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804141911813.png" class="" title="image-20230804141911813">

<h3 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h3><p>•AFIO主要用于引脚复用功能的选择和重定义</p>
<p>•在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142052238.png" class="" title="image-20230804142052238">

<h3 id="EXTI框图"><a href="#EXTI框图" class="headerlink" title="EXTI框图"></a>EXTI框图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804142120741.png" class="" title="image-20230804142120741">

<h3 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h3><p><strong>配置过程：</strong></p>
<p>1.　　　　配置RCC,把涉及的外设时钟都打开GPIO,AFIO，（无需：NVIC,EXTI）<br>2.　　　　配置GPIO，选择端口为输入模式<br>3.　　　　配置AFIO，选择所需的GPIO链接EXTI。<br>4.　　　　配置EXTI，选择触发方式和响应方式。（一般为边沿触发，中断响应）<br>5.　　　　配置NVIC，选择合适的优先级。</p>
<p>最后，通过NVIC，外部中断信号进入CPU。</p>
<p><strong>对射式红外传感器计次</strong></p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804143658827.png" class="" title="image-20230804143658827">

<p>挡光片在对射式红外传感器中间经过时，D0输出电平跳变，触发PB14号IO口的中断。</p>
<details>  <summary><font size="4" color="orange">代码</font></summary>  <pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
uint16_t CountSensor_Count;
void CountSensor_Init(void)
&#123;
//开启相关时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
//利用结构体配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;                     
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
//选择中断线
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
//利用结构体配置EXTI
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line14;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
//利用结构体配置NVIC
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
&#125;
uint16_t CountSensor_Get(void)
&#123;
    return CountSensor_Count;
&#125;
void EXTI15_10_IRQHandler(void)       //中断函数，函数名不可自定义
&#123;
    if (EXTI_GetITStatus(EXTI_Line14) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
        &#123;
            CountSensor_Count ++;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line14);
    &#125;
&#125;
</code> </pre> </details>
**螺旋编码器计次**

<p>螺旋编码器可用于测量位置，速度或旋转方向，当其旋转轴旋转时，其输出端额可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度与方向。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160531114.png" class="" title="image-20230804160531114">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804160614690.png" class="" title="image-20230804160614690">

<p>默认无旋转时，此时上拉为高电平，并输出到A端口，当旋转时内部触电导通，此时因为连接GND，A端口就为低电平。</p>
<p>旋转轴旋转时，此时两触点以相位相差90度的方式交替导通。</p>
<p>示例连接图：</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230804161013946.png" class="" title="image-20230804161013946">

<details> 
<summary><font size="4" color="orange">主函数</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Encoder.h"
int16_t Num;
int main(void)
&#123;
    OLED_Init();                     //初始化OLED屏幕
    Encoder_Init();
    OLED_ShowString(1, 1, "Num:");   //OLED显示函数
    while (1)
    &#123;
        Num += Encoder_Get();
        OLED_ShowSignedNum(1, 5, Num, 5);
    &#125;
&#125;
</code>
</pre> </details>

<details> 
<summary><font size="4" color="orange">Encoder.c</font></summary> 
<pre><code class="language-cpp">
#include "stm32f10x.h"                  // Device header
int16_t Encoder_Count;
//初始化，配置相关IO口，中断。
void Encoder_Init(void)
&#123;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);
    GP_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);
    EXTI_InitTypeDef EXTI_InitStructure;
    EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_Init(&EXTI_InitStructure);
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    NVIC_Init(&NVIC_InitStructure);
&#125;
//放回count的变化值
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = Encoder_Count;
    Encoder_Count = 0;
    return Temp;
&#125;
//中断程序，执行计数
void EXTI0_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line0) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
            &#123;
                Encoder_Count --;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line0);
    &#125;
&#125;
void EXTI1_IRQHandler(void)
&#123;
    if (EXTI_GetITStatus(EXTI_Line1) == SET)
    &#123;
        /*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
        if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)
        &#123;
            if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == 0)
            &#123;
                Encoder_Count ++;
            &#125;
        &#125;
        EXTI_ClearITPendingBit(EXTI_Line1);
    &#125;
&#125;
</code>
</pre> </details>


<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h2><p>•TIM（Timer）定时器</p>
<p>•定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p>
<p>•16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p>
<p>•不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p>
<p>•根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
<p>应用：利用输出比较功能，可以产生PWM波形，驱动电机。输入捕获功能，可以实现测量方波频率。定时器的编码器接口，也可以更方便的读取正交编码器的输出波形。</p>
<h2 id="定时器类型"><a href="#定时器类型" class="headerlink" title="定时器类型"></a>定时器类型</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230805151849133.png" class="" title="image-20230805151849133">

<p>高级定时器可用于三相无刷电机。</p>
<p>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4。</p>
<h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813094959667.png" class="" title="image-20230813094959667">

<p>基本定时器一般是连接到内部时钟（72MHz），经过预分频器进行分频。比如：预分频器写0就是不分频或者（1分频），输出频率&#x3D;输入频率&#x3D;72M，写1就是二分频，输出&#x3D;输入&#x2F;2&#x3D;36M，以此类推。这个预分频器是16位，最大值可填65535，也就是65536分频。分频后计数器（16位）会不断自增，通过自动重装寄存器（16位）可以控制计数时间。当计数&#x3D;自动重装值，计数清零，输出中断。</p>
<p><strong>主从模式触发ADC</strong>  </p>
<p>能让内部的硬件在不受程序的控制下实现自动运行。</p>
<h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100353705.png" class="" title="image-20230813100353705">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100243577.png" class="" title="image-20230813100243577">

<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100827977.png" class="" title="image-20230813100827977">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813100920081.png" class="" title="image-20230813100920081">

<h2 id="定时器结构详解"><a href="#定时器结构详解" class="headerlink" title="定时器结构详解"></a>定时器结构详解</h2><h3 id="定时中断基本结构图"><a href="#定时中断基本结构图" class="headerlink" title="定时中断基本结构图"></a>定时中断基本结构图</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113020376.png" class="" title="image-20230813113020376">

<h3 id="预分频器时序"><a href="#预分频器时序" class="headerlink" title="预分频器时序"></a>预分频器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813113501182.png" class="" title="image-20230813113501182">

<p>•计数器计数频率：CK_CNT &#x3D; CK_PSC &#x2F; (PSC + 1)</p>
<h3 id="计数器时序"><a href="#计数器时序" class="headerlink" title="计数器时序"></a>计数器时序</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813121832130.png" class="" title="image-20230813121832130">

<p>•计数器溢出频率：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)&#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p>
<h4 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h4> <img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122009533.png" class="" title="image-20230813122009533">

<h4 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h4><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230813122038841.png" class="" title="image-20230813122038841">

<p>如果引入影子寄存器，当自动加载寄存器的值更改后，当前计数周期结束后，才会更改自动加载寄存器的值。实际上为了同步，让值的变化和事件的更新同步发生，防止运行途中由于更改所造成的错误。</p>
<p>比如：原本计时50秒，闹钟响起。计时到45秒时，改为计时到30秒响起闹钟。那么则是45-&gt;60-&gt;0-&gt;30，闹钟才会想起。引入影子寄存器后，则是45-&gt;50，响起闹钟，下一个周期：0-&gt;30再响起一次闹钟。</p>
<h3 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h3><p>STM32用来产生和配置时钟.并吧配置好的时钟发送到各个外设系统。SystemInit就是用来配置时钟树的。</p>
<img src="STM32%E5%BD%92%E6%A1%A3/image-20230813124428753.png" alt="image-20230813124428753" style="zoom:150%;" />

<p>左边是产生时钟电路，右边则是分配电路。两个高速时钟是为系统提供时钟的。一般外部晶振比内部稳定，所以一般使用外部晶振。</p>
<p>SystemInit配置时钟过程：先开启内部8Mhz晶振作为系统时钟，再开启外部时钟（一般为8M），经过倍频且稳定后变为72M，再代替原来内部的8M作为系统时钟。所以，如果外部时钟出了问题，则切换为内部时钟。8M和72M相比，大概慢了10倍。</p>
<h3 id="示例程序-2"><a href="#示例程序-2" class="headerlink" title="示例程序"></a>示例程序</h3><h4 id="配置过程（内部时钟为例）："><a href="#配置过程（内部时钟为例）：" class="headerlink" title="配置过程（内部时钟为例）："></a>配置过程（内部时钟为例）：</h4><p>1.　　RCC开启时钟，此时基准时钟和整个外设的工作时钟都被打开。</p>
<p>2.　　选择时基单元的时钟源（内部时钟模式）</p>
<p>3.　　配置时基单元<br>4.　　配置输出中断控制，允许更新中断输出到NVIC<br>5.　　配置NVIC，打开中断通道，并分配优先级</p>
<h4 id="定时器中断（内部时钟）："><a href="#定时器中断（内部时钟）：" class="headerlink" title="定时器中断（内部时钟）："></a>定时器中断（内部时钟）：</h4>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
uint16_t Num; 
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init(); 
//
    OLED_ShowString(1, 1, "Num:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5); // 在OLED屏幕上显示变量Num的值，位于第1行第5列，总宽度为5个字符
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32库的头文件
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 				// 启用TIM2的时钟
    TIM_InternalClockConfig(TIM2); 										// 配置TIM2的时钟源为内部时钟
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;                 //结构体
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; 		// 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 	// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; 					// ARR自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; 				// PSC预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; 				//重复计数器的值（只有高级定时器才有）
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 				// 初始化TIM2的时间基准单元
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 								// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 							// 启用TIM2的更新中断
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 					// 配置NVIC的优先级分组为组2
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;						// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 					// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 			// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 					// 配置子优先级为1
    NVIC_Init(&NVIC_InitStructure); 									// 初始化NVIC
    TIM_Cmd(TIM2, ENABLE); 												// 启用TIM2定时器
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);         // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
        void Timer_Init(void);
//
#endif
</code> </pre> </details>

<h4 id="定时器外部时钟"><a href="#定时器外部时钟" class="headerlink" title="定时器外部时钟"></a>定时器外部时钟</h4>

<p>使用对射式红外传感器来模拟外部时钟。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h" 
#include "OLED.h" 
#include "Timer.h" 
//
uint16_t Num; 
//
int main(void)
&#123;
    OLED_Init(); 
    Timer_Init();
    OLED_ShowString(1, 1, "Num:"); 
    OLED_ShowString(2, 1, "CNT:"); 
    while (1)
    &#123;
        OLED_ShowNum(1, 5, Num, 5);
        OLED_ShowNum(2, 5, Timer_GetCounter(), 5);
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Num++;                                      // 每次定时器2的更新中断触发时，增加Num的值
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除定时器2的更新中断标志位，准备下一次触发
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//
void Timer_Init(void)
&#123;
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);       // 启用TIM2的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);     // 启用GPIOA的时钟
//
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;			 // 配置GPIOA的引脚模式为上拉输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; 				// 配置GPIOA的引脚为引脚0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 		// 配置GPIOA的引脚速度为50MHz
    GPIO_Init(GPIOA, &GPIO_InitStructure); 					// 初始化GPIOA
// 配置TIM2的外部时钟源模式
    TIM_ETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_ExtTRGPolarity_NonInverted, 0x0F); 
//结构体配置
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;				 // 不分频
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 		// 向上计数模式
    TIM_TimeBaseInitStructure.TIM_Period = 10-1; 		// 自动重装载寄存器的值，决定了计数器溢出的时间间隔
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1-1; 		// 预分频器的值，决定了计数器的时钟频率
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure); 	// 初始化TIM2的时间基准单元
//
    TIM_ClearFlag(TIM2, TIM_FLAG_Update); 		// 清除TIM2的更新标志位
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); 	// 启用TIM2的更新中断
//
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 配置NVIC的优先级分组为组2
//
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 				// 配置中断通道为TIM2
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 				// 启用中断通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; 		// 配置抢占优先级为2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 				// 配置响应优先级为1
    NVIC_Init(&NVIC_InitStructure); 								// 初始化NVIC
//
    TIM_Cmd(TIM2, ENABLE);											 // 使能TIM2定时器
&#125;
//
uint16_t Timer_GetCounter(void)
&#123;
    return TIM_GetCounter(TIM2); // 获取TIM2计数器的当前值
&#125;
/*
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        // 在这里添加处理TIM2更新中断的代码
        // 可以在此处执行你的特定任务或操作
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 清除TIM2的更新中断标志位
    &#125;
&#125;
*/
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Timer.h</font></summary>  <pre><code class="language-c">
#ifndef __TIMER_H
#define __TIMER_H
//
void Timer_Init(void);
uint16_t Timer_GetCounter(void);
//
#endif
</code> </pre> </details>


<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h2><p>•　PWM（Pulse Width Modulation）脉冲宽度调制</p>
<p>•　在具有<strong>惯性</strong>的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</p>
<p>•　PWM参数：</p>
<p>   频率 &#x3D; 1 &#x2F; TS      占空比 &#x3D; TON &#x2F; TS      分辨率 &#x3D; 占空比变化步距</p>
<p>简单说，Ts代表一个高低电平变换周期的时间，占空比决定PWM等效出来的模拟电压的大小，分辨率则可以理解为变化的精细，比如：1% → 2%，分辨率为1%。1.1% → 1.2%，分辨率为0.1%</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906144618584.png" class="" title="image-20230906144618584"><img src="STM32%E5%BD%92%E6%A1%A3/image-20230906144635542.png" alt="image-20230906144635542" style="zoom:80%;" />



<p>PWM需要用到输出比较，所以先介绍一下stm32的输出比较功能。</p>
<h2 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h2><p>•　OC（Output Compare）输出比较</p>
<p>•　IC（Input Capture） 输入捕获</p>
<p>•　CC（Capture&#x2F;Compare）输出比较和输入捕获</p>
<p>•　输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<p>•　每个高级定时器和通用定时器都拥有4个输出比较通道</p>
<p>•　高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p>
<h3 id="输出比较通道-高级"><a href="#输出比较通道-高级" class="headerlink" title="输出比较通道(高级)"></a>输出比较通道(高级)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906150101596.png" class="" title="image-20230906150101596">

<h3 id="输出比较通道-通用"><a href="#输出比较通道-通用" class="headerlink" title="输出比较通道(通用)"></a>输出比较通道(通用)</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906161718832.png" class="" title="image-20230906161718832">

<p>比较CNT（计数器）和CCR（捕获比较寄存器）的值，会改变oc1ref（ref：参考信号）的输出电平。（信号可映射至主模式控制器。）输出经过极性选择（是否翻转电平，0为不翻转），最后输出。</p>
<h2 id="输出比较模式"><a href="#输出比较模式" class="headerlink" title="输出比较模式"></a>输出比较模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906162701392.png" class="" title="image-20230906162701392">



<h2 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230906163019452.png" class="" title="image-20230906163019452">

<p>参数计算：</p>
<p>•　PWM频率：　　Freq &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)　　　</p>
<p>•　PWM占空比：　Duty &#x3D; CCR &#x2F; (ARR + 1)</p>
<p>•　PWM分辨率：　Reso &#x3D; 1 &#x2F; (ARR + 1)</p>
<h2 id="示例程序-3"><a href="#示例程序-3" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="配置PWM初始化程序的一般步骤"><a href="#配置PWM初始化程序的一般步骤" class="headerlink" title="配置PWM初始化程序的一般步骤"></a>配置PWM初始化程序的一般步骤</h3><p>1.　开启TIM外设和GPIO外设的时钟。<br>2.　配置时基单元。<br>3.　配置输出比较单元。CCR的值，输出比较模式，极性选择，输出使能<br>4.　配置GPIO，PWM对应的GPIO，配置为复用推挽输出<br>5.　运行控制</p>
<h3 id="PWM驱动LED呼吸灯"><a href="#PWM驱动LED呼吸灯" class="headerlink" title="PWM驱动LED呼吸灯"></a>PWM驱动LED呼吸灯</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"     
#include "OLED.h"      
#include "PWM.h"       
//
uint8_t i; 
//
int main(void)
&#123;
    OLED_Init(); 
    PWM_Init();  
//
    while (1)
    &#123;
        // 增加PWM占空比从0到100，使亮度逐渐增大
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(i); // 设置PWM通道1的占空比
            Delay_ms(10);       
        &#125;
        // 降低PWM占空比从100到0，使亮度逐渐减少
        for (i = 0; i <= 100; i++)
        &#123;
            PWM_SetCompare1(100 - i); // 设置PWM通道1的占空比
            Delay_ms(10);             
        &#125;
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
void PWM_Init(void)
&#123;
// 启用TIM2时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置TIM2通道1的GPIO引脚
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;     // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM2为内部时钟
    TIM_InternalClockConfig(TIM2);
// 配置TIM2的时基
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 100 - 1;  // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 720 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
// 配置TIM2通道1为PWM输出
    TIM_OCInitTypeDef TIM_OCInitStructure;
    TIM_OCStructInit(&TIM_OCInitStructure);
    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCInitStructure.TIM_Pulse = 0; // CCR
    TIM_OC1Init(TIM2, &TIM_OCInitStructure);
// 启用TIM2
    TIM_Cmd(TIM2, ENABLE);
&#125;
void PWM_SetCompare1(uint16_t Compare)
&#123;
    // 设置TIM2通道1的比较值
    TIM_SetCompare1(TIM2, Compare);
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">PWM.h</font></summary>  <pre><code class="language-c">
#ifndef __PWM_H
#define __PWM_H
//
void PWM_Init(void);
void PWM_SetCompare1(uint16_t Compare);
//
#endif
</code> </pre> </details>

<h3 id="PWM驱动舵机"><a href="#PWM驱动舵机" class="headerlink" title="PWM驱动舵机"></a>PWM驱动舵机</h3>

<p>•　舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p>
<p>•　输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms　　　　　　<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907132353584.png" class="" title="image-20230907132353584"></p>
<p>　　　</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
#include "Delay.h"  //延时
#include "OLED.h"   
#include "Servo.h"
#include "Key.h"    //按键
// 全局变量声明
uint8_t KeyNum;
float Angle;
int main(void)
&#123;
    // 初始化OLED显示屏、舵机和按键
    OLED_Init();
    Servo_Init();
    Key_Init();
    OLED_ShowString(1, 1, "Angle:");
    while (1)
    &#123;
        // 获取按键状态
        KeyNum = Key_GetNum();
        // 如果按键被按下
        if (KeyNum == 1)
        &#123;
            Angle += 30;     // 增加角度值
            if (Angle > 180)
            &#123;
                Angle = 0;   // 限制在0到180度之间
            &#125;
        &#125;
        // 设置舵机的角度
        Servo_SetAngle(Angle);
        // 在OLED上显示当前角度
        OLED_ShowNum(1, 7, Angle, 3);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Servo.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
//初始化，和示例一的PWM初始化一致
void Servo_Init(void)
&#123;
    PWM_Init();
&#125;
//设置PWM脉冲宽度，并且与角度用公式转换，便于写入和理解
void Servo_SetAngle(float Angle)
&#123;
    PWM_SetCompare2(Angle / 180 * 2000 + 500);
&#125;
</code> </pre> </details>

<h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><h2 id="输入捕获简介"><a href="#输入捕获简介" class="headerlink" title="输入捕获简介"></a>输入捕获简介</h2><p>•　IC（Input Capture）输入捕获</p>
<p>•　输入捕获模式下，当通道输入引脚出现指定电平跳变时，<strong>当前CNT的值将被锁存到CCR中</strong>，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p>
<p>•　每个高级定时器和通用定时器都拥有4个输入捕获通道</p>
<p>•　可配置为PWMI模式，同时测量频率和占空比</p>
<p>•　<strong>可配合主从触发模式，实现硬件全自动测量</strong></p>
<h2 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135103458.png" class="" title="image-20230907135103458">

<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135147731.png" class="" title="image-20230907135147731">

<h2 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907135338333.png" class="" title="image-20230907135338333">

<p>滤波器控制滤波参数，边沿检测器可以捕获信号的上升沿，如果将信号映射至从模式控制器，则可以再捕获之后自动完成CNT的清零工作。</p>
<h2 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907140812970.png" class="" title="image-20230907140812970">

<p>将定时器的内部信号，映射到TRGO引脚，用于触发其它的外设。选择从模式的触发信号源后，可选择从模式控制自身定时器运行。</p>
<h2 id="输入捕获基本结构"><a href="#输入捕获基本结构" class="headerlink" title="输入捕获基本结构"></a>输入捕获基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907143237498.png" class="" title="image-20230907143237498">

<p>只用了一个通道，所以只能测频率</p>
<h2 id="PWMI基本结构"><a href="#PWMI基本结构" class="headerlink" title="PWMI基本结构"></a>PWMI基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230907162801097.png" class="" title="image-20230907162801097">

<p>使用2个通道同时捕获一个引脚，CRR1为一整个周期的计数值，CRR2是高电气期间的计数值。则占空比&#x3D;CCR2&#x2F;CCR1</p>
<h2 id="示例程序-4"><a href="#示例程序-4" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般配置步骤"><a href="#一般配置步骤" class="headerlink" title="一般配置步骤"></a>一般配置步骤</h3><p>1.使用RCC开启TIM和GPIO的时钟。</p>
<p>2.初始化GPIO，配置为输入模式，一般为上拉&#x2F;浮空输入</p>
<p>3.配置时基单元，使CNT计数器在内部时钟的驱动下自增运行</p>
<p>4.配置输入捕获单元（包括滤波器，极性选择，直连通道）</p>
<p>5.选择从模式的触发源，选择TI1FP1。</p>
<p>6.选择从模式的触发动作（Reset，自动清零CNT）</p>
<p>7.调用TIM_cmd()启动定时器计数。</p>
<h3 id="输入捕获模式测频率"><a href="#输入捕获模式测频率" class="headerlink" title="输入捕获模式测频率"></a>输入捕获模式测频率</h3>



<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 自定义头文件，相关程序参考文章前置相关
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
//
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
    OLED_ShowString(1, 1, "Freq:00000Hz");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5);
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO，为上拉输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>

<h3 id="PWMI模式测频率占空比"><a href="#PWMI模式测频率占空比" class="headerlink" title="PWMI模式测频率占空比"></a>PWMI模式测频率占空比</h3>

<p>使用STM32自身IO口，PA0输出信号，PA6接收并检测频率和占空比。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" 
//自定义头文件
#include "Delay.h"
#include "OLED.h"
#include "PWM.h"
#include "IC.h"
int main(void)
&#123;
// 初始化
    OLED_Init();
    PWM_Init();
    IC_Init();
// OLED显示信息
    OLED_ShowString(1, 1, "Freq:00000Hz");
    OLED_ShowString(2, 1, "Duty:00%");
// 设置PWM的预分频器和占空比
    PWM_SetPrescaler(720 - 1); // Freq = 72M / (PSC + 1) / 100
    PWM_SetCompare1(50);       // Duty = CCR / 100
    while (1)
    &#123;
// 获取输入捕获模块测得的频率和占空比，并在OLED上显示
        OLED_ShowNum(1, 6, IC_GetFreq(), 5); // 显示频率
        OLED_ShowNum(2, 6, IC_GetDuty(), 2); // 显示占空比
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">IC.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h" // 包含STM32标准库头文件
// 初始化输入捕获模块
void IC_Init(void)
&#123;
// 启用TIM3时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
// 启用GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置GPIO为上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; // 配置的GPIO引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3为内部时钟
    TIM_InternalClockConfig(TIM3);
// 配置TIM3的时基单元
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1; // ARR
    TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; // PSC
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3通道1的输入捕获参数
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
    TIM_PWMIConfig(TIM3, &TIM_ICInitStructure); //该函数只需传入一个参数，会自动把剩下的通道初始化为相反的配置，仅适用于通道1和通道2
// 配置TIM3触发源和从模式
    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
// 启用TIM3计数器
    TIM_Cmd(TIM3, ENABLE);
&#125;
// 获取输入捕获模块测得的频率
uint32_t IC_GetFreq(void)
&#123;
    return 1000000 / (TIM_GetCapture1(TIM3) + 1);
&#125;
// 获取输入捕获模块测得的占空比
uint32_t IC_GetDuty(void)
&#123;
    return (TIM_GetCapture2(TIM3) + 1) * 100 / (TIM_GetCapture1(TIM3) + 1);
&#125;
</code> </pre> </details>


<h2 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h2><h3 id="编码器接口简介"><a href="#编码器接口简介" class="headerlink" title="编码器接口简介"></a>编码器接口简介</h3><p>•Encoder Interface 编码器接口</p>
<p>•编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>•每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>•两个输入引脚借用了输入捕获的通道1和通道2（CH1和CH2引脚）</p>
<h3 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h3><p>正交编码器可以输出两个相位相差90°的方波信号。接入stm32，可看成一个带有方向控制的外部时钟。</p>
<img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908100020216.png" class="" title="image-20230908100020216">

<p>使用正交信号精度更高，相当于AB相都参与计次，提高计次频率的同时，也可以抗干扰。</p>
<h3 id="编码器接口基本结构"><a href="#编码器接口基本结构" class="headerlink" title="编码器接口基本结构"></a>编码器接口基本结构</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105311721.png" class="" title="image-20230908105311721">

<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105519483.png" class="" title="image-20230908105519483">

<h3 id="实例（均不反相）"><a href="#实例（均不反相）" class="headerlink" title="实例（均不反相）"></a>实例（均不反相）</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908105542093.png" class="" title="image-20230908105542093">

<h3 id="实例（TI1反相）"><a href="#实例（TI1反相）" class="headerlink" title="实例（TI1反相）"></a>实例（TI1反相）</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230908211901582.png" class="" title="image-20230908211901582">

<p>如果接入编码器后，需要调整数据加减的方向，可直接调用极性选择。</p>
<h3 id="示例程序-5"><a href="#示例程序-5" class="headerlink" title="示例程序"></a>示例程序</h3><h4 id="编码器测速"><a href="#编码器测速" class="headerlink" title="编码器测速"></a>编码器测速</h4>

<p>选择上拉输入或下拉输入时，应参考外部模块的默认输出电平，保持一致。防止电平冲突。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"       
#include "Delay.h"             
#include "OLED.h"              
#include "Timer.h"             
#include "Encoder.h"           
//
int16_t Speed;                  
//
int main(void)
&#123;
//初始化
    OLED_Init();               
    Timer_Init();              
    Encoder_Init();            
    OLED_ShowString(1, 1, "Speed:");
    while (1)
    &#123;
        Speed = Encoder_Get();  						 	// 获取编码器的值并存储在Speed变量中
        OLED_ShowSignedNum(1, 7, Speed, 5);   // 在OLED上显示Speed的值
    &#125;
&#125;
//
void TIM2_IRQHandler(void)
&#123;
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    &#123;
        Speed = Encoder_Get();                            // 获取编码器的值并存储在Speed变量中
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);       // 清除定时器2更新中断标志位
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">Encoder.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  // 包含STM32标准库的头文件
void Encoder_Init(void)
&#123;
//开启时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
// 配置GPIO引脚模式、速度、和上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置TIM3定时器为编码器模式
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;
    TIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
// 配置TIM3的输入捕获通道1和通道2
    TIM_ICInitTypeDef TIM_ICInitStructure;
    TIM_ICStructInit(&TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
    TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
    TIM_ICInitStructure.TIM_ICFilter = 0xF;
    TIM_ICInit(TIM3, &TIM_ICInitStructure);
// 配置编码器接口
    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
// 启动TIM3定时器
    TIM_Cmd(TIM3, ENABLE);  
&#125;
//
int16_t Encoder_Get(void)
&#123;
    int16_t Temp;
    Temp = TIM_GetCounter(TIM3);  // 获取TIM3计数器的值
    TIM_SetCounter(TIM3, 0);     // 清零TIM3计数器的值
    return Temp;                  // 返回获取到的值
&#125;
</code> </pre> </details>


<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>•　ADC（Analog-Digital Converter）模拟 - 数字转换器</p>
<p>　DAC则是数字 - 模拟转换器，一般可用PWM平替DAC输出电机所需电压。DAC则可用于波形生成。</p>
<p>•　ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>•　12位逐次逼近型ADC，1us转换时间</p>
<p>•　输入电压范围：0～3.3V，转换结果范围：0～4095</p>
<p>•　18个输入通道，可测量16个外部和2个内部信号源</p>
<p>•　规则组（常规使用）和注入组（突发事件）两个转换单元</p>
<p>•　模拟看门狗自动监测输入电压范围</p>
<p>•　STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<h2 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909134000653.png" class="" title="image-20230909134000653">

<p>首先在通道选择开关选择一路输入（利用地址锁存和译码选择），再通过比较器进行比较，根据比较结果，改变DAC的值，直到和输入电压近似相等，则DAC的值为相应的数字变量。REF为参考电压。比较时通常用二分法，逐次逼近。</p>
<h2 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141006160.png" class="" title="image-20230909141006160">

<h2 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909140814309.png" class="" title="image-20230909140814309">

<p>触发控制可选择软件触发或者硬件触发。</p>
<h2 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141225078.png" class="" title="image-20230909141225078">

<h2 id="规则组的四种转换模式"><a href="#规则组的四种转换模式" class="headerlink" title="规则组的四种转换模式"></a>规则组的四种转换模式</h2><h3 id="单次转换，非扫描模式"><a href="#单次转换，非扫描模式" class="headerlink" title="单次转换，非扫描模式"></a>单次转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909141515783.png" class="" title="image-20230909141515783">

<p>将需要转换的通道2写入序列1，触发转换即可，完成后将数据放入寄存器，同时将EOC（标志位）置1。下次转换将再次实行以上步骤。</p>
<h3 id="连续转换，非扫描模式"><a href="#连续转换，非扫描模式" class="headerlink" title="连续转换，非扫描模式"></a>连续转换，非扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145103684.png" class="" title="image-20230909145103684">

<p>与单次转换不同，转换结束后将立即开始下一轮转换。即，触发一次，转换会一直进行下去。</p>
<h3 id="单次转换，扫描模式"><a href="#单次转换，扫描模式" class="headerlink" title="单次转换，扫描模式"></a>单次转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145559280.png" class="" title="image-20230909145559280">

<p>相较于单次转换，非扫描模式，可填入多个通道进行转换。</p>
<h3 id="连续转换，扫描模式"><a href="#连续转换，扫描模式" class="headerlink" title="连续转换，扫描模式"></a>连续转换，扫描模式</h3><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145836537.png" class="" title="image-20230909145836537">

<h2 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909145914699.png" class="" title="image-20230909145914699">

<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150013914.png" class="" title="image-20230909150013914">

<p>一般使用右对齐，可直接得出结果。也可以使用左对齐，然后裁剪数据分辨率。</p>
<h2 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h2><p>•　AD转换的步骤：采样，保持，量化，编码</p>
<p>•　STM32 ADC的总转换时间为：</p>
<p>　 TCONV &#x3D; 采样时间 + 12.5个ADC周期</p>
<p>•　例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期</p>
<p>　 TCONV &#x3D; 1.5 + 12.5 &#x3D; 14个ADC周期 &#x3D; 1μs</p>
<h2 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h2><p>•　ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p>
<p>•　建议在每次上电后执行一次校准</p>
<p>•　启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p>
<h2 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h2><img src="/2023/08/02/STM32%E5%BD%92%E6%A1%A3/image-20230909150438360.png" class="" title="image-20230909150438360">

<h2 id="示例程序-6"><a href="#示例程序-6" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><p>１．开启RCC时钟，ADC,GPIO。</p>
<p>２．配置GPIO为模拟输入。</p>
<p>３．配置多路开关，将所要转换的通道接入规则组。</p>
<p>４．配置ADC转换器</p>
<p>５．调用ADC_cmd()函数使能ADC。</p>
<h3 id="AD单通道"><a href="#AD单通道" class="headerlink" title="AD单通道"></a>AD单通道</h3>

<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"         
//
uint16_t ADValue;       // 存储AD转换后的数值
float Voltage;          // 存储计算后的电压值
//
int main(void)
&#123;
// 初始化
    OLED_Init();         
    AD_Init();         
    OLED_ShowString(1, 1, "ADValue:");    
    OLED_ShowString(2, 1, "Volatge:0.00V"); 
    while (1)
    &#123;
        ADValue = AD_GetValue();    // 获取AD转换后的数值
        Voltage = (float)ADValue / 4095 * 3.3; // 计算电压值
        // 在OLED上显示AD值和电压值（带小数点）
        OLED_ShowNum(1, 9, ADValue, 4);
        OLED_ShowNum(2, 9, Voltage, 1);
        // 在OLED上显示电压值的小数部分（两位小数）
        OLED_ShowNum(2, 11, (uint16_t)(Voltage * 100) % 100, 2);
        Delay_ms(100);  // 延时100毫秒
        &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  // 配置引脚为模拟输入模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;      
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
//利用结构体配置ADC
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                   // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;      // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                      // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                						 // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                      						 // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  // 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); // 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  // 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  // 等待校准完成
&#125;
//转换函数
uint16_t AD_GetValue(void)
&#123;
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);                    // 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);    // 等待转换完成
    return ADC_GetConversionValue(ADC1);                       // 获取ADC转换结果
&#125;
</code> </pre> </details>

<h3 id="AD多通道"><a href="#AD多通道" class="headerlink" title="AD多通道"></a>AD多通道</h3>

<p>采用扫描模式实现多通道，最好配合DMA防止数据覆盖。</p>
<p>本次利用单次转换非扫描模式，只需在每次触发转换之前，手动更改一下列表第一个位置通道即可。</p>
<details>  <summary><font size="4" color="orange">main.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"  
#include "Delay.h"      
#include "OLED.h"       
#include "AD.h"        
// 存储四个ADC通道的转换值
uint16_t AD0, AD1, AD2, AD3; 
int main(void)
&#123;
// 初始化
    OLED_Init();   
    AD_Init();     
    OLED_ShowString(1, 1, "AD0:"); 
    OLED_ShowString(2, 1, "AD1:"); 
    OLED_ShowString(3, 1, "AD2:"); 
    OLED_ShowString(4, 1, "AD3:"); 
    while (1)
    &#123;
        // 获取ADC通道的转换值
        AD0 = AD_GetValue(ADC_Channel_0); 
        AD1 = AD_GetValue(ADC_Channel_1); 
        AD2 = AD_GetValue(ADC_Channel_2); 
        AD3 = AD_GetValue(ADC_Channel_3); 
     // 在OLED上显示
        OLED_ShowNum(1, 5, AD0, 4);
        OLED_ShowNum(2, 5, AD1, 4);
        OLED_ShowNum(3, 5, AD2, 4);
        OLED_ShowNum(4, 5, AD3, 4);
     // 延时100毫秒
        Delay_ms(100); 
    &#125;
&#125;
</code> </pre> </details>

<details>  <summary><font size="4" color="orange">AD.c</font></summary>  <pre><code class="language-c">
#include "stm32f10x.h"
void AD_Init(void)
&#123;
// 使能ADC1和GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
// 配置ADC时钟分频
    RCC_ADCCLKConfig(RCC_PCLK2_Div6);
// 配置GPIO引脚为模拟输入模式
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
// 配置ADC的通道、采样时间等参数
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                       // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;                  // 数据右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;    // 不使用外部触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;                    // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;                         // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1;                               // 转换通道数为1
    ADC_Init(ADC1, &ADC_InitStructure);
// 启用ADC1
    ADC_Cmd(ADC1, ENABLE);  
//校准
    ADC_ResetCalibration(ADC1);  													// 复位校准寄存器
    while (ADC_GetResetCalibrationStatus(ADC1) == SET); 	// 等待校准寄存器复位完成
    ADC_StartCalibration(ADC1);  													// 启动ADC1校准
    while (ADC_GetCalibrationStatus(ADC1) == SET);  			// 等待校准完成
&#125;
//
uint16_t AD_GetValue(uint8_t ADC_Channel)
&#123;
    ADC_RegularChannelConfig(ADC1, ADC_Channel, 1, ADC_SampleTime_55Cycles5);	// 配置ADC
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);  									// 启动ADC转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); 					// 等待转换完成
    return ADC_GetConversionValue(ADC1);  										// 获取ADC转换结果
&#125;
</code> </pre> </details>
]]></content>
      <categories>
        <category>stm32归档</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>分支结构</title>
    <url>/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h5 id="小学数学-N-合一"><a href="#小学数学-N-合一" class="headerlink" title="小学数学 N 合一"></a>小学数学 N 合一</h5><p><strong>题目描述</strong><span id="more"></span></p>
<p><strong>问题 1</strong></p>
<p>请输出 <code>I love Luogu!&lt;!-- more --&gt;</code></p>
<p><strong>问题 2</strong></p>
<p>这里有 10 个苹果，小 A 拿走了 2 个，Uim 拿走了 4 个，八尾勇拿走剩下的所有的苹果。我们想知道：</p>
<ol>
<li>小A 和 Uim 两个人一共拿走多少苹果？</li>
<li>八尾勇能拿走多少苹果？</li>
</ol>
<p>现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。</p>
<p><strong>问题 3</strong></p>
<p>现在有 14 个苹果。要均分给 4 名同学，分不掉的苹果放回冰箱。请问：</p>
<ol>
<li><p>每位同学能分得几个苹果？</p>
</li>
<li><p>一共分出去多少苹果？</p>
</li>
<li><p>把几个苹果放回冰箱？</p>
<p>  现在需要编写一个程序，输出三个数字作为答案，每个数字一行。</p>
</li>
</ol>
<p><strong>问题 4</strong></p>
<p>现在有 500 毫升的肥宅快乐水，要均分给 3 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留 6 位有效数字，且不使用科学计数法。</p>
<p><strong>问题 5</strong></p>
<p>甲列火车长 260 米，每秒行 12 米；乙列火车长 220 米，每秒行 20 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。</p>
<p><strong>问题 6</strong></p>
<p>一个长方形长宽分别是 6cm、9cm，求它的对角线长度(cm)。直接使用 <code>cout</code> 输出。</p>
<p><strong>问题 7</strong></p>
<p>Uim 银行账户里面有 100 元。经过了下面的操作：</p>
<ol>
<li><p>往里面存了 10 元；</p>
</li>
<li><p>购物花掉了 20 元；</p>
</li>
<li><p>把里面的钱全部取出。</p>
<p>  请在每次操作后输出账户余额，并使用换行符隔开。</p>
</li>
</ol>
<p><strong>问题 8</strong></p>
<p>当半径为 r&#x3D;5，请输出圆的周长、面积和球体积。取 \pi&#x3D;3.141593。请直接使用 <code>cout</code> 输出答案，每行一个数字。</p>
<p><strong>问题 9</strong></p>
<p>一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？</p>
<p><strong>问题 10</strong></p>
<p>洛谷的评测任务是单位时间内均匀增加的。8 台评测机 30 分钟可以刚好把评测队列中的程序评测完毕，10 台评测机 6 分钟可以刚好把评测队列中的程序评测完毕，请问几台评测机可以在 10 分钟时刚好把评测队列中的程序评测完毕？</p>
<p><strong>问题 11</strong></p>
<p>小 A 跑步速度 5  m&#x2F;s，八尾勇跑步速度 8  m&#x2F;s，八尾勇在小 A 后面 100  m，他们同时起跑，请问需要多长时间八尾勇可以追上小 A？输出一个数字表示答案，使用 <code>cout</code> 直接输出。</p>
<p><strong>问题 12</strong></p>
<p>大家都知道有 26 个英文字母，其中 A 是第一个字母。现在请编程求出：</p>
<ol>
<li>M 是字母表中的第几个字母？</li>
<li>第 18 个字母是什么？</li>
</ol>
<p>输出一个数字和一个字母，使用换行隔开。</p>
<p><strong>问题 13</strong></p>
<p>小 A 有两块球形橡皮泥，一个半径是 4，一个半径是 10。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少？如果结果不是整数，则舍去小数点之后的数字。取π&#x3D; 3.141593。</p>
<p><strong>问题 14</strong></p>
<p>根据咕咕网校的预测，当课程定价为 110 元时，会有 10 人报名。如果课程价格每降低 1 元，就会多 1 名报名者（反之亦然）。如果希望总共能收到 3500 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较小的那一个。如果这个答案不是整数，则需四舍五入精确到整数。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数，表示第几个问题。</p>
<p><strong>输出格式</strong></p>
<p>根据所输入的问题编号，输出对应问题的答案。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230712194658604.png" class="" title="image-20230712194658604">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">float</span> b,c,d,e;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;I love Luogu!&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;6 4&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;3\n12\n2&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;%.31f&quot;</span>,<span class="number">500</span>/<span class="number">3</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;15&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">6</span>: b=<span class="built_in">sqrt</span>(<span class="number">6</span>*<span class="number">6</span>+<span class="number">9</span>*<span class="number">9</span>); <span class="built_in">printf</span>(<span class="string">&quot;%0.4f&quot;</span>,b); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">&quot;110\n90\n0&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">8</span>: b=<span class="number">2</span>*<span class="number">3.141593</span>*<span class="number">5</span>; c=<span class="number">3.141593</span>*<span class="number">5</span>*<span class="number">5</span>;d=<span class="number">4</span>/<span class="number">3</span>*<span class="number">3.141593</span>*<span class="number">5</span>*<span class="number">5</span>*<span class="number">5</span>;<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n%.4f\n%.3f&quot;</span>,b,c,d); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;22&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">10</span>: <span class="built_in">printf</span>(<span class="string">&quot;9&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">11</span>: b=<span class="number">100</span>/<span class="number">3</span>; <span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>,b); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">12</span>: <span class="built_in">printf</span>(<span class="string">&quot;13\nR&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">13</span>: <span class="built_in">printf</span>(<span class="string">&quot;16&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">14</span>: <span class="built_in">printf</span>(<span class="string">&quot;50&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="苹果和虫子"><a href="#苹果和虫子" class="headerlink" title="苹果和虫子"></a>苹果和虫子</h5><p>八尾勇喜欢吃苹果。她现在有 <em>m</em>（1≤<em>m</em>≤100）个苹果，吃完一个苹果需要花费 <em>t</em>（0≤<em>t</em>≤100）分钟，吃完一个后立刻开始吃下一个。现在时间过去了 <em>s</em>（1≤<em>s</em>≤10000）分钟，请问她还有几个完整的苹果？</p>
<p><strong>输入格式</strong></p>
<p>输入三个<strong>非负整数</strong>表示 ,<em>m</em>,<em>t</em>,<em>s</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数表示答案。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714145620724.png" class="" title="image-20230714145620724">

<p>这不简单？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m,s,t,x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;m,&amp;t,&amp;s);</span><br><span class="line">	x=m-s/t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714150328891.png" class="" title="image-20230714150328891">

<p>考虑到除t&#x3D;0，和苹果完整性问题，修改后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> m, s, t, x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;m, &amp;t, &amp;s);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= t) </span><br><span class="line">	&#123;</span><br><span class="line">		x = m - s / t;  <span class="comment">//常规计算</span></span><br><span class="line">    	<span class="keyword">if</span>(s%t) x--;  <span class="comment">//考虑是否刚好吃完的情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = m<span class="number">-1</span>;  <span class="comment">//开始吃苹果，即使没吃完，完整的苹果也少一个。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) x=<span class="number">0</span>;  <span class="comment">//t=0的情况</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出特例代入计算，没有bug，不过仍未通过检测。</p>
<h5 id="数的性质"><a href="#数的性质" class="headerlink" title="数的性质"></a>数的性质</h5><p>一些整数可能拥有以下的性质：</p>
<ul>
<li>性质 1：是偶数；</li>
<li>性质 2：大于 44 且不大于 1212。</li>
</ul>
<p>小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；八尾勇喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 <em>x</em>，请问他们是否喜欢这个整数？</p>
<p><strong>输入格式</strong></p>
<p>输入一个整数 (0≤1000)<em>x</em>(0≤<em>x</em>≤1000)</p>
<p><strong>输出格式</strong></p>
<p>输出这 44 个人是否喜欢这个数字，如果喜欢则输出 <code>1</code>，否则输出 <code>0</code>，用空格分隔。输出顺序为：小 A、Uim、八尾勇、正妹。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714152230449.png" class="" title="image-20230714152230449">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b,c,d,input,x,y; <span class="comment">//abcd代表四人，xy表示两个性质。 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input%<span class="number">2</span>) x=<span class="number">0</span>; <span class="keyword">else</span>&#123;x=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(input&gt;<span class="number">4</span>&amp;&amp;input&lt;=<span class="number">12</span>) y=<span class="number">1</span>;<span class="keyword">else</span> &#123;y=<span class="number">0</span>;&#125;;</span><br><span class="line">    a=(x&amp;&amp;y); b=(x||y);</span><br><span class="line">	<span class="keyword">if</span>(x*y==<span class="number">0</span>&amp;&amp;(x||y)==<span class="number">1</span>) c=<span class="number">1</span>; <span class="keyword">else</span> &#123;c=<span class="number">0</span>;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) d=<span class="number">1</span>; <span class="keyword">else</span> &#123;d=<span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,a,b,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得亏学过数电和单片机，反哺了。</p>
<h5 id="闰年判断"><a href="#闰年判断" class="headerlink" title="闰年判断"></a>闰年判断</h5><p>输入一个年份，判断这一年是否是闰年，如果是输出 11，否则输出 00。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714154108172.png" class="" title="image-20230714154108172">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;input%<span class="number">100</span>||input%<span class="number">400</span>==<span class="number">0</span>) x=<span class="number">1</span>; <span class="keyword">else</span>&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Apples"><a href="#Apples" class="headerlink" title="Apples"></a>Apples</h5><p>八尾勇喜欢吃苹果。她今天吃掉了 <em>x</em> 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1 个苹果，就输出 <code>Today, I ate 1 apple.</code>；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 <code>apple</code> 这个单词后面要加上代表复数的 <code>s</code>。你能帮她完成这个句子吗？</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714155007534.png" class="" title="image-20230714155007534">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>(input&lt;<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today, I ate %d apple.&quot;</span>,input);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Today, I ate %d apples.&quot;</span>,input);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用？：语句也可。</p>
<h5 id="洛谷团队系统"><a href="#洛谷团队系统" class="headerlink" title="洛谷团队系统"></a>洛谷团队系统</h5><p>在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 55 分钟；而在洛谷团队中上传私有题目，每题只需要花费 33 分钟，但是上传题目之前还需要一次性花费 1111 分钟创建与配置团队。现在要配置 n* 道题目，如果本地配置花费的总时间短，请输出 <code>Local</code>，否则输出 <code>Luogu</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> input,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;input);</span><br><span class="line">    <span class="keyword">if</span>((input*<span class="number">5</span>)&gt;(input*<span class="number">3</span>+<span class="number">11</span>))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Luogu&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;Local&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="肥胖问题"><a href="#肥胖问题" class="headerlink" title="肥胖问题"></a>肥胖问题</h5><p>BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 m&#x2F;h²其中 <em>m</em> 是指体重（千克），ℎ 是指身高（米）。不同体型范围与判定结果如下：</p>
<ul>
<li>小于 18.518.5：体重过轻，输出 <code>Underweight</code>；</li>
<li>大于等于 18.518.5 且小于 2424：正常体重，输出 <code>Normal</code>；</li>
<li>大于等于 2424：肥胖，不仅要输出 BMI 值（使用 <code>cout</code> 的默认精度），然后换行，还要输出 <code>Overweight</code>；</li>
</ul>
<p>现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。</p>
<p>对于非 C++ 语言，在输出时，请四舍五入保留六位<strong>有效数字</strong>输出，如果小数部分存在后缀 00，不要输出后缀 00。</p>
<p>请注意，保留六位<strong>有效数字</strong>不是保留六位小数。例如 123.4567 应该输出为 123.457，5432.10 应该输出为 5432.1。</p>
<p><strong>输入格式</strong></p>
<p>共一行。</p>
<p>第一行，共 22 个浮点数，m*,*h，分别表示体重（单位为 kg），身高（单位为 m）。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个字符串，表示根据 BMI 的对应判断。特别地，对于 <code>Overweight</code> 情况的特别处理请参照题目所述。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230714191105581.png" class="" title="image-20230714191105581">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> m,k,x;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">    x=m/k/k;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">18.5</span>) <span class="built_in">printf</span>(<span class="string">&quot;Underweight&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">25</span>&amp;&amp;x&gt;=<span class="number">18.5</span>) <span class="built_in">printf</span>(<span class="string">&quot;Normal&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">25</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.6g\nOverweight&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“.6g”意思是输出6位有效数字。</p>
<h5 id="三位数排序"><a href="#三位数排序" class="headerlink" title="三位数排序"></a>三位数排序</h5><p>给出三个整数a*,<em>b</em>,<em>c</em>(0≤<em>a</em>,<em>b</em>,*c≤100)，要求把这三位整数从小到大排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=b; b=i;  <span class="comment">//a和b互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=c; c=i; <span class="comment">//a和c互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=b; b=c; c=i; <span class="comment">//b和c互换</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总所周知，三位数需要比较三次。也可以用数组和指针的方法。</p>
<h5 id="月份天数"><a href="#月份天数" class="headerlink" title="月份天数"></a>月份天数</h5><p>输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数，分别表示年份 <em>y</em> 和月数 <em>m</em>，以空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个正整数，表示这个月有多少天。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230715112207643.png" class="" title="image-20230715112207643">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> y,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;y,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">2</span>&amp;&amp;(y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>||y%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;29&quot;</span>); <span class="comment">//闰年二月</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m%<span class="number">2</span>&amp;&amp;m!=<span class="number">2</span>||m==<span class="number">8</span>) <span class="built_in">printf</span>(<span class="string">&quot;31&quot;</span>); </span><br><span class="line">		<span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;m!=<span class="number">2</span>&amp;&amp;m!=<span class="number">8</span>) <span class="built_in">printf</span>(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;28&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人检测不出bug，不过仍未通过洛谷测试。</p>
<h5 id="不高兴的津津"><a href="#不高兴的津津" class="headerlink" title="不高兴的津津"></a>不高兴的津津</h5><p>津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。</p>
<p><strong>输入格式</strong></p>
<p>输入包括 77 行数据，分别表示周一到周日的日程安排。每行包括两个小于 1010 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。</p>
<p><strong>输出格式</strong></p>
<p>一个数字。如果不会不高兴则输出 00，如果会则输出最不高兴的是周几（用 1,2,3,4,5,6,71,2,3,4,5,6,7 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716095447576.png" class="" title="image-20230716095447576">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">6</span>],b[<span class="number">6</span>],i,x,y;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">		<span class="keyword">if</span>((a[i]+b[i])&gt;x&amp;&amp;(a[i]+b[i])&gt;<span class="number">8</span>) &#123;x=a[i]+b[i]; y=i+<span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（好像不需要数组），仍未通过洛谷测试点(12个差一)，本人查看无bug。</p>
<h5 id="买铅笔"><a href="#买铅笔" class="headerlink" title="买铅笔"></a>买铅笔</h5><p>P 老师需要去商店买<em>n</em> 支铅笔作为小朋友们参加 NOIP 的礼物。她发现商店一共有 33 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P 老师决定只买同一种包装的铅笔。</p>
<p>商店不允许将铅笔的包装拆开，因此 P 老师可能需要购买超过<em>n</em> 支铅笔才够给小朋友们发礼物。</p>
<p>现在 P 老师想知道，在商店每种包装的数量都足够的情况下，要买够至少<em>n</em> 支铅笔最少需要花费多少钱。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含一个正整数<em>n</em>，表示需要的铅笔数量。</p>
<p>接下来三行，每行用 2 个正整数描述一种包装的铅笔：其中第 1 个整数表示这种包装内铅笔的数量，第 2 个整数表示这种包装的价格。</p>
<p>保证所有的 7 个数都是不超过 10000 的正整数。</p>
<p><strong>输出格式</strong></p>
<p>11 个整数，表示 P 老师最少需要花费的钱。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,num,a[<span class="number">6</span>],x,money;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i],&amp;a[i+<span class="number">1</span>]);</span><br><span class="line">		num=a[<span class="number">0</span>]/a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>]%a[i]) num++;</span><br><span class="line">		x=num*a[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) money=x;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;money) money=x; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三角形分类"><a href="#三角形分类" class="headerlink" title="三角形分类"></a>三角形分类</h5><p>给出三条线段 a*,<em>b</em>,*c 的长度，均是不大于 10000 的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？</p>
<ul>
<li>如果三条线段不能组成一个三角形，输出<code>Not triangle</code>；</li>
<li>如果是直角三角形，输出<code>Right triangle</code>；</li>
<li>如果是锐角三角形，输出<code>Acute triangle</code>；</li>
<li>如果是钝角三角形，输出<code>Obtuse triangle</code>；</li>
<li>如果是等腰三角形，输出<code>Isosceles triangle</code>；</li>
<li>如果是等边三角形，输出<code>Equilateral triangle</code>。</li>
</ul>
<p>如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716183534384.png" class="" title="image-20230716183534384">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)	&#123;i=a; a=b; b=i;&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)	&#123;i=a; a=c; c=i;&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)	&#123;i=b; b=c; c=i;&#125; <span class="comment">//排序，方便后续判断</span></span><br><span class="line">	<span class="keyword">if</span>(a+b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b==c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Right triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b&gt;c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Acute triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a*a+b*b&lt;c*c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Obtuse triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a==b) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Isosceles triangle\n&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">if</span>(a==b==c) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Equilateral triangle\n&quot;</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not triangle\n&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍未通过洛谷测试点，本人查看无bug。</p>
<h5 id="小玉家的电费"><a href="#小玉家的电费" class="headerlink" title="小玉家的电费"></a>小玉家的电费</h5><p>夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 150 千瓦时及以下部分按每千瓦时 0.4463 元执行，月用电量在 151∼400 千瓦时的部分按每千瓦时 0.4663 元执行，月用电量在 401 千瓦时及以上部分按每千瓦时 0.56630.5663 元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数，表示用电总计（单位以千瓦时计），不超过 10000。</p>
<p><strong>输出格式</strong></p>
<p>输出一个数，保留到小数点后 11 位（单位以元计，保留到小数点后 11 位）。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718094839494.png" class="" title="image-20230718094839494">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">150</span>) y=x*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">150</span>&amp;&amp;x&lt;<span class="number">400</span>) y=(x<span class="number">-150</span>)*<span class="number">0.4663</span>+<span class="number">150</span>*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">400</span>) y=(x<span class="number">-400</span>)*<span class="number">0.5663</span>+<span class="number">250</span>*<span class="number">0.4663</span>+<span class="number">150</span>*<span class="number">0.4463</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="小鱼的航程（改进版）"><a href="#小鱼的航程（改进版）" class="headerlink" title="小鱼的航程（改进版）"></a>小鱼的航程（改进版）</h5><p>有一只小鱼，它平日每天游泳 250250 公里，周末休息（实行双休日)，假设从周 <em>x</em> 开始算起，过了 <em>n</em> 天以后，小鱼一共累计游泳了多少公里呢？</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数 x*,*n，表示从周 x 算起，经过 n天。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示小鱼累计游泳了多少公里。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718100558164.png" class="" title="image-20230718100558164">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,n,y=<span class="number">0</span>,i; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=x;i&lt;x+n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">7</span>!=<span class="number">6</span>&amp;&amp;i%<span class="number">7</span>!=<span class="number">0</span>) &#123;y=y+<span class="number">250</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>输入一组勾股数 a*,<em>b</em>,<em>c</em>（<em>a</em>\&#x3D;<em>b</em>\&#x3D;<em>c</em>），用分数格式输出其较小锐角的正弦值。（要求约分。）</p>
<p><strong>输入格式</strong></p>
<p>一行，包含三个正整数，即勾股数 a*,<em>b</em>,*c（无大小顺序）。</p>
<p><strong>输出格式</strong></p>
<p>一行，包含一个分数，即较小锐角的正弦值</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718180733934.png" class="" title="image-20230718180733934">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,i; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=b; b=i;  <span class="comment">//a和b互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=a; a=c; c=i; <span class="comment">//a和c互换	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		i=b; b=c; c=i; <span class="comment">//b和c互换</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;a+b+c;i++) <span class="comment">//用于约分</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a%i==<span class="number">0</span>&amp;&amp;c%i==<span class="number">0</span>) &#123;a=a/i;c=c/i;i--;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>,a,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的输出只是最短边&#x2F;斜边，for循环用于暴力约分。假如4&#x2F;8，第一次可约为2&#x2F;4，然后i–,使数据再次尝试约2，直到无法约2位置，然后i++,尝试约3，以此类推。</p>
<h5 id="陶陶摘苹果"><a href="#陶陶摘苹果" class="headerlink" title="陶陶摘苹果"></a>陶陶摘苹果</h5><p>陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 10 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 30 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。</p>
<p>现在已知 10 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</p>
<p><strong>输入格式</strong></p>
<p>输入包括两行数据。第一行包含 1010 个 100 到 200 之间（包括 100 和 200 ）的整数（以厘米为单位）分别表示 10 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 100 到 120 之间（包含 100 和 120 ）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。</p>
<p><strong>输出格式</strong></p>
<p>输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">9</span>],b,num,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d %d %d %d %d&quot;</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>],&amp;a[<span class="number">4</span>],&amp;a[<span class="number">5</span>],&amp;a[<span class="number">6</span>],&amp;a[<span class="number">7</span>],&amp;a[<span class="number">8</span>],&amp;a[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((b+<span class="number">30</span>)/a[i]&gt;=<span class="number">1</span>) num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h5><p>三个整数分别为 A*,<em>B</em>,*C。这三个数字不会按照这样的顺序给你，但它们始终满足条件：A&lt;B&lt;C。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行包含三个正整数 A*,<em>B</em>,*C，不一定是按这个顺序。这三个数字都小于或等于 100100。第二行包含三个大写字母 A、B 和 C（它们之间<strong>没有</strong>空格）表示所需的顺序。</p>
<p><strong>【输出格式】</strong></p>
<p>在一行中输出 A，B和 C，用一个 （空格）隔开。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230716231910507.png" class="" title="image-20230716231910507">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序，从小到大</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;n;q++)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>])  &#123;<span class="type">int</span> x=nums[i];nums[i]=nums[i+<span class="number">1</span>];nums[i+<span class="number">1</span>]=x;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">3</span>];</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;nums[<span class="number">0</span>],&amp;nums[<span class="number">1</span>],&amp;nums[<span class="number">2</span>]);</span><br><span class="line">	BubbleSort(nums,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (str[i])</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[<span class="number">2</span>]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ISBN-号码"><a href="#ISBN-号码" class="headerlink" title="ISBN 号码"></a>ISBN 号码</h5><p>每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 <code>x-xxx-xxxxx-x</code>，其中符号 <code>-</code> 就是分隔符（键盘上的减号），最后一位是识别码，例如 <code>0-670-82162-4</code>就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 <code>-</code> 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p>
<p>识别码的计算方法如下：</p>
<p>首位数字乘以 1 加上次位数字乘以 2 ……以此类推，用所得的结果 mod11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 <code>0-670-82162-4</code> 中的识别码 44 是这样得到的：对 <code>067082162</code> 这 99 个数字，从左至右，分别乘以 1,2,…,9 再求和，即 0×1+6×2+……+2×9&#x3D;1580，然后取 158 mod 11的结果 4 作为识别码。</p>
<p>你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 <code>Right</code>；如果错误，则输出你认为是正确的 ISBN 号码。</p>
<p><strong>输入格式</strong></p>
<p>一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。</p>
<p><strong>输出格式</strong></p>
<p>一行，假如输入的 ISBN 号码的识别码正确，那么输出 <code>Right</code>，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 <code>-</code>）。</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718085518325.png" class="" title="image-20230718085518325">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> b,c,d,x,y,a[<span class="number">9</span>],i,k=<span class="number">0</span>,num;</span><br><span class="line">	<span class="type">char</span> p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d-%s&quot;</span>,&amp;b,&amp;c,&amp;d,&amp;p);</span><br><span class="line">	a[<span class="number">0</span>]=b;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)	<span class="comment">//数据是3位，利用循环逐位取数，放入数组。比如123，分别将1,2,3放入a[1]，a[2]，a[3] </span></span><br><span class="line">	&#123;</span><br><span class="line">		y=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">3</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(y!=<span class="number">0</span>) x=c/y; </span><br><span class="line">		c=c%y;</span><br><span class="line">		a[i]=x;         </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">9</span>;i++)	<span class="comment">//同上，这次数据是5位，从a[4]开始往后取数放 </span></span><br><span class="line">	&#123; </span><br><span class="line">		y=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">8</span>-i);</span><br><span class="line">		<span class="keyword">if</span>(y!=<span class="number">0</span>) x=d/y; </span><br><span class="line">		d=d%y;</span><br><span class="line">		a[i]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)	<span class="comment">//ISBN计算公式，先求和 </span></span><br><span class="line">	&#123;</span><br><span class="line">		k=k+a[i]*(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	num=k%<span class="number">11</span>;          <span class="comment">//ISBN计算公式，再取余 </span></span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>&amp;&amp;p==<span class="number">88</span>)  <span class="comment">//条件判断与输出 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Right&quot;</span>); <span class="keyword">goto</span> Break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>&amp;&amp;p!=<span class="number">88</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-%d%d%d-%d%d%d%d%d-X&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">4</span>],a[<span class="number">5</span>],a[<span class="number">6</span>],a[<span class="number">7</span>],a[<span class="number">8</span>]); <span class="keyword">goto</span> Break;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((num+<span class="number">48</span>)==p&amp;&amp;p!=<span class="number">88</span>)	&#123;<span class="built_in">printf</span>(<span class="string">&quot;Right&quot;</span>);<span class="keyword">goto</span> Break;&#125;	</span><br><span class="line">	<span class="keyword">if</span>((num+<span class="number">48</span>)!=p)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d-%d%d%d-%d%d%d%d%d-%d\n&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">4</span>],a[<span class="number">5</span>],a[<span class="number">6</span>],a[<span class="number">7</span>],a[<span class="number">8</span>],num);<span class="keyword">goto</span> Break;&#125;</span><br><span class="line"></span><br><span class="line">Break:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到一个很烦的bug,第二次提取的五位数，在DEV中，输出</p>
<img src="/2023/07/13/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/image-20230718085116792.png" class="" title="image-20230718085116792">

<p>理论上，应该输出为0-670-82162-4。单独提取部分函数出来，进行测试，测试结果正常。怀疑定义时int长度不够，遂定为long，无果。最后换了一下编译器，在VC中结果正常。</p>
]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>实用软件</title>
    <url>/2023/08/10/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>有段时间，对于某些需求挺强烈的，但是也花了不少时间，不过可能也就那段时间用用罢了。或许可以整理一下，已经容易忘事了。<span id="more"></span></p>
<h3 id="远程屏幕分享"><a href="#远程屏幕分享" class="headerlink" title="远程屏幕分享"></a>远程屏幕分享</h3><p>单纯的一对一进行屏幕分享，按照分享的画面质量，延迟，帧率，大致可以做一个排名。当然，都是白嫖的。</p>
<p>发送方是电脑，接收方可以是电脑，或者是手机。</p>
<p>B站直播&gt;网页&gt;Skype&gt;钉钉&gt;qq</p>
<p>B站直播简单易行，除非是注意隐私，或者分享禁播游戏。</p>
<p>网页：<a href="https://easychuan.cn/">轻松传 - 传文件，传文本，传屏幕，传实时视频 (easychuan.cn)</a></p>
<p>网页分享屏幕帧率上限30帧，画面比较清晰，偶有卡顿。</p>
<p>Skype：免费注册，使用无需翻墙（或许注册的时候要），本质是一个网络电话，可以视频通话并分享屏幕，非常稳定。</p>
<p>钉钉和qq懂的都懂，不做评价。</p>
<h3 id="远程同乐"><a href="#远程同乐" class="headerlink" title="远程同乐"></a>远程同乐</h3><p>steam自带的远程同乐，Parsec(网络要求较高，需要公网，参考比特彗星黄绿灯），搭建局域网可用樱花映射（账号需要实名认证，并在支付宝扫脸，支付宝必须是实名认证时所填的身份信息并且18+，需要扫脸。软件较为良心）。</p>
]]></content>
      <categories>
        <category>储物间</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构（未完）</title>
    <url>/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="找最小值"><a href="#找最小值" class="headerlink" title="找最小值"></a>找最小值</h3><p>给出 .<em>n</em> 和 .<em>n</em> 个整数a<del>i</del> ，求这 <em>n</em> 个整数中最小值是什么。<span id="more"></span></p>
<p><strong>输入格式</strong></p>
<p>第一行输入一个正整数 <em>n</em>，表示数字个数。</p>
<p>第二行输入 <em>n</em> 个非负整数，表示 a<del>1</del> ,a<del>2</del> …..a<del>n</del>，以空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>输出一个非负整数，表示这 <em>n</em> 个非负整数中的最小值。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718190411647.png" class="" title="image-20230718190411647">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,i,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    	<span class="keyword">if</span>(i==<span class="number">0</span>) num=a[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">if</span>(a[i]&lt;num) num=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="分类平均"><a href="#分类平均" class="headerlink" title="分类平均"></a>分类平均</h3><p>给定 <em>n</em> 和 <em>k</em>，将从 1 到 <em>n</em> 之间的所有正整数可以分为两类：A 类数可以被 <em>k</em> 整除（也就是说是 <em>k</em> 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 1 位，用空格隔开。</p>
<p>数据保证两类数的个数都不会是 0。</p>
<p><strong>输入格式</strong></p>
<p>输入两个正整数 <em>n</em> 与 <em>k</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，两个实数，分别表示 A 类数与 B 类数的平均数。精确到小数点后一位。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718191544415.png" class="" title="image-20230718191544415">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,i,num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//累加</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(i%k==<span class="number">0</span>) &#123;a+=i;num=num+<span class="number">1</span>;&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;b+=i;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;n) &#123;num=<span class="number">1</span>;	n=n+<span class="number">1</span>;&#125; <span class="comment">//如果k&gt;n，完善代码</span></span><br><span class="line">	a=a/(<span class="type">float</span>)num;         <span class="comment">//取平均数。</span></span><br><span class="line">	b=b/(<span class="type">float</span>)(n-num);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f %.1f&quot;</span>,a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>仍未通过洛谷测试点。</p>
<h3 id="一尺之棰"><a href="#一尺之棰" class="headerlink" title="一尺之棰"></a>一尺之棰</h3><p>《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 <em>a</em> 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍的长度会变为 1？</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数 <em>a</em>，表示木棍长度。</p>
<p><strong>输出格式</strong></p>
<p>输出一个正整数，表示要第几天的时候木棍长度会变为 1。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718212020030.png" class="" title="image-20230718212020030">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,k,i,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) num=<span class="number">1</span>; <span class="comment">//应付测试点，当a=1时，表示第1天木棍长度为1，若不加，则a=1时，第0天木棍长度为1。</span></span><br><span class="line">    <span class="keyword">while</span>(a<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(a%<span class="number">2</span>&amp;&amp;a!=<span class="number">1</span>) &#123;a++;&#125;</span><br><span class="line">    	a=a/<span class="number">2</span>;</span><br><span class="line">    	num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="数字直角三角形"><a href="#数字直角三角形" class="headerlink" title="数字直角三角形"></a>数字直角三角形</h3><p>给出 <em>n</em>，请输出一个直角边长度是 <em>n</em> 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0。</p>
<p><strong>输入格式</strong></p>
<p>输入一个正整数 <em>n</em>。</p>
<p><strong>输出格式</strong></p>
<p>输出如题目要求的数字直角三角形。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718213101103.png" class="" title="image-20230718213101103">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,k,i,j,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    j=a;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a;i++)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				num++;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,num);	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			j--;	</span><br><span class="line">	 &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="阶乘之和（高精度）"><a href="#阶乘之和（高精度）" class="headerlink" title="阶乘之和（高精度）"></a>阶乘之和（高精度）</h3><p>用高精度计算出!<em>S</em>&#x3D;1!+2!+3!+⋯+<em>n</em>!（n*≤50）。</p>
<p>其中 <code>!</code> 表示阶乘，定义为n*!&#x3D;*n×(n−1)×(n−2)×⋯×1。例如，5!&#x3D;5×4×3×2×1&#x3D;120。</p>
<p><strong>输入格式</strong></p>
<p>一个正整数 <em>n</em>。</p>
<p><strong>输出格式</strong></p>
<p>一个正整数 <em>S</em>，表示计算结果。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230718220220977.png" class="" title="image-20230718220220977">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,i,j,k,x=<span class="number">1</span>,num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    k=a;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	x=x*j;  <span class="comment">//阶乘</span></span><br><span class="line">		&#125;</span><br><span class="line">		num=x+num;  <span class="comment">//求阶乘和</span></span><br><span class="line">		k--;</span><br><span class="line">		x=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>好吧好吧，还是想的太简单了。作为阶乘和，都是大整数，int和long甚至unsigned long long都无法存储。</p>
<p>那么拓展一下高精度的知识：</p>
<p>高精度乘法使用数组和逐位计算的方法来处理大整数乘法。每个数组元素存储整数的一位数字。通过使用数组来存储每个数字，可以处理任意长度的整数。</p>
<p>以下是高精度乘法的基本思路：</p>
<ol>
<li>创建两个整数的数组表示乘法运算的两个操作数，每个数组元素存储一个数字位。</li>
<li>从低位开始，逐位相乘，并将结果累加到结果数组中的相应位置。</li>
<li>处理进位：如果某个位置的乘积结果大于等于10，则将进位部分加到高位上。</li>
<li>重复上述步骤，直到乘法运算完成。</li>
<li>最后，将结果数组转换为所需的输出格式。</li>
</ol>
<p>高精度乘法的实现可能涉及到数组的遍历、进位处理和结果转换等操作。根据具体的需求和实现方式，代码可能会有所不同。在实际应用中，还可以使用现有的高精度计算库或使用其他更高效的算法来进行大整数乘法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">void AddStaff(void);</span><br><span class="line">int StaffNum=0;</span><br><span class="line">int Staff[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AddStaff();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void AddStaff(void)  //添加员工 </span><br><span class="line">&#123;</span><br><span class="line">	int i,j,a;</span><br><span class="line">	printf(&quot;您需要录入几位员工的数据，请输入：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">	if(a&lt;=0) &#123;printf(&quot;ERROR！请输入正确的格式&quot;);&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;开始录入员工编号\n&quot;);</span><br><span class="line">		for(i=1;i&lt;=a;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;您正在录入第%d位员工的编号，输入完毕后请按回车键。\n&quot;,StaffNum+i);</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;Staff[StaffNum+i]);</span><br><span class="line">			for(j=1;j&lt;StaffNum+i;j++)      //判断输入数据是否和之前的一样。 </span><br><span class="line">			&#123;</span><br><span class="line">				if(Staff[StaffNum+i]==Staff[j])</span><br><span class="line">				&#123;</span><br><span class="line">					printf(&quot;系统已收录该员工编号，请重新输入。\n&quot;); </span><br><span class="line">					i--;	</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125; </span><br><span class="line">		</span><br><span class="line">			if(Staff[StaffNum+i]/10000000==0||Staff[StaffNum+i]/10000000&gt;10)  //判断输入编号格式 </span><br><span class="line">			&#123;</span><br><span class="line">				printf(&quot;请按照正确格式输入，该次输入无效。\n&quot;);</span><br><span class="line">				i--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		printf(&quot;输入成功，已录入系统。&quot;);</span><br><span class="line">		StaffNum+=a; 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void LookStaff(void)   //查看录入的员工编号 </span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(StaffNum==0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;您还未录入员工编号，请先录入。&quot;);</span><br><span class="line">	 &#125; </span><br><span class="line">	 else</span><br><span class="line">	 &#123;</span><br><span class="line">		 printf(&quot;以下是系统已录入的员工编号：&quot;);</span><br><span class="line">		for(i=1;i&lt;=StaffNum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;第%d位员工：&quot;,StaffNum);</span><br><span class="line">			printf(&quot;%d\n&quot;,Staff[StaffNum]);</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><p><strong>题目描述</strong></p>
<p>试计算在区间 1 到 n 的所有整数中，数字 x（0 ≤ x ≤ 9）共出现了多少次？例如，在 1 到 11 中，即在 1,2,3,4,5,6,7,8,9,10,11中，数字 1 出现了 4 次。</p>
<p><strong>输入格式</strong></p>
<p>2 个整数 n,x，之间用一个空格隔开。</p>
<p><strong>输出格式</strong></p>
<p>1 个整数，表示 x 出现的次数。</p>
<img src="/2023/07/15/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/image-20230908221427186.png" class="" title="image-20230908221427186">
]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>循环结构和选择结构</title>
    <url>/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h6 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">语句块 <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句块 <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span><img src="/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/image-20230709100009541.png" class="" title="image-20230709100009541">

<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">	<span class="type">int</span> a, b, max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入两个整数： &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">if</span> (a&gt;b) max = a;</span><br><span class="line">		<span class="keyword">else</span> max = b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d和%d的较大值是： %d\n&quot;</span>, a, b, max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>输入两个整数： 34 28↙<br>34 和 28 的较大值是： 34</p>
<h6 id="只使用-if-语句"><a href="#只使用-if-语句" class="headerlink" title="只使用 if 语句"></a>只使用 if 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123; 语句块 &#125;</span><br></pre></td></tr></table></figure>

<h6 id=""><a href="#" class="headerlink" title=""></a><img src="/2023/07/08/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/image-20230709110223414.png" class="" title="image-20230709110223414"></h6><p>只使用 if 语句来求两个数中的较大值：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">	<span class="type">int</span> a, b, max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入两个整数： &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    max = b; <span class="comment">// 假设b最大</span></span><br><span class="line">    <span class="keyword">if</span> (a&gt;b) max = a; <span class="comment">// 如果a&gt;b，那么更改max的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d和%d的较大值是： %d\n&quot;</span>, a, b, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>输入两个整数： 34 28<br>34 和 28 的较大值是： 34  </p>
<h6 id="多个-if-else-语句"><a href="#多个-if-else-语句" class="headerlink" title="多个 if else 语句"></a>多个 if else 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件 <span class="number">1</span>)&#123;</span><br><span class="line">语句块 <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(判断条件 <span class="number">2</span>)&#123;</span><br><span class="line">语句块 <span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件 <span class="number">3</span>)&#123;</span><br><span class="line">语句块 <span class="number">3</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件 m)&#123;</span><br><span class="line">语句块 m</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句块 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>使用多个 if else 语句判断输入的字符的类别  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Input a character:&quot;</span>);</span><br><span class="line">     c = getchar();</span><br><span class="line">     <span class="keyword">if</span> (c&lt;<span class="number">32</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a control character\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a digit\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a capital letter\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is a small letter\n&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is an other character\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input a character:e↙<br>This is a small letter  </p>
<h6 id="if-语句的嵌套"><a href="#if-语句的嵌套" class="headerlink" title="if 语句的嵌套"></a>if 语句的嵌套</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123; <span class="comment">//!=表示不等于</span></span><br><span class="line">    <span class="keyword">if</span> (a&gt;b) <span class="built_in">printf</span>(<span class="string">&quot;a&gt;b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;a&lt;b\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;a=b\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Input two numbers:12 68<br>a&lt;b  </p>
<p>if 语句嵌套时，要注意 if 和 else 的配对问题。 C 语言规定， else 总是与它前面最近的 if 配对，例 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != b) <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b) <span class="built_in">printf</span>(<span class="string">&quot;a&gt;b\n&quot;</span>); <span class="comment">// ②</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;a&lt;b\n&quot;</span>); <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>

<p>③和②配对，而不是和①配对  。</p>
<h6 id="C-语言逻辑运算符"><a href="#C-语言逻辑运算符" class="headerlink" title="C 语言逻辑运算符"></a>C 语言逻辑运算符</h6><p>\1) 与运算(&amp;&amp;)<br>参与运算的两个表达式都为真时，结果才为真，否则为假。例如：<br>5&amp;&amp;0<br>5 为真， 0 为假，相与的结果为假，也就是 0。<br>(5&gt;0) &amp;&amp; (4&gt;2)<br>5&gt;0 的结果是 1，为真， 4&gt;2 结果是 1，也为真，所以相与的结果为真，也就是 1。<br>\2) 或运算(||)<br>参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假。例如：<br>10 || 0<br>10 为真， 0 为假，相或的结果为真，也就是 1。<br>(5&gt;0) || (5&gt;8)<br>5&gt;0 的结果是 1，为真， 5&gt;8 的结果是 0，为假，所以相或的结果为真，也就是 1。<br>\3) 非运算(!)<br>参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。例如：<br>!0<br>0 为假，非运算的结果为真，也就是 1。<br>!(5&gt;0)<br>5&gt;0 的结果是 1，为真，非运算的结果为假，也就是 0。  </p>
<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>逻辑运算符和其它运算符优先级从低到高依次为：<br>赋值运算符(&#x3D;) &lt; &amp;&amp;和|| &lt; 关系运算符 &lt; 算术运算符 &lt; 非(!)<br>&amp;&amp; 和 || 低于关系运算符， ! 高于算术运算符。<br>按照运算符的优先顺序可以得出：<br>    a&gt;b &amp;&amp; c&gt;d 等价于 (a&gt;b)&amp;&amp;(c&gt;d)<br>    !b&#x3D;&#x3D;c||d&lt;a 等价于 ((!b)&#x3D;&#x3D;c)||(d&lt;a)<br>     a+b&gt;c&amp;&amp;x+y&lt;b 等价于 ((a+b)&gt;c)&amp;&amp;((x+y)&lt;b)<br>另外，逻辑表达式也可以嵌套使用，例如 a&gt;b &amp;&amp; b || 9&gt;c， a || c&gt;d &amp;&amp; !p。  </p>
<h6 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 整型数值 <span class="number">1</span>: 语句 <span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> 整型数值 <span class="number">2</span>: 语句 <span class="number">2</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> 整型数值 n: 语句 n;</span><br><span class="line"><span class="keyword">default</span>: 语句 n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（? :）"></a>条件运算符（? :）</h6><p>语法格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式 <span class="number">1</span> ? 表达式 <span class="number">2</span> : 表达式 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果表达式 1 的值为真，则以表达式 2 的值作为<br>整个条件表达式的值，否则以表达式 3 的值作为整个条件表达式的值。条件表达式通常用于赋值语句之中。  </p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) &#123;</span><br><span class="line">       max = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       max = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max = (a&gt;b) ? a : b;</span><br></pre></td></tr></table></figure>

<p>使用条件表达式时，还应注意以下几点：<br>\1) 条件运算符的优先级低于关系运算符和算术运算符，但高于赋值符。因此<br>    max&#x3D;(a&gt;b) ? a : b;<br>可以去掉括号而写为<br>    max&#x3D;a&gt;b ? a : b;<br>\2) 条件运算符?和：是一对运算符，不能分开单独使用。<br>\3) 条件运算符的结合方向是自右至左。例如：<br>    a&gt;b ? a : c&gt;d ? c : d;  </p>
<p>应理解为：<br>a&gt;b ? a : ( c&gt;d ? c : d );<br>这也就是条件表达式嵌套的情形，即其中的表达式又是一个条件表达式。  </p>
<h6 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">	语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是，先计算“表达式”的值，当值为真（非 0）时， 执行“语句块”；执行完“语句块”，再次计算表达式的值，如果为真，继续执行“语句块”……这个过程会一直重复，直到表达式的值为假（0），就退出循环，执行 while后面的代码。  </p>
<h6 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>do-while 循环与 while 循环的不同在于：它会先执行“语句块”，然后再判断表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此， do-while 循环至少要执行一次“语句块”。  </p>
<h6 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)&#123;</span><br><span class="line">语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的运行过程为：<br>\1) 先执行“表达式 1”。<br>\2) 再执行“表达式 2”，如果它的值为真（非 0），则执行循环体，否则结束循环。<br>\3) 执行完循环体后再执行“表达式 3”。<br>\4) 重复执行步骤 2) 和 3)，直到“表达式 2”的值为假，就结束循环。  </p>
<h6 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h6><p>当 break 关键字用于 while、 for 循环时，会终止循环而执行整个循环语句后面的代码。 break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环 。</p>
<p>例：使用 while 循环计算 1 加到 100 的值：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//循环条件为死循环</span></span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：5050<br>while 循环条件为 1，是一个死循环。当执行到第 100 次循环的时候，计算完 i++;后 i 的值为 101，此时 if 语句的条件 i&gt; 100 成立，执行 break;语句，结束循环。  </p>
<p>在多层循环中，一个 break 语句只向外跳一层。  </p>
<h6 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h6><p>continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环。 continue 语句只用在 while、 for 循环中，常与 if 条件语句一起使用，判断条件是否成立。  </p>
]]></content>
      <categories>
        <category>C语言学习之路</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>童年的正午小路</title>
    <url>/2023/07/10/%E7%AB%A5%E5%B9%B4%E7%9A%84%E6%AD%A3%E5%8D%88%E5%B0%8F%E8%B7%AF/</url>
    <content><![CDATA[<p>​		在我小学的时候，蛮喜欢玩的。有邻居好友，有同学玩伴。上课学习一下，中午跑到学校附近一个类似于“托管班”的地儿。<span id="more"></span>应该是一个私人住宅，主人是原先小学的老师，应该退休了。叫“陈老师”。和班上几位同学，同校的一些校友在里头吃中午饭，年纪小的要睡午觉，大孩子则到二楼闹腾。</p>
<p>​		小学生嘛，流行什么玩什么。在那里，玩过老鹰抓小鸡，蒙过眼睛抓人，玩过弹珠，比过陀螺，也有那种砸卡。硬币大小的卡套，可以放几张圆形的卡进去。卡套两边有个小坡，可以被其他卡套滑上去。一般规则就是谁被滑上去了，卡套里的卡归就归谁了，有时候卡套也算在内。后面五六年级，就是打扑克，三国杀为主了。也有一些西游杀等等。</p>
<p>​		那附近也有一个小卖部。有卖一根葱之类的小零食。印象比较深的是小卖部有一次进了那种花钱抽奖的小纸片。5毛还是1块钱一张。同学第一次中了5块，老板娘不认账了。说这5块只能继续拿来抽卡，然后气不过，又没办法。只能再抽，不过爆率是真的高。后续是一盒纸片，给我们抽了个六成，倒是过了把瘾。后面就没再见过店里有这个了。</p>
<p>​		中午闹腾够了，下午则结伴上学去了。路途有一个废弃的房子，斑驳的锁，关不严的门。曾偷偷顺着门缝儿往里面看去。一片土地，零星的水泥，几点的杂草。还有一滩白骨和一个猫脑袋的骷髅。白骨看上去像是粉末一般，已经是一片了，看不出是什么。看那骷髅脑袋推断的。当初是很想拿出来瞅瞅的，感觉如果带到学校去，一定很酷。</p>
<p>​		也在下午结伴的时候，甩书包玩，像是电视里甩链球的动画一样，抓着书包，原地转圈甩出去。有个玩伴，丢的时候，书包正好飞向小河的方向。好巧不巧，那里正好有个小石凳，书包磕到石凳边缘。然后从石凳上缓慢滚了一下，最后还是滑下去了。冲过去的时候，书包正飘在水面上。自己当时觉得这个画面太滑稽了，笑的上气不接下气，还是叫住了前面另一个玩伴。然后他用树枝想把书包划到岸边，结果书包在水的一阵阵涟漪中反复横跳。不肯走也不肯来，小孩子的喧哗倒是惊动了附近的一位老太太。她从家中找了跟长竹竿，最后书包才得以上岸，最后作业当然是全湿了。</p>
<p>​		也是那条路，傍晚回家的时候，每每走到巷子里的时候，总会远远地见到一直猫，黑猫，但它会笑，而且笑起来特别诡异。令我毛骨悚然。它的微笑直接咧到耳根子。一向它走去，它就扭头撒丫子跑了。一连几天。那时候自己看了老哥送的《笑猫日记——寻找黑骑士》。似乎还看了《马小跳》。杨红樱的作品看了零星点点。当初是有点相信世界上有会笑的猫的，不过也没见过，想象中应该笑的很可爱。后续啊后续，终于它有一次从我面前跳了出来。瞟了我一眼，我清晰的看到它脸上有两条印。就两条黄黑色的线，从嘴巴斜着到眼睛，两边都很均匀。配合它一身黑毛，远远的看上去，就像是只看到一双眼睛，和眼睛下的一个“V”。非常渗人。还好最后还是明白的它的笑是怎么一回事。不过后面就再也没有见过它了。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>　　其实做一个私人博客，是很早前就有的想法。最早是追溯到小学吧，觉得这是一件很酷的事情。就像是精心的养QQ空间的花给来访者看或者是配置背景音乐（后来需要绿钻）。<span id="more"></span>大抵在初中和高中，觉得自己会有一些比较有趣的想法，或者一些想做的事情，先记着，以后会做。当然，现在慢慢淡忘了，仅有一些，记载在高中的笔记本，亦或是回忆。那时候懒，不想写东西，也不愿留下什么。拍照也仅仅是消遣。  </p>
<p>　　再后来，觉得有些东西还是记下来好。出现记录的想法，源于我当初玩过的游戏，追过的漫画，看过的小说。明明当初很沉浸，或是冒险救公主，或是探索世界，或是征战一方。但渐渐的，就忘却当初的感觉。仅有一些印象极深的bgm和cg。再看再听时，能回忆起创作者们精心构建的世界。我是想把自己此刻喜欢的东西，记录下来。最好的办法应该是把它们构建成一幅画。比如：库巴顶着豌豆射手和坚果地刺构成的防线，就为了摘到后排的向日葵送给桃花公主。亚瑟深吸一口气，死亡之眼后，左轮已回腰间。百尺外的酒瓶岿然不动，倒是有个刺猬蓝毛小子戏谑的把玩子弹。如此如此，或许可以把一生所爱，都绘成一幅画。尽管有Ai，但构图和规模都是难以企及的。<br>​　　扯远了，私人博客除了分享我个人的一些东西。也是自己的归档。电脑和手机里有太多太多东西，草草被留在各处，现在打算给它们做个坟墓，也算是朝花夕拾。也想着来访的人，仅能在那一天，能见到墓碑。不过自己懒，或许只会给碑上刻一些自己才能看懂的墓志铭。既是赛博坟墓，自应万古长存。静态博客将在云端和硬盘中进行双备份。并挂载到github。</p>
]]></content>
      <categories>
        <category>杂谈与想法</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>说说(2023)</title>
    <url>/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/</url>
    <content><![CDATA[<p>　　<span id="more"></span>曾在初中高中的时候，想过说说的意义。当初是觉得别人发一条说说，很多人点赞，好厉害的样子。当时自己是不爱发说说的，那时候有相机记录生活，有kindle阅读世界，也有游戏机。不过到现在，自己倒是很平常的分享自己的日常了，说是分享，其实更多是记录，记录自己的生活，所以也开始发说说了，原本是仅自己可见，不过有些事，还是希望能让更多人知道。像是传教般，也渴望有人能在自己感兴趣的东西上交流。原来我的好友里，也有对这方面有兴趣的人啊。。。。。。不过直到现在，还是觉得自己记录就好了，或许现在还不习惯博客的载体，觉得比动动手指，发个QQ空间或者朋友圈要麻烦的多，希望自己能在这记载。相较于云上的存储，自己更安心能在本地，或者硬盘上存储自己的回忆。</p>
<h3 id="2023-7-26"><a href="#2023-7-26" class="headerlink" title="2023-7-26"></a>2023-7-26</h3><p>　　虽然她中考考差了，不过也是走出来了。倒是和之前想的一样，不过调整的时间还是蛮久的。这有点超乎意料，决定再复读一年也蛮好。希望她能加油，湖南的教育真的是太卷了。如果我以后有孩子，不希望看到ta和她一样。真的太累了。她决定暑假好好玩玩。倒也行。反正8月13号开学，也快。当是劳逸结合吧。</p>
<h3 id="2023-7-XX"><a href="#2023-7-XX" class="headerlink" title="2023-7-XX"></a>2023-7-XX</h3><p>　　因为实际上自己是8月14才决定试着写博客。这些事情或许是回忆，不过都有些繁琐。博客美化的挺满意的，因此也很乐意用它记述。不过本来是以说说为目的，到后面可能会变成日志了。还是决定记载后面的事吧，这个暑假，亦失亦得，事不少。</p>
<h3 id="2023-8-14"><a href="#2023-8-14" class="headerlink" title="2023-8-14"></a>2023-8-14</h3><p>时间过的好快，还有半个月就开学了。计划还是赶不上变化，自己应该在这个暑假，把车车搞好，小四轴焊好，至少调试没问题，四轴的深入研究可以等到以后。</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/image-20230814235033738.png" class="" title="image-20230814235033738">

<p>2023年9月8日，《YOSHIKI：UNDER THE SKY》记录片开播了，我觉得叫《天空之下》还不错，或许可以期待一手，不过没有到中国上映，也是偏冷门，希望能在10月初能看到资源，并且有翻译。这可以期待一手的，当初也是因为纪录片，才对X  JAPAN感兴趣。或许天空之下能带给我更多的惊喜。（但是林老板鸽了6年的新专辑呢？不会真打算10年磨一剑吧。。）</p>
<h3 id="2023-9-3"><a href="#2023-9-3" class="headerlink" title="2023-9-3"></a>2023-9-3</h3><p>新学期了，今天发教材，发现stm32那本书我买过？还稍微看了一下。不过一般还是去B站看的。（突然感觉我又可以翘课了）</p>
<p>贴一下，我原本是看到画才关注画师（優子鈴），觉得色彩很棒。</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/20230903_152234.jpg" class="" title="20230903_152234">

<p>后面喜欢这幅画的神情，不过上色感觉有点杂</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/20230901_150639.jpg" class="" title="20230901_150639">

<p>将我妹的小玩意布置了一下，似乎还不错？</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/IMG20230901233238.jpg" class="" title="IMG20230901233238">

<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/IMG20230902001659-16937269066041.jpg" class="" title="IMG20230902001659">

<p>（或许整理好电脑桌面再拍会更好些)。</p>
<h3 id="2023-9-5"><a href="#2023-9-5" class="headerlink" title="2023-9-5"></a>2023-9-5</h3><p>看到鸽子，理解鸽子，成为鸽子。</p>
<h3 id="2023-9-7"><a href="#2023-9-7" class="headerlink" title="2023-9-7"></a>2023-9-7</h3><p>年轻真好，博爱真好。</p>
<p>　　</p>
<p>　　</p>
<p>　　</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/image-20230907193520666.png" class="" title="image-20230907193520666">

<p>难得今天大更一下，灾难性的目录栏，自己甚至考虑到要更换音乐插件，为底部模式了，然后是各种头疼，自己当初可是东一铲西一铲，自己都不知道该翻哪里的屎堆，所幸只是hexo解析md目录只能支持逐级目录，而我经常越级，改好后上传，还算可以。</p>
<img src="/2023/08/14/%E8%AF%B4%E8%AF%B4(2023)/image-20230907194355312.png" class="" title="image-20230907194355312">
]]></content>
      <categories>
        <category>说说</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>远古的啊哈C</title>
    <url>/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/</url>
    <content><![CDATA[<p>　　在我小学六年级的时候，老哥给我买了本小学生坐在马桶上都能读懂的Ｃ语言书《啊哈Ｃ语言》。那时候老哥应该大学在读，大概是本着培养兴趣把这本书塞给我。当初对游戏着迷。家人们抱着“你那么爱玩游戏，做一个游戏给别人玩”的想法鼓励我敲敲代码。<span id="more"></span>虽然在小学生看来，对着电脑写代码就像黑客一样酷炫。看着满屏滚动的代码和窗口，自己动动手指，就能在世界的某个地方引起骚乱和轰动。亦或者是黑入某个企业或政府的网站，把主页改成“ＸＸＸ到此一游”。然后坐等媒体宣传，国家招安。但很快在过早的年龄，体验到头秃的感觉。</p>
<p>　<img src="/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/001.jpg" class=""></p>
<p>　　谁能想象，一个正值童年的小子，看着书对着电脑一个字母一个字母的敲。边敲边抓脑袋，痛苦着思考示例程序的代码逻辑，头发大把大把掉。真是童年的梦魇。</p>
<p>　　怎么可能？！</p>
<p>　　事实上，当自己用‘＃’和‘＠’等一些特殊字符，仿照书上手打了一两幅走迷宫的地图，便放弃了。又麻烦又不好玩。早早明白了做游戏是多累多无聊的事情。而且看了那么久书，也没教人什么好玩的东西。索性丢书逛论坛去了。论坛有不少人的示例程序，自己copy别人的代码，在电脑上跑着玩。现在才明白，这才是程序猿的正确打开方式。Ctrl+C和Ctrl+V使我在放弃后，仍能兴致勃勃的翻阅代码。</p>
<p>　　印象较深的是Ai对话和一款文字游戏《勇者斗恶龙》。Ai对话也不算Ai，更像是本字典。你填入提问的答案，它才会回答。不然就是不知道，不清楚。虽然交互上比现在的ChatGpt更方便调教，但是也极度无聊。或许大家交换自己的Ai，才会有点玩头。《勇者斗恶龙》应该是我第一款接触到的文字游戏。因为几个选项暴毙魔界后，便想着修改源码。抓耳挠腮的反复翻看几千行的代码，瞎改。不过有点小聪明，知道哪些地方不能动，哪些地方改了也白改。但还是无果。随后这份源码便保存在我的ＱＱ日志里，仅我可见。</p>
<p>　　<img src="/2023/07/02/%E8%BF%9C%E5%8F%A4%E7%9A%84%E5%95%8A%E5%93%88C/002.png" class=""></p>
<p>　　其他的代码，就是贪吃蛇推箱子这种无聊小游戏。或者是让运行框显示烟花啊，在黑色背景下滚动的绿色数字，满足一下童年对黑客的幻想。但自己也知道这些只是嚎头而已。稍稍有点意思的，也只是一些像病毒一样的恶作剧。比如超多的弹窗，再怎么点叉也叉不完。弹出个窗口，给你１分钟让你承认你是猪，不承认，叉掉或者时间到了，电脑就会强制关机。或者模拟蓝屏，但是能用任务管理器清掉，或者按Ｅｓｃ就能使全屏变窗口。又或者是一个乱动的鼠标，只能靠自己的能力，用键盘调出任务管理器，再用鼠标点那个程序。至于怎么点，那只能看你了。实际上乱动的ＣＤ不长，也可以迅速摸过去点一下。当然，自己也能设置ＣＤ，但是再短，自己也关不掉了，只能重启。这些恶作剧小程序，给我改了个名，上传到班群去了。觉得最有搞头的鼠标乱动，命名为“三维弹珠”，其他的冠以电脑课学过的软件。希望能有人下载打开，然后看到异常的电脑大惊失色，慌忙的喊大人过来。不过到现在为止，除了我，也没什么人下过。自己也没听过关于隐藏在群文件之中“病毒”的小道消息。　　</p>
<p>​			<img src="./003.png" style="zoom:75%;" /></p>
<p>　　后来，玩的差不多了，便丢在角落了。小孩子坐不住，谁会搁这电脑前坐一天，薅自己的头发写代码呢？哦，大一开始学Ｃ语言是这样的。大二开始学Ｃ５１和ｓｔｍ32标准库也是这样的。还好从小就深通ｃｏｐｙ的精髓，毕竟连牛顿也是站在巨人的肩膀上。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐启蒙</title>
    <url>/2023/07/16/%E9%9F%B3%E4%B9%90%E5%90%AF%E8%92%99/</url>
    <content><![CDATA[<p>​		其实我听歌的时候算晚的了。尝试寻找，选择自己喜欢的音乐，大抵是高中的时候。在此之前，我甚至不听歌，觉得没啥意思。</p>
<span id="more"></span>

<p>​		不过，漫长岁月里，我也不可能完全没听过音乐，童年里，有小学音乐课的《外婆的澎湖湾》，有家里点读机的《鲁冰花》，也有老哥唱的《风云决》，老爸兴起常哼的《好汗歌》。再着就是烂大街的凤凰传奇，因为在广东的缘故，身边也有人听beyond的《不再犹豫》(不过也是很久以后才发现的)。然后自己感觉我能和一首歌的旋律同步一样，就是没听过的歌，能认真的让自己脑中的旋律和它同步。不过有时候一些变奏也跟不上。</p>
<p>​		即使如此，仍觉无感。似乎我的童年只有纯粹的玩乐。我理解不了旋律，对歌词无感。觉得无非就是爱恨情仇，实在不太感冒。对歌星的了解也仅限于身边伙伴的谈论。小学六年级的时候，班里的广播放TF_boy的歌，倒有一堆童子童女捂住耳朵，十分不情愿的样子，看样子也不是很讨厌，自己当初感觉他们好像平时经常听。直到现在，也不太理解他们当时的想法，或许是听腻了？不想再听？当初在班里比较知名的，除了他好像就是周杰伦了，自己依稀记得班里有不少女生谈论或者有一些照片。</p>
<p>​		然后初中回到老家，仍是对音乐无感。并且对他们的品味嗤之以鼻，不是土嗨就是无聊的情歌。在初中，自己信息闭塞，班里人有智能手机，有的还打王者。自己有个老哥送的mp4,和村里一个小孩的游戏机。自己就用mp4看小说，或者玩玩游戏，那上面大多是古早的fc游戏，一代的超级玛丽或者实况足球。不过在校的话，还是喜欢学以致用，捣鼓了很多东西玩儿，这就是另一个故事了。在初中能记起的歌，似乎是纵贯线的《再见》（live）和李玉刚的《刚好遇见你》。这个是下课铃响后，自己冲入学校食堂吃饱饭足后，惬意的回到教室的时候，学校广播所放的歌。</p>
<p>​		直到高中，也只是高二高三的时候，发现写作业很无聊，于是边听电台边写作业。或者晚自习的时候，偷偷用mp4翻电台听。什么中国之声的，都听过。在那个闭塞的环境里，想用它为自己打开一些世界。最后发现听电台写作业太容易分心。自习听电台，也有时候要听不少广告，内容也不一定是自己感兴趣的。随后又下了不少相声或者说书，相声自己倒是从小看的时候觉得很有意思，但也没深入。</p>
<p>​		此后，自己用kindle看知乎周刊，有一期是关于摇滚的，内容看着很有意思，便听了一些期刊中列举的歌。有不少听不进去，但有不少却意外的喜欢，比如Pink floyd的《Wish you were here》。被里面的吉他和它的故事吸引。深感浪漫。于是一发不可收拾，在下载了《月之暗面》，一气呵成的听了两三遍后，就弃了。这啥啊，一个专辑，十多首歌，差不多一个多小时。但是它风评又很好，互联网上一堆吹的。行吧，或许自己没到那个地步，寻寻渐进，先听一些流行摇滚吧。然后就挑，知名摇滚乐队有啥啊。披头士，ACDC,齐柏林，大门。逐一挑几首热门的，听着不错，再挑销量不错的专辑，然后蛮喜欢，就干脆把作品都全下了，一首首慢慢听，喜欢的留着，可以反复听，不喜欢的就挪个位置。</p>
<p>​		不过遗憾的是，很多乐队的歌听不进。能听的进去就beyond，披头士，avantasia,X japan，pink floyd。这些比较喜欢。pink floyd是不知道哪一天，脑袋中回想起它的旋律，然后再听就喜欢上了。后面发现自己喜欢迷幻摇滚和金属歌剧。我喜欢一气呵成，连续一两个小时沉浸其中。其实高中的时候，比较空闲，对摇滚的探索是很多的。或许是迷恋于它的故事，它的寓意，它对世界的居高临下，和对自由的渴望等等。不过直到现在，它都是我最喜欢的音乐。</p>
<p>​		再后来，听过纯音乐，对古典音乐有过尝试，也听过rap和流行音乐。只是觉得这些太容易腻了，古典音乐也不太听不进（除非像猫和老鼠那样）。现在倒偶尔听听电音，摇滚似乎也是翻来覆去那些乐队。安于现状。</p>
<p>​		有想过弹贝斯，弹吉他，弹钢琴。我想用贝斯弹《つぎの夜へ》，沉沦其中。想怀抱吉他，跟着电台弹《Wish you  were here》，一遍遍用钢琴演奏《The last song》。如果能实现，那样十分惬意呐。</p>
<img src="/2023/07/16/%E9%9F%B3%E4%B9%90%E5%90%AF%E8%92%99/123.jpg" class="" title="img">

<p>不过只在大一，参加了社团培训，入门吉他一个学期。想必下次入门会更有经验了（笑）。</p>
<p>​		感谢音乐，倒是一路过来，或许没有同趣之人可以分享。窃以为，能与乐队，在音乐中相识同感即可。</p>
<p>应该附上自己喜欢的乐队和最喜欢的一首歌：</p>
<p>Pink Floyd								《Wish You Were Here》</p>
<p>X Japan									《The Last Song》</p>
<p>ゆらゆら帝国						《つぎの夜へ》</p>
<p>Avantasia								《The Seven Angels》</p>
<p>Metallica								《Fade To Black》</p>
<p>Guns N’ Roses 						《Novenmber Rain》</p>
<p>Wolf Alice 								《Soapy Water》</p>
<p>Stratovarius							《When Mountains Fall》</p>
<p>Porter Robinson						《Shelter》</p>
<p>beyond（挑不出）</p>
<p>…………….</p>
<p>​		高中时曾听闻同学以前班上晚会，有人失恋了，在全班上唱beyond《海阔天空》，或者用《真的爱你》表白。颇为不齿。</p>
]]></content>
      <categories>
        <category>朝花夕拾</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序结构</title>
    <url>/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h6 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World!"></a>Hello,World!</h6><p>编写一个能够输出 <code>Hello,World!</code> 的程序。<span id="more"></span></p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712000542827.png" class="" title="image-20230712000542827">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>Hello,World!</p>
<h6 id="输出字符菱形"><a href="#输出字符菱形" class="headerlink" title="输出字符菱形"></a>输出字符菱形</h6><p>用 <code>*</code> 构造一个对角线长 55 个字符，倾斜放置的菱形。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712000922663.png" class="" title="image-20230712000922663">

<p>简单粗暴法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慵懒粗暴法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  *\n ***\n*****\n ***\n  *\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="超级玛丽游戏"><a href="#超级玛丽游戏" class="headerlink" title="超级玛丽游戏"></a>超级玛丽游戏</h6><p>超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                ********</span><br><span class="line">               ************</span><br><span class="line">               ####....#.</span><br><span class="line">             #..###.....##....</span><br><span class="line">             ###.......######              ###            ###</span><br><span class="line">                ...........               #...#          #...#</span><br><span class="line">               ##*#######                 #.#.#          #.#.#</span><br><span class="line">            ####*******######             #.#.#          #.#.#</span><br><span class="line">           ...#***.****.*###....          #...#          #...#</span><br><span class="line">           ....**********##.....           ###            ###</span><br><span class="line">           ....****    *****....</span><br><span class="line">             ####        ####</span><br><span class="line">           ######        ######</span><br><span class="line">##############################################################</span><br><span class="line">#...#......#.##...#......#.##...#......#.##------------------#</span><br><span class="line">###########################################------------------#</span><br><span class="line">#..#....#....##..#....#....##..#....#....#####################</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.....#......##.....#......##.....#......#    #----------#</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#</span><br><span class="line">##########################################    ############</span><br></pre></td></tr></table></figure>

<p>有一种printf多行字符串的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;                ********\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ************\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ####....#.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             #..###.....##....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ###.......######              ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;                ...........               #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ##*#######                 #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;            ####*******######             #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ...#***.****.*###....          #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....**********##.....           ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....****    *****....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ####        ####\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ######        ######\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##############################################################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#...#......#.##...#......#.##...#......#.##------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;###########################################------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#..#....#....##..#....#....##..#....#....#####################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.....#......##.....#......##.....#......#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    ############\n&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A+B Problem"></a>A+B Problem</h6><p>输入两个整数a,b，输出它们的和；</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712003025442.png" class="" title="image-20230712003025442">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="字符三角形"><a href="#字符三角形" class="headerlink" title="字符三角形"></a>字符三角形</h6><p>给定一个字符，用它构造一个底边长 55 个字符，高 33 个字符的等腰字符三角形。</p>
<p>输入格式：	 输入只有一行，包含一个字符。</p>
<p>输出格式：	该字符构成的等腰三角形，底边长 55 个字符，高 33 个字符。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712003406362.png" class="" title="image-20230712003406362">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %c\n %c%c%c\n%c%c%c%c%c&quot;</span>,a,a,a,a,a,a,a,a,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="苹果采购"><a href="#苹果采购" class="headerlink" title="苹果采购"></a>苹果采购</h6><p>现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？</p>
<p>输入格式：</p>
<p>输入两个不超过 109109 正整数，分别表示每人分到的数量和同学的人数。</p>
<p>输出格式：</p>
<p>一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712004708142.png" class="" title="image-20230712004708142">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a*b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="字母转换"><a href="#字母转换" class="headerlink" title="字母转换"></a>字母转换</h6><p>输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712004845534.png" class="" title="image-20230712004845534">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	a-=<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ASCII码表中，小写字母比大写字母大32.</p>
<h6 id="数字反转"><a href="#数字反转" class="headerlink" title="数字反转"></a>数字反转</h6><p>输入一个不小于 100100 且小于 10001000，同时包括小数点后一位的一个浮点数，例如 123.4 ，要求把这个数字翻转过来，变成 4.321 并输出。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712005845379.png" class="" title="image-20230712005845379">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a,b;</span><br><span class="line">	<span class="type">int</span> c,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;a);</span><br><span class="line">	c=a*<span class="number">10</span>;</span><br><span class="line">	d=c%<span class="number">10</span>*<span class="number">1000</span>+c/<span class="number">10</span>%<span class="number">10</span>*<span class="number">100</span>+c/<span class="number">100</span>%<span class="number">10</span>*<span class="number">10</span>+c/<span class="number">1000</span>;<span class="comment">//反转</span></span><br><span class="line">	b=(<span class="type">float</span>)d/<span class="number">10</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5.1f&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>656.8↙<br>865.6</p>
<p>浮点数不能取余，所以干脆变成整形转换，转换完成后在变回来。可以使用强制类型转换，也可定义中间变量。最后输出时“%5.1f”，意思是至少占5个字符宽度（包括一位小数和一个小数点），且小数点后面有1位小数，小数点占一位，所以整数部分至少占3位。</p>
<p>懒人法（直接利用字符串）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a, b, c, d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c.%c&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c.%c%c%c&quot;</span>, d, c, b, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="再分肥宅水"><a href="#再分肥宅水" class="headerlink" title="再分肥宅水"></a>再分肥宅水</h6><p>现在有 t 毫升肥宅快乐水，要均分给 n 名同学。每名同学需要 2 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后3 位），以及一共需要多少个杯子。</p>
<p>输入格式：</p>
<p>输入一个实数 t 和一个正整数 n，使用空格隔开。</p>
<p>输出格式：</p>
<p>输出两行。</p>
<p>第一行输出一个三位小数，表示可以获得多少毫升饮料。第二行输出一个正整数，表示一共需要多少个杯子。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712103702737.png" class="" title="image-20230712103702737">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> a,c;</span><br><span class="line"><span class="type">int</span> b,d;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a/b;</span><br><span class="line">	d=<span class="number">2</span>*b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%0.3f\n%d&quot;</span>,c,d);;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h6><img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712104909313.png" class="" title="image-20230712104909313">

<p>输入格式：</p>
<p>第一行输入三个实数a*,<em>b</em>,*c，以空格隔开。</p>
<p>输出格式：</p>
<p>输出一个实数，表示三角形面积。精确到小数点后 1位。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712104959296.png" class="" title="image-20230712104959296">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> a,b,c,p,s;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	p=<span class="number">0.5</span>*(a+b+c);</span><br><span class="line">	s=p*(p-a)*(p-b)*(p-c);</span><br><span class="line">	s=<span class="built_in">sqrt</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,s);;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>double精度比float高，sqrt()是开根号的函数，使用时需引入头文件&lt;math.h&gt;。</p>
<h6 id="上学迟到"><a href="#上学迟到" class="headerlink" title="上学迟到"></a>上学迟到</h6><p>学校和 yyy 的家之间的距离为 s 米，而 yyy 以 v 米每分钟的速度匀速走向学校。</p>
<p>在上学的路上，yyy 还要额外花费 10 分钟的时间进行垃圾分类。</p>
<p>学校要求必须在上午 8:00 到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。</p>
<p>由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s,v,t,a,b,c,d,hour,min;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s,&amp;v);</span><br><span class="line">	t=s/v+<span class="number">10</span>;  <span class="comment">//计算所需总时间（min) </span></span><br><span class="line">	<span class="keyword">if</span>(s%v) &#123;t=t+<span class="number">1</span>;&#125; <span class="comment">//考虑时间计算，整形数据会忽略小数（秒），当有小数（秒）时，分钟+1； </span></span><br><span class="line">	hour=t/<span class="number">60</span>;  <span class="comment">//划分数据为时和分； </span></span><br><span class="line">	min=t%<span class="number">60</span>;  </span><br><span class="line">	<span class="keyword">if</span>(t&gt;=<span class="number">1440</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;输入条件无效，提前时间大于24小时。&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(hour&gt;<span class="number">8</span>) &#123;hour=<span class="number">8</span>+<span class="number">24</span>-hour;a=hour/<span class="number">10</span>;b=hour%<span class="number">10</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">8</span>&gt;hour&gt;<span class="number">0</span>)&#123;a=<span class="number">0</span>;b=<span class="number">8</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour==<span class="number">0</span>)&#123;a=<span class="number">0</span>;b=<span class="number">7</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(min!=<span class="number">0</span>) &#123;min=<span class="number">60</span>-min;c=min/<span class="number">10</span>;d=min%<span class="number">10</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;c=d=<span class="number">0</span>;&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d%d:%d%d\n&quot;</span>,a,b,c,d);</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍有麻烦的就是补零和时间格式。根据chatgpt建议修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s,v,t,hour,min;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s,&amp;v);</span><br><span class="line">	t=s/v+<span class="number">10</span>;  <span class="comment">//计算所需总时间（min) </span></span><br><span class="line">	<span class="keyword">if</span>(s%v) &#123;t=t+<span class="number">1</span>;&#125; <span class="comment">//考虑时间计算，整形数据会忽略小数（秒），当有小数（秒）时，分钟+1； </span></span><br><span class="line">	hour=t/<span class="number">60</span>;  <span class="comment">//划分数据为时和分； </span></span><br><span class="line">	min=t%<span class="number">60</span>;  </span><br><span class="line">	<span class="keyword">if</span>(t&gt;=<span class="number">1440</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;输入条件无效，提前时间大于24小时。&quot;</span>);&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(hour&gt;<span class="number">8</span>) &#123;hour=<span class="number">8</span>+<span class="number">24</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour&lt;<span class="number">8</span>&amp;&amp;hour&gt;<span class="number">0</span>) &#123;hour=<span class="number">8</span>-hour;&#125;</span><br><span class="line">			<span class="keyword">if</span>(hour==<span class="number">0</span>) &#123;hour=<span class="number">7</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(min==<span class="number">0</span>) &#123;min=<span class="number">60</span>;&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d\n&quot;</span>,hour,<span class="number">60</span>-min);</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在条件判断语句 <code>8 &gt; hour &gt; 0</code> 中，C 语言不支持连续的比较操作符(但我的编译器Dve能通过)。四位数的拆分可以通过输出格式前导零简化。<em>不过还是没有通过洛谷的条件检测。可能有瑕疵尚未发现。</em></p>
<h6 id="大象喝水"><a href="#大象喝水" class="headerlink" title="大象喝水"></a>大象喝水</h6><p>一只大象口渴了，要喝 2020 升水才能解渴，但现在只有一个深 <em>h</em> 厘米，底面半径为 <em>r</em> 厘米的小圆桶 （h* 和 <em>r</em> 都是整数）。问大象至少要喝多少桶水才会解渴。这里我们近似地取圆周率 π&#x3D;3.14。</p>
<p>输入格式：</p>
<p>输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 <em>h</em> 和底面半径 <em>r</em>，单位都是厘米。</p>
<p>输出格式：</p>
<p>输出一行，包含一个整数，表示大象至少要喝水的桶数。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712164136390.png" class="" title="image-20230712164136390">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h,r,v,k;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;h,&amp;r);</span><br><span class="line">	v=<span class="number">3.14</span>*r*r*h*<span class="number">100</span>; <span class="comment">//多乘100，保存精度并且是整形方便计算 </span></span><br><span class="line">	k=<span class="number">2000000</span>/v;    <span class="comment">//相应的，20升也变为2000升。 </span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2000000</span>%v) &#123;k=k+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟没有2.5桶水，也不能四舍五入。所以引入条件判断。</p>
<h6 id="小鱼的游泳时间"><a href="#小鱼的游泳时间" class="headerlink" title="小鱼的游泳时间"></a>小鱼的游泳时间</h6><p>伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。</p>
<p>这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 2424 小时制计算），它发现自己从 <em>a</em> 时 <em>b</em> 分一直游泳到当天的 <em>c</em> 时 d* 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？</p>
<p>输入格式：</p>
<p>一行内输入四个整数，以空格隔开，分别表示题目中的 �,�,�,�<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>。</p>
<p>输出格式：</p>
<p>一行内输出两个整数 <em>e</em> 和 <em>f</em>，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 <em>f</em> 应该小于 6060。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712175006634.png" class="" title="image-20230712175006634">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">	f=(c-a)*<span class="number">60</span>+d-b;</span><br><span class="line">	e=f/<span class="number">60</span>;</span><br><span class="line">	f=f%<span class="number">60</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,e,f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="小玉买文具"><a href="#小玉买文具" class="headerlink" title="小玉买文具"></a>小玉买文具</h6><p>班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 11 元 99 角，而班主任给小玉的钱是 <em>a</em> 元 <em>b</em> 角，小玉想知道，她最多能买多少只签字笔呢。</p>
<p>输入格式：</p>
<p>输入只有一行两个整数，分别表示 <em>a</em> 和 <em>b</em>。</p>
<p>输出格式：</p>
<p>输出一行一个整数，表示小玉最多能买多少只签字笔。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712180113375.png" class="" title="image-20230712180113375">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	c=a*<span class="number">10</span>+b;   <span class="comment">//计算现金为多少角 </span></span><br><span class="line">	c=c/<span class="number">19</span>;    <span class="comment">//1元9角为19角 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h6><p>牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：</p>
<p>总成绩&#x3D;作业成绩×20%+小测成绩×30%+期末考试成绩×50%</p>
<p>牛牛想知道，这门课程自己最终能得到多少分。</p>
<p>输入格式：</p>
<p>三个非负整数 A*,<em>B</em>,<em>C</em>，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是100 分。</p>
<p>输出格式：</p>
<p>一个整数，即牛牛这门课程的总成绩，满分也是 100 分。</p>
<img src="/2023/07/12/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/image-20230712180509212.png" class="" title="image-20230712180509212">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a,b,c,x;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	x=a*<span class="number">0.2</span>+b*<span class="number">0.3</span>+c*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>洛谷C语言练习题目</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
